<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<?xml-stylesheet ekr_test ?>
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="leo.20151212173315.1"><vh>@settings</vh>
<v t="leo.20151212173315.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="leo.20151212173315.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="amd.20160106095324.1" a="E"><vh>@path ./../</vh>
<v t="leo.20151213173811.1" a="E"><vh>假如要送到 gh-pages 分支, 使用下列按鈕</vh>
<v t="leo.20151212173658.1"><vh>@button gh-pages pelican</vh></v>
</v>
<v t="leo.20151213173830.1" a="E"><vh>假如要在近端檢視, 使用下列按鈕</vh>
<v t="leo.20151213085727.1"><vh>@button local pelican</vh></v>
</v>
<v t="ibm.20160115125316.1"><vh>管理者在產生遠端資料前, 定期清理 post 目錄</vh></v>
<v t="ibm.20160115125101.1"><vh>@button git rm -fr post</vh></v>
<v t="amd.20151215180106.1"><vh>設定與開發</vh>
<v t="amd.20151216151325.1"><vh>@edit index.html</vh></v>
<v t="amd.20151216152209.1"><vh>@edit README.md</vh></v>
<v t="amd.20160118111604.1"><vh>@edit LICENSE</vh></v>
<v t="amd.20160118111653.1"><vh>@edit .gitignore</vh></v>
<v t="leo.20151213230723.1"><vh>Pelican 設定</vh>
<v t="leo.20151213230957.1"><vh>文章 Date 設定</vh></v>
<v t="leo.20151213230729.1"><vh>使用 summary plugin</vh></v>
</v>
<v t="amd.20151215170117.1"><vh>以下 pellicanconf.py 為近端與遠端的共同設定</vh></v>
<v t="leo.20151212173725.1"><vh>@edit pelicanconf.py</vh></v>
<v t="amd.20151215170142.1"><vh>以下 publishconf.py 為遠端所使用的設定</vh></v>
<v t="leo.20151212173803.1"><vh>@edit publishconf.py</vh></v>
<v t="amd.20151215170221.1"><vh>以下 local_publishconf.py 為近端所使用的設定</vh></v>
<v t="leo.20151213085752.1"><vh>@edit local_publishconf.py</vh></v>
<v t="amd.20160120180714.1" a="E"><vh>@path theme</vh>
<v t="amd.20160120180720.1" a="E"><vh>@path pelican-bootstrap3</vh>
<v t="amd.20160120180746.1" a="E"><vh>@path templates</vh>
<v t="amd.20160120180758.1"><vh>@edit base.html</vh></v>
</v>
</v>
<v t="amd.20160325234732.1" a="E"><vh>@path pelican-bootstrap3_local</vh>
<v t="amd.20160325234743.1" a="E"><vh>@path templates</vh>
<v t="amd.20160325234757.1"><vh>@edit base.html</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="amd.20160328205435.1"><vh>Wordpress 端</vh>
<v t="amd.20160328205435.2" a="E"><vh>@button new to wp (pelican)</vh>
<v t="amd.20160328205435.3"><vh>md 檔案的格式</vh></v>
<v t="amd.20160328205435.4"><vh>將 md 節點內容送到 Wordpress 方法</vh></v>
</v>
<v t="amd.20160328205435.5"><vh>@button edit to wp (pelican)</vh></v>
<v t="amd.20160328205435.6" a="E"><vh>@button get from wp (pelican)</vh>
<v t="amd.20160328205435.7"><vh>程式設計考量</vh></v>
</v>
<v t="amd.20160328205435.8"><vh>Leo Editor 程式開發</vh></v>
<v t="amd.20160329161653.1" a="E"><vh>Raspberry Pi 專案</vh>
<v t="amd.20160329161726.1"><vh>audio output 設定</vh></v>
</v>
</v>
<v t="amd.20160410195347.1"><vh>blockdiag</vh>
<v t="amd.20160410195347.2"><vh>@button blockdiag</vh></v>
<v t="amd.20160410195347.3"><vh>blockdiag</vh></v>
<v t="amd.20160410195347.4"><vh>@button nwdiag</vh></v>
<v t="amd.20160410195347.5"><vh>nwdiag</vh></v>
</v>
<v t="amd.20160531095449.1"><vh>Brython 程式開發</vh>
<v t="amd.20160531095458.1"><vh>參考用</vh></v>
</v>
<v t="amd.20151215170350.1"><vh>以下為 content 目錄中的 md 檔案</vh></v>
<v t="amd.20160106093610.1"><vh>協同網誌編寫規範</vh></v>
<v t="amd.20151216001126.1"><vh>md 檔案範例</vh></v>
<v t="amd.20151215170031.1" a="E"><vh>@path ./../content</vh>
<v t="amd.20160531120758.1"><vh>@path by</vh>
<v t="amd.20160531120808.1"><vh>@edit spur.js</vh></v>
</v>
<v t="amd.20160531094803.1"><vh>Brython 程式庫</vh></v>
<v t="amd.20160106093454.1" a="E"><vh>yen 網誌文章</vh>
<v t="amd.20160605111320.1"><vh>before 201606</vh>
<v t="amd.20160106093510.1"><vh>201601</vh>
<v t="ibm.20160115121941.1"><vh>@clean yen_20160115.md</vh></v>
<v t="amd.20160117143423.1"><vh>@clean yen_20160117.md</vh>
<v t="amd.20160328210705.1"><vh>30</vh></v>
</v>
<v t="amd.20160120213235.1"><vh>@clean yen_20160120.md</vh></v>
</v>
<v t="amd.20160215161310.1"><vh>201602</vh>
<v t="amd.20160215161329.1"><vh>@clean yen_20160215.md</vh></v>
<v t="amd.20160223120511.1"><vh>@clean yen_20160223.md</vh>
<v t="amd.20160328210652.1"><vh>28</vh></v>
</v>
<v t="amd.20160321205838.1"><vh>@clean yen_20160321.md</vh>
<v t="amd.20160328210546.1"><vh>26</vh></v>
</v>
<v t="amd.20160325212631.1"><vh>@clean yen_20160325.md</vh>
<v t="amd.20160328210538.1"><vh>24</vh></v>
</v>
<v t="amd.20160325231101.1"><vh>@clean yen_20160325-1.md</vh>
<v t="amd.20160328210441.1"><vh>22</vh></v>
</v>
<v t="amd.20160329110611.1"><vh>@clean yen_20160329.md</vh>
<v t="amd.20160329120546.1"><vh>33</vh></v>
</v>
<v t="amd.20160329122032.1"><vh>@clean yen_20160329-1.md</vh>
<v t="amd.20160331205814.1"><vh>35</vh></v>
</v>
<v t="amd.20160331195141.1"><vh>@clean yen_20160331.md</vh>
<v t="amd.20160331205819.1"><vh>37</vh></v>
</v>
<v t="amd.20160401141633.1"><vh>@clean yen_20160401.md</vh></v>
<v t="amd.20160401230037.1"><vh>@clean yen_20160401-1.md</vh></v>
<v t="amd.20160402103950.1"><vh>@@clean yen_20160402.md</vh></v>
</v>
<v t="amd.20160412201150.1"><vh>201604</vh>
<v t="amd.20160412201156.1"><vh>@clean yen_20160412.md</vh></v>
</v>
<v t="amd.20160506230749.1"><vh>201605</vh></v>
<v t="amd.20160506230801.1"><vh>@clean yen_20160506.md</vh>
<v t="amd.20160506235635.1"><vh>43</vh></v>
</v>
<v t="amd.20160514153227.1"><vh>@clean yen_20160514.md</vh></v>
<v t="amd.20160515165148.1"><vh>@clean yen_20160515.md</vh></v>
<v t="amd.20160517115058.1"><vh>@clean yen_20160517.md</vh></v>
<v t="amd.20160518215337.1"><vh>@clean yen_20160518.md</vh>
<v t="amd.20160518215339.1"><vh>57</vh></v>
</v>
<v t="amd.20160521222238.1"><vh>@clean yen_20160521.md</vh></v>
<v t="amd.20160527201408.1"><vh>@clean yen_20160527.md</vh></v>
<v t="amd.20160527213220.1"><vh>@clean yen_20160527-1.md</vh></v>
<v t="amd.20160529144234.1"><vh>@clean yen_20160529.md</vh></v>
<v t="amd.20160529155022.1"><vh>@clean yen_20160529-1.md</vh></v>
</v>
<v t="amd.20160605111404.1" a="E"><vh>201606</vh>
<v t="amd.20160603225335.1"><vh>@clean yen_20160603.md</vh></v>
<v t="amd.20160605104719.1"><vh>@clean yen_20160605.md</vh>
<v t="amd.20160605104725.1"><vh>68</vh></v>
</v>
<v t="amd.20160605104803.1"><vh>@clean yen_20160605-1.md</vh>
<v t="amd.20160605104803.2"><vh>85</vh></v>
</v>
<v t="amd.20160608105837.1"><vh>@clean yen_20160608.md</vh></v>
<v t="amd.20160614093804.1"><vh>@clean yen_20160614.md</vh></v>
<v t="amd.20160614172648.1"><vh>@clean yen_20160614-2.md</vh></v>
<v t="amd.20160615082003.1"><vh>@clean yen_20160615.md</vh></v>
<v t="amd.20160618114526.1"><vh>@clean yen_20160618.md</vh></v>
<v t="amd.20160618115606.1"><vh>@clean yen_20160618-1.md</vh></v>
</v>
</v>
</v>
<v t="amd.20160106094754.1"><vh>@path ./../content/pages</vh>
<v t="amd.20160106094829.1" a="E"><vh>yen pages 文章</vh>
<v t="amd.20160106094844.1"><vh>@edit yen_pages_1.md</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="amd.20151215170031.1"></t>
<t tx="amd.20151215170117.1"></t>
<t tx="amd.20151215170142.1"></t>
<t tx="amd.20151215170221.1"></t>
<t tx="amd.20151215170350.1"></t>
<t tx="amd.20151215180106.1"></t>
<t tx="amd.20151216001126.1">@language md
Title: 文章標題
Category: 類別
Tags: 標籤
Author: kmol

這裡放入文章摘要

&lt;!-- PELICAN_END_SUMMARY --&gt;

這裡為文章主要內容</t>
<t tx="amd.20160106093454.1"></t>
<t tx="amd.20160106093510.1"></t>
<t tx="amd.20160106093610.1">協同成員的 .leo 檔案

    每一位協同者, 各自可以在 users 目錄下擁有一個 .leo 檔案, 用來維護各自位於 content 目錄下的 .md 檔案,
    
    例如: user yen 的 .leo 檔案位於 users/yen.leo

協同成員的 .md 檔案命名

    由於各成員所編寫的 .md 檔案都位於 content 目錄下, 因此必須在各負責的 .md 檔案名稱冠上用戶名稱,
    
    例如: 由 yen 負責編寫的 .md 檔案, 特別命名為 yen_20160106.md, 若一天有兩篇以上文章, 則取 yen_20160106-1.md
    
    當使用者要利用 pelican 在近端轉換網誌時, 必須使用 local-pelican 按鈕, 若要送到 github pages 網站, 則必須透過 gh-pages-pelican 按鈕轉檔.

pages 文章

    寫在 content/pages 目錄中的 .md 檔案, 將會被轉為網誌 pages 內容

</t>
<t tx="amd.20160106094754.1"></t>
<t tx="amd.20160106094829.1"></t>
<t tx="amd.20160106095324.1"></t>
<t tx="amd.20160117143423.1">@language md
Title: 導入 Ubuntu 操作系統
Category: 導引
Tags: Ubuntu, Mechanical Design
Author: kmol
@others
身為一位機械設計工程系的學生, 有機會在 Ubuntu 操作系統上工作嗎?

&lt;!-- PELICAN_END_SUMMARY --&gt;

自從 1995 年, 第1套能在 Windows 操作系統執行的電腦輔助機械設計繪圖軟體套件, SolidWorks, 出現, 並且逐步蔚為風潮之後,  MCAD (Mechanical Computer Aided Design) 中端套件, 幾乎都只能在 Windows 操作系統上運作. 許多機械設計工程系相關師生, 幾乎早已經忘記, 最早的 MCAD 系統可都是在泛 Unix based 的操作系統上運作.

時間轉到 2015 年, Onshape: &lt;http://www.onshape.com&gt; 的出現, 雖然截至目前只提供陽春的 MCAD 功能, 但是至少讓原本必須在 Windows 操作系統上才能上課的約束條件, 頓時消失, 因為計算機程式、網際內容管理、電腦輔助設計實習與協同產品設計實習等課程, 已經能夠百分之百在 Ubuntu 操作系統上運作.

過去, 我們在 Windows 操作系統上的工作類別, 不外乎:

1. 文書處理
2. 程式編寫與執行
3. MCAD 零件繪圖, 零件組立
4. MCAE 工程分析
5. 擷取執行畫面
6. 錄製操作流程影片
7. 遠端登入到其他電腦 (Remote Desktop)

以下將就這些工作分類, 介紹在 Ubuntu 操作系統中的相對應工具與使用方法.

首先, 這裡建議的 Ubuntu 操作系統為 Ubuntu Server 版本加上 ubuntu-desktop 套件的安裝.

一旦安裝完成, 第1項文書處理工作就可以由 LibreOffice 套件加以勝任.

## 程式編寫與執行

這裡包含 Python3, PyQt5, Leo Editor, SciTE, Git 等套件都是跨操作系統, 其中 Python3  已經內建在 Ubuntu 14.04 操作系統中, 只是必須透過 python3 執行, 例如: 必須在命令列中, 輸入 python3 帶出互動式解譯環境.

pip3 模組則需要透過 sudo apt-get install python3-pip 安裝

PyQt5 則需要透過 sudo apt-get install python3-pyqt5 安裝

Leo Editor 透過 sudo pip3 install https://github.com/leo-editor/leo-editor/archive/master.zip 安裝, 並且以 leo&amp; 呼叫

SciTE 透過 sudo apt-get install scite 安裝

git 透過 sudo apt-get install git 安裝

## MCAD 零件與組件繪圖

這裡採用 &lt;http://www.onshape.com&gt;, 只需要 Firefox 或 Chromium 瀏覽器就可以運作

FreeCAD: &lt;http://www.freecadweb.org/&gt; 與 Solvespace: &lt;http://solvespace.com/&gt;, 則是能在 Ubuntu 環境運作的 MCAD 套件.

## MCAE 工程分析

這裡採用 &lt;http://www.simscale.com&gt;, 只需要 Firefox 或 Chromium 瀏覽器就可以運作

COMSOL &lt;a href="https://www.comsol.com/system-requirements"&gt;可以&lt;/a&gt;在 Ubuntu 環境中運作

Ansys 則&lt;a href="http://www.ansys.com/-/media/Ansys/corporate/files/pdf/solutions/it-professionals/platform-support/platformsupportansys162stategyandplans.pdf?la=en"&gt;建議&lt;/a&gt;在 Red Hat 或 SUSE 商用版上運作

## 錄製操作流程影片

在 Ubuntu 操作系統中擷取電腦螢幕畫面, 只要按下 PrintScr 按鍵, 就可以直接存為 png 格式檔案

操作流程則可以使用 Kazam 將過程錄成 mp4檔案

Kazam: &lt;https://code.launchpad.net/~kazam-team/kazam/stable&gt; (以 Python 編寫)

安裝:

&lt;pre class="brush: python"&gt;
sudo add-apt-repository ppa:kazam-team/stable-series
sudo apt-get update
sudo apt-get install kazam
&lt;/pre&gt;

使用: kazam&amp;

至於在 Ubuntu 遠端登入到 Windows, 可以使用 Ubuntu Software Center 安裝 remmina, 並且在連線設定上的 Advanced 頁面中, Security 選用 RDP 協定, 即可正確連線.

## Ubuntu 檔案架構

* /bin ­­ binary applications (most of your executable files) 
* /boot ­­ files required to boot (such as the kernel, etc) 
* /dev ­­ your devices (everything from drives to displays) 
* /etc ­­ just about every configuration file for your system 
* /etc/rc.d ­­ contains a number of shell scripts that are run on bootup at different run levels. 
* /etc/X11 ­­ configuration files for the X Window system 
* /home ­­ locally stored user files and folders 
* /lib ­­ system libraries (similar to Program Files) 
* /media ­­ mounted (or loaded) devices such as cdroms, digital cameras, etc. 
* /mnt ­­ mounted file systems 
* /opt ­­ location for “optionally” installed programs 
* /sbin ­­ system ­only binaries
* /sys ­­ contains information about the system 
* /tmp ­­ temporary files 
* /usr ­­ applications mainly for regular users 
* /var ­­ mainly logs, databases, etc. 

## Ubuntu 常用指令

* ls : list directory contents
* cd : Change Directory
* pwd : print the current/working directory
* mkdir : make/create directory
* rmdir : remove the empty directory
* rm : remove/delete file
* mv : rename or move a file/directory
* man : Manual pages for shell commands
* cp : Copy Files
* passwd : Change password for user
* tar : Creates and extracts files from a tape or disk archive
* find :  find searches the file located at /
* grep :  print lines matching a pattern
* chown :  change file owner and group
* chgrp :  change group ownership
* chmod :  change file mode bits
* ifconfig :  configure a network interface

參考資料:

1. &lt;a href="https://help.ubuntu.com/lts/serverguide/serverguide.pdf"&gt;https://help.ubuntu.com/lts/serverguide/serverguide.pdf&lt;/a&gt;
2. &lt;a href="http://ecourts.nic.in/2/mannual/admin_manual.pdf"&gt;http://ecourts.nic.in/2/mannual/admin_manual.pdf&lt;/a&gt;
3. &lt;a href="http://wiki.lib.sun.ac.za/images/7/7b/Ubuntu-desktop.pdf"&gt;http://wiki.lib.sun.ac.za/images/7/7b/Ubuntu-desktop.pdf&lt;/a&gt;
4. &lt;a href="http://askubuntu.com/questions/154121/why-wont-remmina-connect-to-windows-7-remote-desktop"&gt;http://askubuntu.com/questions/154121/why-wont-remmina-connect-to-windows-7-remote-desktop&lt;/a&gt;





</t>
<t tx="amd.20160120180714.1"></t>
<t tx="amd.20160120180720.1"></t>
<t tx="amd.20160120180746.1"></t>
<t tx="amd.20160120213235.1">@language md
Title: Bezier 曲線導引
Category: 導引
Tags: Javascript, 程式
Author: kmol
@others
A primer on Bezier curves

&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;http://pomax.github.io/bezierinfo/&gt;

&lt;http://pomax.github.io/bezierjs/&gt;

嘗試將純 Javascript 的環境轉為 Brython based &lt;https://github.com/brython-dev/brython&gt;, 希望完成之後, 可以讓使用者編寫 Python3 程式碼來操控 Bezier 曲線 &lt;https://en.wikipedia.org/wiki/B%C3%A9zier_curve&gt;.

</t>
<t tx="amd.20160215161310.1"></t>
<t tx="amd.20160215161329.1">@language md
Title: KMOL 2016 Spring Portable Tool
Category: 資源
Tags: 可攜套件, 2016Spring
Author: kmol
@others
針對 cadlab 上計算機程式、網際內容管理、電腦輔助設計實習與協同產品設計實習等課程, 採用 Python 3.4 打造的 Windows 版可攜程式套件

&lt;!-- PELICAN_END_SUMMARY --&gt;

可攜套件倉儲:

&lt;https://github.com/chiamingyen/kmol2016&gt;

kmol2016 下載:

&lt;https://my.pcloud.com/publink/show?code=XZH5J4ZOj9C9aomi5F1DtnuQNIHYLDO7EjX&gt;</t>
<t tx="amd.20160223120511.1">@language md
Title: Cadlab 的理想設置
Category: 參考
Tags: CADLAB
Author: kmol
@others
一個符合二十一世紀工學院實際需求的電腦輔助設計室, 應該如何規劃配置?

&lt;!-- PELICAN_END_SUMMARY --&gt;

Cadlab 是個熱門的名詞, 代表 Computer Aided Design Laboratory, 也就是電腦輔助設計實驗室, 或簡稱電腦輔助設計室.

過去的電腦輔助設計室, 充滿各種讓使用者進行電腦輔助設計的公用電腦, 加上部份伺服器提供相關設計運算或資料儲存之用, 而現在, 這樣的配置可能不再恰當, 尤其是一間配置著 60 幾台最新硬體的桌上型電腦, 但卻採用所謂的防寫卡進行硬碟保護的電腦, 倘若無法隨時配合著經常性的操作系統或應用軟體更新, 這樣的 Cadlab 配置, 更是錯上加錯.

其實, 二十一世紀的工學院, 所有課程都應該在數位網路環境中進行, 因此所有這些所謂未來的工程師, 就應該在入學的第1天就被配予一台 17 寸的筆記型電腦, 而且裝載著各種未來幾年甚至離開學校之後, 都還能夠合法使用的相關專業用軟硬體套件.

過去, 由於全球協同的步調較慢, 各種產品的生命週期時間較長, 因此允許學校與產業界的差異性容忍度較大, 但是, 近幾年在在各種資訊與通訊軟硬體的快速發展衝擊下, 不僅全球協同的步調加速, 各種產品的生命週期愈來愈短, 促使學校教育單位與產業界必須在某些層面上攜手同步, 否則終將無法培育出適才、適所與適任的未來工程師.

而且, 隨著可攜裝置與自造軟硬體的逐步普及, Cadlab 配置中的所謂電腦, 除了包括讓工程師可以隨身攜帶的筆記型電腦以外, 還必須包括各類微控制器與 3D 印表機, 讓 Cadlab 實驗室中的各種系統模擬, 可以透過初步的硬體原型測試基本的可行性.

</t>
<t tx="amd.20160321205838.1">@language md
Title: CADLab 網路配線繪圖
Category: 參考
Tags: CADLAB, network
Author: kmol
@others
利用程式方法執行網路配線繪圖

&lt;!-- PELICAN_END_SUMMARY --&gt;

CADLab 中的網路配線圖, 就如同 &lt;a href="http://blockdiag.com/en/"&gt;http://blockdiag.com/en/&lt;/a&gt; 專案所示, 可以利用語法描述參數與配置之後, 透過程式方法轉出結果.

以 nwdiag &lt;a href="https://bitbucket.org/blockdiag/nwdiag"&gt;https://bitbucket.org/blockdiag/nwdiag&lt;/a&gt; 為例, 在只有 Python3 的 Windows 環境中安裝:

pip install nwdiag

之後就可以利用 nwdiag 命令解讀 .diag network diagram 描述檔, 並且轉為 png 或 svg 格式.

假如是在同時裝有 Python2 與 Python3 的 Ubuntu 環境中安裝 nwdiag:

pip3 install nwdiag

之後的應用與 Windows 環境相同.

&lt;a href="http://blockdiag.com/en/"&gt;http://blockdiag.com/en/&lt;/a&gt; 專案還有方塊圖 blockdiag, 序列圖 seqdiag 以及活動圖 actdiag 等相關繪圖的應用.

最後假如 CADLab 希望利用 Sphinx 來整理電腦輔助設計室的文件, 則可以套用 &lt;a href="https://github.com/blockdiag"&gt;https://github.com/blockdiag&lt;/a&gt; 中的 extensions 工具.

</t>
<t tx="amd.20160325212631.1">@language md
Title: CADLab 學員卡片電腦規格與應用
Category: 參考
Tags: CADLAB, raspberrypi
Author: kmol
@others
卡片電腦 (credit-card sized computer) 的盛行, 除了在操作系統上有機會讓 CADLab 的學員, 得以學習 Windows 10 以外的應用, 最大的功用, 是讓機械設計工程專長的學員能夠實際動手, 理解網路的整合, 並且迎接自造 (self-manufacturing) 時代的蒞臨.

&lt;!-- PELICAN_END_SUMMARY --&gt;

## Raspberry Pi 3 電腦

當一間嚴格管理, 軟硬體配置僵化的 CADLab 電腦輔助設計室已經無法滿足現代機械設計科技人才的培育使用時, 導入以 &lt;a href="https://www.raspberrypi.org/products/raspberry-pi-3-model-b/"&gt;Raspberry Pi 3 Model B&lt;/a&gt; 為基礎的個人隨身卡片電腦, 應該是個不錯的選擇.

2016 年 2 月份推出的這一片採用 1.2GHz 64-bit quad-core ARMv8 CPU 的小卡片電腦, 不僅能夠用來控制 &lt;a href="http://delta.firepick.org/"&gt;http://delta.firepick.org/&lt;/a&gt;, 可以安裝執行 &lt;a href="https://github.com/jupyter/jupyterhub"&gt;Jupyter hub&lt;/a&gt;, 而且在 &lt;a href="https://www.raspberrypi.org/downloads/noobs/"&gt;Noobs&lt;/a&gt; 操作系統套件中, 還&lt;a href="https://www.raspberrypi.org/blog/mathematica-10/"&gt;內建&lt;/a&gt;免費的非營利版 Mathematica.

以下是我們建議學員自備的 Raspberry Pi 3 Model B 卡片電腦規格:

處理器:

Broadcom BCM2387 晶片組，1.2GHz 四核心 ARM Cortex-A53.802.11 b/g/n 無線 LAN 和藍牙 4.1

GPU:

雙核心 VideoCore IVR 多媒體協同處理器。提供 Open GL ES 2.0、硬體加速 OpenVG，以及 1080p30 H.264 高型解碼。支援 1Gpixel/s、1.5Gtexel/s 或 24GFLOPs，並具備材質過濾功能與 DMA 基礎架構
    
記憶體:

1GB LPDDR2
    
作業系統:

由 Micro SD 記憶卡(建議使用 32 GB 以上) 啟動，建議安裝 Raspbian 操作系統
    
尺寸:

85 x 56 x 17mm

電源:

Micro USB 插槽 5V1，2.5A

##Raspbian 安裝配置

當學員拿到 Raspberry Pi 3 卡片電腦之後, 首次配置時, 建議使用 CADLab 教室中的 HDMI 線連接到支援 HDMI 的電腦螢幕後, 進行 &lt;a href="https://www.raspberrypi.org/downloads/raspbian/"&gt;Raspbian&lt;/a&gt; 操作系統的安裝, 安裝後則必須開啟 SSH 的連線, 並且編輯 /etc/lightdm/lightdm.conf 設定檔, 將 [XDMCPServer] 項下的 enabled 設為 true.

##CADLab 卡片電腦使用情境

完成 Raspbin 系統安裝後, Raspberry Pi 3 電腦在 CADLab 教室使用, 共有兩種基本情境:

###連接滑鼠鍵盤螢幕開機

目前的 CADLab 電腦配置, USB 鍵盤與滑鼠的接頭是採隱藏式保護, 因此學員無法直接以公用的滑鼠與鍵盤連接 Raspberry Pi 3 卡片電腦, 但是若新配置的新電腦設備允許學員使用公用的 USB 鍵盤與滑鼠, 並且提供支援 HDMI 格式的電腦螢幕, 用戶就可以很單純直接用自行攜入的 Raspberry Pi 3 開機使用. 開機後, 可以透過 CADLab 中的 Wifi 連線 (Raspberry Pi 3 Model B 內建 802.11n Wireless LAN) 或實體線 (每桌必須提供 4 或 8 port hub) 上網, 使用較為簡單.

###無滑鼠鍵盤螢幕開機

若新配置的 CADLab  電腦設備並不允許學員使用公用的滑鼠與鍵盤, 且桌上並無 hub 可用, 則建議 Raspberry Pi 3 使用者, 可以自帶一條網路跳線, 利用桌上型電腦的多 NIC 連線, 以 &lt;a href="https://sourceforge.net/projects/dhcpserver/"&gt;https://sourceforge.net/projects/dhcpserver/&lt;/a&gt; 發給 Raspberry Pi 3 電腦臨時的內部網路 IP, 然後再利用 &lt;a href="https://sourceforge.net/projects/xming/"&gt;https://sourceforge.net/projects/xming/&lt;/a&gt;, 以 XDMCP 協定 (只建議在內部網路使用, 廣域網路上, 建議採較安全的 SSH 連線), 登入 Raspberry Pi 3, 並且以 Wifi 連線到 CADLab 的 Access Point 後, 確定連線的 IP 位址後, 就可以移除與桌上型電腦的網路跳線, 改採與桌上型電腦同位階的內部網路上網, 然後透過桌上型電腦的 Putty, 以 SSH 連線到 Raspberry Pi 3 進行操控, 或者再透過 xming, 以 XDMCP 協定登入.

另外, 假如 Raspberry Pi 3 電腦並無與電腦教室其他電腦設備連線的要求, 用戶希望利用網路跳線與桌機相連後上網, 則建議在桌機上使用代理程式 &lt;a href="http://www.youngzsoft.net/ccproxy/"&gt;http://www.youngzsoft.net/ccproxy/&lt;/a&gt; 的免費版 (可以3個用戶使用), 讓 Raspberry pi 3 電腦以桌機的 proxy server 上網, 或者設法將桌上型電腦 Windows 7 或 10 操作系統上的第2片網路卡橋接到第1片已經上網的網卡上, Raspberry Pi 3 就可以藉此設定直接上網.

</t>
<t tx="amd.20160325231101.1">@language md
Title: CADLab CAD/E 軟體套件使用建議
Category: 資源
Tags: CADLAB, CAX
Author: kmol
@others
電腦輔助設計與工程分析是機械設計工程師進行 2D/3D 繪圖與理論分析表達的重要工具, 這裡是我們建議學員使用的 CAD/CAE 軟體套件.

&lt;!-- PELICAN_END_SUMMARY --&gt;

##CAD:

商用封閉單機套件:

SolidWorks 與 PTC Creo

雲端封閉套件(提供免費使用方案):

Onshape: &lt;a href="http://onshape.com"&gt;http://onshape.com&lt;/a&gt;

自由開源套件:

Solvespace: &lt;a href="http://solvespace.com/"&gt;http://solvespace.com/&lt;/a&gt;

FreeCAD: &lt;a href="http://www.freecadweb.org/"&gt;http://www.freecadweb.org/&lt;/a&gt;

##CAE:

商用封閉套件:

ansys 與 comsol

自由開源套件:

Elmer: &lt;a href="https://www.csc.fi/web/elmer"&gt;https://www.csc.fi/web/elmer&lt;/a&gt;

Kratos: &lt;a href="http://www.cimne.com/kratos"&gt;http://www.cimne.com/kratos&lt;/a&gt;

##數值運算:

商用封閉套件:

Matlab 與 Mathematica

自由開源套件:

Jupyter: &lt;a href="http://jupyter.org/"&gt;http://jupyter.org/&lt;/a&gt;


</t>
<t tx="amd.20160325234732.1"></t>
<t tx="amd.20160325234743.1"></t>
<t tx="amd.20160328205435.1"></t>
<t tx="amd.20160328205435.2">@language python
#coding: utf-8
import xmlrpc.client
import datetime
import os

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python
    # 用跳行符號分割
    data_list = data.split("\n")
    #第2行為 title
    title= data_list[1]
    #第3行為 category
    category = data_list[2]
    #第4行為 tags
    tags = data_list[3]
    # 有多項資料的 content 型別為數列
    # 再將第7行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[6:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 &lt;!-more-&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    content = content.replace('~~~python', '[code lang="python"]')
    content = content.replace('~~~', '[/code]')
    return title, category, tags, content
    
os.environ['TZ'] = 'Asia/Taipei'

#################################
filepath = "/home/amd/Desktop/wordpress-cadlab.rhcloud.com.txt"
wordpress = "wordpress-cadlab.rhcloud.com"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

# 從網誌節點的 parent().h 取得 wp_url
# 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑
wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################
wp_blogid = "0"
 
status_draft = 0
status_published = 1
 
server = xmlrpc.client.ServerProxy(wp_url)

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 指定時間出版
'''
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime("2013-01-01 00:00",
"%Y-%m-%d %H:%M"))
'''
# 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \
datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),"%Y-%m-%d %H:%M"))
categories = [category_str.split(":")[1]]
# 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料
# 先用 : 斷開標投頭的 Tags:, 然後再透過逗點隔開, 將標註轉為數列資料
tags = tags_str.split(":")[1].split(",")
data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags}
 
post_id = server.metaWeblog.newPost(wp_blogid, wp_username, wp_password, data, status_published)
# 利用最後的 child 節點來儲存 post_id
to_save_post_id = p.insertAsLastChild()   
# 改為內文為空的節點, id 直接標在 head 標題 
to_save_post_id.b = ""
to_save_post_id.h = post_id
# 因為新增節點, commander 必須 redraw
c.redraw() 

g.es("post_id 為", post_id)
g.es("已經送出資料!")

'''
其他 metaWeblog 的用法:
metaWeblog.newPost (blogid, username, password, struct, publish) returns string(postid)
metaWeblog.editPost (postid, username, password, struct, publish) returns true
metaWeblog.getPost (postid, username, password) returns struct(blog content)
'''</t>
<t tx="amd.20160328205435.3">第1行 

    Title: yen - Github Pages 網頁資料更新問題
    
第2行

    Category: Misc
    
第3行

    Tags: Github Pages
    
第4行

    Author: yen

&lt;!-- PELICAN_END_SUMMARY --&gt; 之前為 文章摘要

之後為文章內容, 但是

~~~python 必須換為 [code lang="python"]
~~~ 則換為 [/code]

然後再看看 &lt;a href="http://project.mde.tw"&gt;http://project.mde.tw&lt;/a&gt; 是否要直接採用 html anchor 或將

Pelican 的 &lt;http://project.mde.tw&gt; 轉為 html anchor 格式

此外, 將 .md 檔案的內容解讀後, 送到對應的 Wordpress 網站後, 將回傳在 .md 檔案的子節點, 加入一個"文章 id "的節點, 內文為該文章在 Wordpress 的 id 號碼

但是從 Pelican md 文章內容解讀後送到 Wordpress, 只支援 new 與 edit, 從 Wordpress 取回文章內容的流程還要再思考一下
</t>
<t tx="amd.20160328205435.4">滑鼠停在 .md 文章的對應節點, 然後按下 new-wp-pelican 按鈕,
完成後該 .md 節點下屬會傳回文章 id 節點, 標示在 Wordpress 的對應文章 id</t>
<t tx="amd.20160328205435.5">@language python
#coding: utf-8
import xmlrpc.client
import datetime
import os

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python
    # 用跳行符號分割
    data_list = data.split("\n")
    #第2行為 title
    title= data_list[1]
    #第3行為 category
    category = data_list[2]
    #第4行為 tags
    tags = data_list[3]
    # 有多項資料的 content 型別為數列
    # 再將第7行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[6:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 &lt;!-more-&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    content = content.replace('~~~python', '[code lang="python"]')
    content = content.replace('~~~', '[/code]')
    return title, category, tags, content
    
os.environ['TZ'] = 'Asia/Taipei'
 
#################################
filepath = "/home/amd/Desktop/wordpress-cadlab.rhcloud.com.txt"
wordpress = "wordpress-cadlab.rhcloud.com"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################
wp_blogid = "0"
 
status_draft = 0
status_published = 1
 
server = xmlrpc.client.ServerProxy(wp_url)

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 指定時間出版
'''
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime("2013-01-01 00:00",
"%Y-%m-%d %H:%M"))
'''
# 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \
datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),"%Y-%m-%d %H:%M"))
categories = [category_str.split(":")[1]]
# 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料
tags = tags_str.split(":")[1].split(",")
data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags}

# 設法取得原 post 的 id
origin_post = p.getLastChild()
# 直接從標題取得 post 的 id 號碼
post_id = origin_post.h
status = server.metaWeblog.editPost(post_id, wp_username, wp_password, data, status_published)

if status:
    g.es("資料已經更新!")
else:
    g.es("有問題, 資料沒有更新!")
'''
其他 metaWeblog 的用法:
metaWeblog.newPost (blogid, username, password, struct, publish) returns string(postid)
metaWeblog.editPost (postid, username, password, struct, publish) returns true
metaWeblog.getPost (postid, username, password) returns struct(blog content)
'''</t>
<t tx="amd.20160328205435.6">@language python
#coding: utf-8
import xmlrpc.client
# 導入 html 模組, 使用 html.unescape 轉換 html 特殊符號
import html
 
#################################
filepath = "/home/amd/Desktop/wordpress-cadlab.rhcloud.com.txt"
wordpress = "wordpress-cadlab.rhcloud.com"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

# 從網誌節點的 parent().h 取得 wp_url
# 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑
wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################

server = xmlrpc.client.ServerProxy(wp_url)

# 設法透過上述網誌網址, 帳號與密碼, 以及文章 id, 取回 categories, tags, 文章標題, 文章內容等資

# 從最後的 child 節點來取 post_id
origin_post = p.getLastChild()
post_id = origin_post.h
# 取回與 post_id 對應的網誌文章內容
blog_content = server.metaWeblog.getPost(post_id, wp_username, wp_password)
title = blog_content["title"]
# 這裡要利用 html.unescape 轉回特殊符號
description = html.unescape(blog_content["description"])
mt_text_more = html.unescape(blog_content["mt_text_more"])
if mt_text_more != "":
    post_content = description + "\n&lt;!--more--&gt;\n"+mt_text_more
else:
    post_content = description
# 所取回的 categories 為 list
categories = blog_content["categories"]
# 所取回的 tags 為以逗點隔開的字串
mt_keywords = blog_content["mt_keywords"]
# 取回文章作者
author = blog_content["wp_author_display_name"]
p.h = title
categories_str = ""
for category in categories:
    # 假如不是最後一個
    if category != categories[len(categories)-1]:
        categories_str += category + ", "
    else:
        # 這是最後一個
        categories_str += category
line1 = "@language md\n"
line2 = "Title: " +title + "\n"
line3 = "Category: " + categories_str + "\n"
line4 = "Tags: " + mt_keywords + "\n"
line5 = "Author: " + author + "\n@others\n"
post_content = post_content.replace('&lt;!--more--&gt;', '\n&lt;!-- PELICAN_END_SUMMARY --&gt;\n')
post_content = post_content.replace('[code lang="python"]', '~~~python')
post_content = post_content.replace('[/code]', '~~~')
p.b = line1 + line2 + line3 + line4 + line5 + post_content + "\n"
# 因為節點資料更新, commander 必須 redraw
c.redraw() 
g.es("資料已經取回")



</t>
<t tx="amd.20160328205435.7">俱備取回資料的權限

透過子節點的文章 id 與網誌網址, 以 xmlrpc 協定進行連線

取回 categories, tags, 文章標題與文章內容, 還有作者帳號?

分別按照格式, 將取回的資料放入對應節點

</t>
<t tx="amd.20160328205435.8">execute-script predefines:

c: The commander of the present outline.
g: The leo.core.leoGlobals module.
p: The presently selected position, c.p.</t>
<t tx="amd.20160328210441.1"></t>
<t tx="amd.20160328210538.1"></t>
<t tx="amd.20160328210546.1"></t>
<t tx="amd.20160328210652.1"></t>
<t tx="amd.20160328210705.1"></t>
<t tx="amd.20160329110611.1">@language md
Title: 電腦輔助設計室網路連線管理
Category: 規劃
Tags: CADLAB, Ｎetwork, IPV6
Author: kmol
@others
電腦輔助設計室長期以來都是在 IPV4 的架構下, 透過 NAT, 以共用一個網路位址上網, 若以整間教室 63 台電腦為例, 只需要設法利用 9 個固定的 IPV4 網路位址, 讓其中的 9 台電腦同時支援 IPV4 與 IPV6 協定, 並且透過 Squid 代理伺服器的設定, 就可以利用網路負載平衡, 大幅提升用戶的連網速度.

&lt;!-- PELICAN_END_SUMMARY --&gt;

自 2012 年起校園主幹就已經全面支援 IPV6 的網路協定, 但是由於台灣大部份的網站仍然只提供 IPV4 網址與協定連線, 因此即使在 IPV6 網址無虞的情況下, 讓每一台電腦輔助設計室的電腦都透過 IPV6 協定取得網址, 仍然需要 IPV4/IPV6 雙支援的代理主機, 才能連結使用所有的網站.

因此目前的規劃是, 讓 63 台電腦全部透過 IPV6 協定取得 IP 位址上網, 但是其中的 9 台電腦則以其中規劃好的第3磁區 Ubuntu Server 開機 (其他兩個開機磁區分別為 Windows 7 與 Windows 10), 而且這 9 台電腦是在預先綁定 MAC 位址到雙支援 IPV4/IPV6 的固定 IP 情況下, 自行透過 DNS 設定, 以 Round Robin 的簡單負載平衡, 來服務其他僅設定 IPV6 DHCP Client 連線的電腦.

其次, 學員自行攜入 CADLab 使用的 Raspberry Pi 3 隨身卡片電腦, 也可以利用 IEEE 802.11n 的協定取得 IPV6 位址, 然後也是透過雙支援的代理伺服器連線上網. 而使用 git 相關指令之前, 必須確定已經設定

git config --global http.proxy http://myproxy.server:port

git config --global https.proxy https://myproxy.server:port</t>
<t tx="amd.20160329120546.1"></t>
<t tx="amd.20160329122032.1">@language md
Title: 該如何編寫一份電腦輔助機械設計使用手冊
Category: 規劃
Tags: CADLAB, Ｍanual, MCAD
Author: kmol
@others
我們正在極力推廣使用的電腦輔助機械設計(Mechanical Computer Aided Design)相關套件, 包括 OnShape, Solvespace, FreeCAD, Elmer, V-rep 以及 Jupyter, 該如何用最"好"的方式來編寫使用手冊?

&lt;!-- PELICAN_END_SUMMARY --&gt;

假如您已經在使用 OnShape, 一定已經看過 &lt;a href="https://cad.onshape.com/help/"&gt;https://cad.onshape.com/help/&lt;/a&gt;. 對應的 Solvespce 導引 &lt;a href="http://solvespace.com/tutorial.pl"&gt;http://solvespace.com/tutorial.pl&lt;/a&gt; 也是很不錯, 其他的幾個套件, 也都已經有了不錯的英文導引資料, 只是從教導學員協力完成某件電腦輔助設計流程工作的同時, 我們想要試試在 Github 的版次管理模式下, 我們能夠怎樣協同編寫一份電腦輔助設計相關的網頁式手冊.

啟動:

在 Github cad-lab 帳號下新增一個倉儲, 命名為 manual, 然後 git clone 到本地端, 準備置入能夠協同編輯的 Leo Editor 與 Pelican 架構.

git clone https://github.com/cad-lab/manual.git cadlabmanual 之後, 進入 cadlabmanual 目錄, 利用 git branch gh-pages 建立 Github Pages 對應分支, 然後以 git checkout gh-pages 指令將本地端倉儲的工作目錄定位在 gh-pages 分支.

接下來就是放入 Pelican 靜態網頁系統, 就可以開始建立電腦輔助機械設計使用手冊了: &lt;a href="http://cad-lab.github.io/manual/"&gt;http://cad-lab.github.io/manual/&lt;/a&gt;

</t>
<t tx="amd.20160329161653.1"></t>
<t tx="amd.20160329161726.1">sudo amixer cset numid=3 &lt;output&gt;

0=auto
1=headphones
2=hdmi

使用 耳機

sudo amixer cset numid=3 1

使用 hdmi

sudo amixer cset numid=3 2</t>
<t tx="amd.20160331195141.1">@language md
Title: Gigabit 乙太網路線
Category: 規劃
Tags: CADLAB
Author: kmol
@others
目前在 CADLab 中使用的網路線為傳輸速率每秒十億 bit (10**9 bit/sec) 的 Category 6 Gigabit Ethernet. 採 1000BASE‑T 無遮蔽雙絞線, 以 EIA/TIA 568B 連接 RJ45 接頭. 其接線方式為接頭向前, 耳朵朝下, 混白線在前, 緊接著色線, 以橘藍綠棕排列後,  再將藍白與綠白對調, 就是 568B 的接法.

&lt;!-- PELICAN_END_SUMMARY --&gt;

至於 568B 的網路跳線則再將一邊的橘白與橘線, 跟綠白與綠線對調. 因為橘白線的 pin 1 為 Transmit Data+, 橘線 pin2 則是 Transmit Data-, 綠白線 pin3 則為 Receive Data+, 綠線 pin 6 為 Receive Data-. 藍線 pin 4 與棕白 pin 7 同為 Bi-directional+, 而藍白線 pin5 與棕線 pin 8 則同為 Bi-directional-. 為了達到規格中的 Gigabit 傳輸速度, 8 條線都要確實連接, 假如只有 pin 1, 2, 3, 6 接線, 則傳輸速度將會降為 100 Mega bit/sec. 另外, 1000BASE‑T 的無遮蔽雙絞銅線, 建議每段最長為 100 m.

EIA/TIA 568B 的標準雙絞線 (兩端採相同色線排列)
腳位: 接頭朝前, 耳朵朝下 (橘藍綠棕, 白線在前, 排好後, 藍白與綠白對調)
顏色: 橘白-橘-綠白-藍-藍白-綠-棕白-棕

Cross Over (EIA/TIA 568B) 線 (一端採標準 EIA/TIA 568B 色線排列, 另一端則將綠線與橘線對調)
腳位: 接頭朝前, 耳朵朝下
顏色: 綠白-綠-橘白-藍-藍白-橘-棕白-棕 (即將上面正常線的橘線與綠線對調)

最後, 假如要利用 Raspberry Pi 3 打造成為 Wifi 的 Access Point, 可以參考 &lt;a href="http://blog.itist.tw/2016/03/using-raspberry-pi-3-as-wifi-ap-with-raspbian-jessie.html"&gt;http://blog.itist.tw/2016/03/using-raspberry-pi-3-as-wifi-ap-with-raspbian-jessie.html&lt;/a&gt; 與 &lt;a href="http://raspberry-at-home.com/hotspot-wifi-access-point/"&gt;http://raspberry-at-home.com/hotspot-wifi-access-point/&lt;/a&gt; 與 &lt;a href="https://frillip.com/using-your-raspberry-pi-3-as-a-wifi-access-point-with-hostapd/"&gt;https://frillip.com/using-your-raspberry-pi-3-as-a-wifi-access-point-with-hostapd/&lt;/a&gt;</t>
<t tx="amd.20160331205814.1"></t>
<t tx="amd.20160331205819.1"></t>
<t tx="amd.20160401141633.1">@language md
Title: CADLab 學員網誌系統
Category: 規劃
Tags: CADLAB, Pelican, Leo Editor
Author: kmol
@others
我們希望每一位 CADLab 電腦輔助設計室的學員都能夠充份利用現階段各種全球資訊網上的工具, 有效管理自己與團隊間的協同產品開發或學習過程的各種資訊.

&lt;!-- PELICAN_END_SUMMARY --&gt;

這裡所謂的資訊包括:

1. 口語資訊
2. Text 文字資訊
3. 2D 圖面資訊
4. 3D 動態資訊
5. 系統模擬資訊
6. 實體模型資訊

其中需要使用的工具包括 Python3, Leo Editor 以及 Pelican, 使用者若在 Windows 環境, 可以直接使用可攜套件: &lt;a href="https://github.com/chiamingyen/kmol2016"&gt;https://github.com/chiamingyen/kmol2016&lt;/a&gt;.

而每位學員均可利用 &lt;a href="http://www.cmsimply.com"&gt;http://www.cmsimply.com&lt;/a&gt; 來收集上述各種資訊內容, 然後再配合時機點與需求, 將資料分別同步到動態 Wordpress 網誌與 Pelican 靜態網誌.

目前所使用的 Leo Editor 網誌系統專案位於: &lt;a href="https://github.com/cad-lab/manual"&gt;https://github.com/cad-lab/manual&lt;/a&gt;, 學員可以在其中加入下列3個 Leo Editor 的指令按鈕, 讓內容與 Wordpress 動態網誌同步.

&lt;pre class="brush: python"&gt;
#new-to-wordpress
#coding: utf-8
import xmlrpc.client
import datetime
import os

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python
    # 用跳行符號分割
    data_list = data.split("\n")
    #第2行為 title
    title= data_list[1]
    #第3行為 category
    category = data_list[2]
    #第4行為 tags
    tags = data_list[3]
    # 有多項資料的 content 型別為數列
    # 再將第7行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[6:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 &lt;!-more-&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    content = content.replace('~~~python', '[code lang="python"]')
    content = content.replace('~~~', '[/code]')
    return title, category, tags, content
    
os.environ['TZ'] = 'Asia/Taipei'

#################################
filepath = "/home/amd/Desktop/your_wordpress_account_and_password.txt"
wordpress = "your-wordpress-site-url"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

# 從網誌節點的 parent().h 取得 wp_url
# 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑
wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################
wp_blogid = "0"
 
status_draft = 0
status_published = 1
 
server = xmlrpc.client.ServerProxy(wp_url)

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 指定時間出版
'''
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime("2013-01-01 00:00",
"%Y-%m-%d %H:%M"))
'''
# 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \
datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),"%Y-%m-%d %H:%M"))
categories = [category_str.split(":")[1]]
# 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料
# 先用 : 斷開標投頭的 Tags:, 然後再透過逗點隔開, 將標註轉為數列資料
tags = tags_str.split(":")[1].split(",")
data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags}
 
post_id = server.metaWeblog.newPost(wp_blogid, wp_username, wp_password, data, status_published)
# 利用最後的 child 節點來儲存 post_id
to_save_post_id = p.insertAsLastChild()   
# 改為內文為空的節點, id 直接標在 head 標題 
to_save_post_id.b = ""
to_save_post_id.h = post_id
# 因為新增節點, commander 必須 redraw
c.redraw() 

g.es("post_id 為", post_id)
g.es("已經送出資料!")

'''
其他 metaWeblog 的用法:
metaWeblog.newPost (blogid, username, password, struct, publish) returns string(postid)
metaWeblog.editPost (postid, username, password, struct, publish) returns true
metaWeblog.getPost (postid, username, password) returns struct(blog content)
'''
&lt;/pre&gt;

&lt;pre class="brush: python"&gt;
#edit-to-wordpress
#coding: utf-8
import xmlrpc.client
import datetime
import os

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python
    # 用跳行符號分割
    data_list = data.split("\n")
    #第2行為 title
    title= data_list[1]
    #第3行為 category
    category = data_list[2]
    #第4行為 tags
    tags = data_list[3]
    # 有多項資料的 content 型別為數列
    # 再將第7行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[6:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 &lt;!-more-&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    content = content.replace('~~~python', '[code lang="python"]')
    content = content.replace('~~~', '[/code]')
    return title, category, tags, content
    
os.environ['TZ'] = 'Asia/Taipei'
 
#################################
filepath = "/home/amd/Desktop/your_wordpress_account_and_password.txt"
wordpress = "your-wordpress-site-url"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################
wp_blogid = "0"
 
status_draft = 0
status_published = 1
 
server = xmlrpc.client.ServerProxy(wp_url)

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 指定時間出版
'''
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime("2013-01-01 00:00",
"%Y-%m-%d %H:%M"))
'''
# 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \
datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),"%Y-%m-%d %H:%M"))
categories = [category_str.split(":")[1]]
# 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料
tags = tags_str.split(":")[1].split(",")
data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags}

# 設法取得原 post 的 id
origin_post = p.getLastChild()
# 直接從標題取得 post 的 id 號碼
post_id = origin_post.h
status = server.metaWeblog.editPost(post_id, wp_username, wp_password, data, status_published)

if status:
    g.es("資料已經更新!")
else:
    g.es("有問題, 資料沒有更新!")
'''
其他 metaWeblog 的用法:
metaWeblog.newPost (blogid, username, password, struct, publish) returns string(postid)
metaWeblog.editPost (postid, username, password, struct, publish) returns true
metaWeblog.getPost (postid, username, password) returns struct(blog content)
'''
&lt;/pre&gt;

&lt;pre class="brush: python"&gt;
#get-from-wordpress
#coding: utf-8
import xmlrpc.client
# 導入 html 模組, 使用 html.unescape 轉換 html 特殊符號
import html
 
#################################
filepath = "/home/amd/Desktop/your_wordpress_account_and_password.txt"
wordpress = "your-wordpress-site-url"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

# 從網誌節點的 parent().h 取得 wp_url
# 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑
wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################

server = xmlrpc.client.ServerProxy(wp_url)

# 設法透過上述網誌網址, 帳號與密碼, 以及文章 id, 取回 categories, tags, 文章標題, 文章內容等資

# 從最後的 child 節點來取 post_id
origin_post = p.getLastChild()
post_id = origin_post.h
# 取回與 post_id 對應的網誌文章內容
blog_content = server.metaWeblog.getPost(post_id, wp_username, wp_password)
title = blog_content["title"]
# 這裡要利用 html.unescape 轉回特殊符號
description = html.unescape(blog_content["description"])
mt_text_more = html.unescape(blog_content["mt_text_more"])
if mt_text_more != "":
    post_content = description + "\n&lt;!--more--&gt;\n"+mt_text_more
else:
    post_content = description
# 所取回的 categories 為 list
categories = blog_content["categories"]
# 所取回的 tags 為以逗點隔開的字串
mt_keywords = blog_content["mt_keywords"]
# 取回文章作者
author = blog_content["wp_author_display_name"]
p.h = title
categories_str = ""
for category in categories:
    # 假如不是最後一個
    if category != categories[len(categories)-1]:
        categories_str += category + ", "
    else:
        # 這是最後一個
        categories_str += category
line1 = "@language md\n"
line2 = "Title: " +title + "\n"
line3 = "Category: " + categories_str + "\n"
line4 = "Tags: " + mt_keywords + "\n"
line5 = "Author: " + author + "\n@others\n"
post_content = post_content.replace('&lt;!--more--&gt;', '\n&lt;!-- PELICAN_END_SUMMARY --&gt;\n')
post_content = post_content.replace('[code lang="python"]', '~~~python')
post_content = post_content.replace('[/code]', '~~~')
p.b = line1 + line2 + line3 + line4 + line5 + post_content + "\n"
# 因為節點資料更新, commander 必須 redraw
c.redraw() 
g.es("資料已經取回")
&lt;/pre&gt;

</t>
<t tx="amd.20160401230037.1">@language md
Title: CADLab 機械設計系網路配置圖
Category: 規劃
Tags: CADLAB, Network Diagram
Author: kmol
@others
我們正在使用 Python3 與 &lt;a href="http://blockdiag.com/en/"&gt;http://blockdiag.com/en/&lt;/a&gt; 中的 nwdiag 工具繪製機械設計工程系的網路配置圖.

&lt;!-- PELICAN_END_SUMMARY --&gt;

從 &lt;a href="http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-de-biao-da-ji-shu-ling-yu-yu-kao-liang-ceng-mian.html"&gt;機械設計專題的表達、技術領域與考量層面&lt;/a&gt; 範例, 可以了解利用文字描述轉成 2D 流程圖, 具有容易修改維護的優點, 這裡運用相同的概念, 嘗試利用類似的 nwdiag 工具, 畫出整個系的網路配置圖.

blockdiag 與 nwdiag 若能夠搭配全球資訊網路上的 Python3 wsgi 程式, 採用資料庫系統來管理機械設計工程系的網路資源配置, 將可以實際納為&lt;a href="http://chiamingyen.github.io/kmolab/blog/tag/wang-ji-nei-rong-guan-li.html"&gt;網際內容管理&lt;/a&gt;課程的教材.

&lt;img src="http://cad-lab.github.io/cadlab_data/files/mde_network_diag.png" width="800" /&gt;

上述 CADLab 網路配置圖對應的 nwdiag 描述文件:

&lt;pre class="brush: bash;"&gt;
nwdiag {
    default_fontsize = 15;
    校主幹 [shape = cloud];
    校主幹 -- 系路由器;
    
    network 系主幹{
        address = "140.130.17.0/24";
        系路由器 [address="140.130.17.254"];
        雲端點名網路;
        八樓集線器 [address="140.130.17.82"];
        七樓集線器;
        六樓集線器;
        系伺服器群;
    }
    
    network 八樓主幹{
        address="17.10-82"
        八樓集線器 [address="140.130.17.82"];
        老師1伺服器群 [address="140.130.17.10-15"];
        老師2伺服器群 [address="140.130.17.16-25"];
        老師3伺服器群 [address="140.130.17.26-60"];
    }
    
    network CAD_CAE{
        address="17.83";
        八樓集線器 [address="140.130.17.82"];
        CAD_NAT [address="140.130.17.82"];
        CAE_NAT [address="140.130.17.83"];
    }
    
    network 電腦輔助設計室{
        address="192.168.1.0/24";
        CAD_NAT [address="192.168.1.1"];
        CAD1 [address=".2"];
        CAD2;
        CAD64 [address=".100"];
    }
    
    network 電腦輔助繪圖室{
        address="192.168.1.0/24";
        CAE_NAT [address="192.168.1.1"];
        CAE1 [address=".2"];
        CAE2;
        CAE64 [address=".100"];
    }
    
    network 七樓主幹{
        address="140.130.17.83-90"
        七樓集線器;
        老師4伺服器群 [address="140.130.17.61-63"];
        老師5伺服器群 [address="140.130.17.64-70"];
        老師6伺服器群 [address="140.130.17.71-75"];
    }
    
    network 六樓主幹{
        address="140.130.17.91-100"
        六樓集線器;
        老師7伺服器群 [address="140.130.17.76-78"];
        老師8伺服器群 [address="140.130.17.79-80"];
        老師9伺服器群 [address="140.130.17.81-95"];
    }
}
&lt;/pre&gt;

</t>
<t tx="amd.20160402103950.1">@language md
Title: 機械設計工程專業學員程式語言學習
Category: 規劃
Tags: CADLAB, Programming
Author: kmol
@others
程式語言對於機械設計工程師愈來愈重要, 因為全球化協同產品開發的模式方興未艾, 要整合的不同領域與時區的相關技術團隊愈來愈多, 而機械設計通常至少負責團隊中 2D 工程尺寸, 3D 零組件圖, 動態模擬與電腦輔助工程分析的任務, 假如沒有一個隨選客製化並且納入產品生命週期管理架構的雲端系統, 機械設計工程單位將會是各專長領域人士爭相追索資料的單位.

&lt;!-- PELICAN_END_SUMMARY --&gt;

https://github.com/ipython/ipython/wiki/IPython-kernels-for-other-languages</t>
<t tx="amd.20160410195347.1"></t>
<t tx="amd.20160410195347.2">@language python
import os
# 節點的 body 內容設為 content
content = p.b
with open('test.diag', 'w') as f:
    f.write(content)
f.closed
# 存為 svg
#os.system("blockdiag -Tsvg test.diag" )
# 存為 png, 使用 fireflysung.ttf
#os.system("blockdiag -f fireflysung.ttf test.diag" )
os.system("blockdiag test.diag" )
g.es("已經存 test.png 檔案")</t>
<t tx="amd.20160410195347.3">
blockdiag {
    default_shape = roundedbox;
    // 內定寬度為 128
    node_width = 140;
    // 內定高度為 40
    node_height = 50;
    default_fontsize = 15;
    default_node_color = "lightyellow";
    edge_layout = flowchart;
    // 表達方式
    表達 [label = "六種表達方式"];
    1 [label = "口語表達(聲音)"];
    2 [label = "文字表達", color="#99ff33"];
    3 [label = "2D表達(靜態影像)"];
    4 [label = "3D表達(動態影像)"];
    5 [label = "理論表達(定量分析)"];
    6 [label = "實體表達", color="#99ff33"];
    表達 -&gt; 1;
    表達 -&gt; 2;
    表達 -&gt; 3;
    表達 -&gt; 4;
    表達 -&gt; 5;
    表達 -&gt; 6;
    // 學門
    學門 [label = "四種技術領域"];
    學門1 [label = "熱流力學"];
    學門2 [label = "固體力學"];
    學門3 [label = "電機電子"];
    學門4 [label = "資訊通信", color="#99ff33"];
    學門 -&gt; 學門1;
    學門 -&gt; 學門2;
    學門 -&gt; 學門3;
    學門 -&gt; 學門4;
    // 流程
    流程 [label = "四個層面"];
    流程1 [label = "設計", color="#99ff33"];
    流程2 [label = "製造"];
    流程3 [label = "控制"];
    流程4 [label = "管理", color="#99ff33"];
    流程 -&gt; 流程1;
    流程 -&gt; 流程2;
    流程 -&gt; 流程3;
    流程 -&gt; 流程4;
    //專題
    //專題 [label = "機械設計專題", stacked];
    專題 [label = "隨身卡片電腦選購", stacked, color="#ff5050"];
    專題 -&gt; 表達;
    專題 -&gt; 流程;
    專題 -&gt; 學門;
}
</t>
<t tx="amd.20160410195347.4">@language python
import os
# 節點的 body 內容設為 content
content = p.b
with open('test.diag', 'w') as f:
    f.write(content)
f.closed
# 存為 svg
#os.system("nwdiag -Tsvg test.diag" )
# 存為 png, 使用 fireflysung.ttf
#os.system("nwdiag -f fireflysung.ttf test.diag" )
os.system("nwdiag test.diag" )
g.es("已經存 test.png 檔案")</t>
<t tx="amd.20160410195347.5">/*
nwdiag {
  network dmz {
      address = "210.x.x.x/24"

      web01 [address = "210.x.x.1"];
      web02 [address = "210.x.x.2"];
  }
  network internal {
      address = "172.x.x.x/24";

      web01 [address = "172.x.x.1"];
      web02 [address = "172.x.x.2"];
      db01;
      db02;
  }
}
*/

nwdiag {
    default_fontsize = 15;
    校主幹 [shape = cloud];
    校主幹 -- 系路由器;
    
    network 系主幹{
        address = "140.130.17.0/24";
        系路由器 [address="140.130.17.254"];
        雲端點名網路;
        八樓集線器 [address="140.130.17.82"];
        七樓集線器;
        六樓集線器;
        系伺服器群;
    }
    
    network 八樓主幹{
        address="17.10-82"
        八樓集線器 [address="140.130.17.82"];
        老師1伺服器群 [address="140.130.17.10-15"];
        老師2伺服器群 [address="140.130.17.16-25"];
        老師3伺服器群 [address="140.130.17.26-60"];
    }
    
    network CAD_CAE{
        address="17.83";
        八樓集線器 [address="140.130.17.82"];
        CAD_NAT [address="140.130.17.82"];
        CAE_NAT [address="140.130.17.83"];
    }
    
    network 電腦輔助設計室{
        address="192.168.1.0/24";
        CAD_NAT [address="192.168.1.1"];
        CAD1 [address=".2"];
        CAD2;
        CAD64 [address=".100"];
    }
    
    network 電腦輔助繪圖室{
        address="192.168.1.0/24";
        CAE_NAT [address="192.168.1.1"];
        CAE1 [address=".2"];
        CAE2;
        CAE64 [address=".100"];
    }
    
    network 七樓主幹{
        address="140.130.17.83-90"
        七樓集線器;
        老師4伺服器群 [address="140.130.17.61-63"];
        老師5伺服器群 [address="140.130.17.64-70"];
        老師6伺服器群 [address="140.130.17.71-75"];
    }
    
    network 六樓主幹{
        address="140.130.17.91-100"
        六樓集線器;
        老師7伺服器群 [address="140.130.17.76-78"];
        老師8伺服器群 [address="140.130.17.79-80"];
        老師9伺服器群 [address="140.130.17.81-95"];
    }
}</t>
<t tx="amd.20160412201150.1"></t>
<t tx="amd.20160412201156.1">@language md
Title: Onshape 提供免費教育單位帳號
Category:導引
Tags: Onshape, MCAD
Author: kmol
@others
從 &lt;a href="https://www.onshape.com/cad-blog/introducing-the-onshape-education-plan"&gt;https://www.onshape.com/cad-blog/introducing-the-onshape-education-plan&lt;/a&gt; 得知, Onshpae 除了提供各種身份的用戶有使用限度的免費帳號以外, 從 2016.04.07 開始更加碼, 讓教育單位可以免費, 且沒有使用限度的情況下, 來探索使用這個劃時代的雲端電腦輔助機械設計套件.

&lt;!-- PELICAN_END_SUMMARY --&gt;

##穩定的網路連線是使用 Onshpae 的必要條件

假如電腦教室網路連線穩定, 六十名學生可以同時利用 Firefox 或 Chrome,  登入到 &lt;a href="https://www.onshape.com"&gt;Onshape&lt;/a&gt; 執行協同產品設計, 登記免費的教育單位專用帳號後, 只要完成電子郵箱驗證, 就會自動登入系統.

##Onshape 的 Document 是專案容器

登入後, 可以利用左側的 Tutorials &amp; Samples 來了解 Onshpae 的用法:

Onshape 中的 Documents 為設計專案層次 (Project level) 的文件庫 (Container), 可以納入 3D 零件, 3D 組件, 工程圖, 以及從外部轉入的各式檔案.

##Onshape 操作無需存檔, 而且保有流程版本

在 Onshpae 環境中操作零件繪圖, 使用者無需手動存檔, 只要完成任何操作, 都會自動儲存版本, 而且可以在各版本之間遊走.

登入 Onshape, 就可以利用左上角的 Create 按鈕建立 Document 專案文件, 然後再利用左下角的 + 號, 選擇要建立零件, 組件, 工程圖或者是從本地端上傳各式文件.

假如是建立零件, 與其他 MCAD 套件類似, 可以選擇 Sketch 再選擇作圖平面, 或者先選擇作圖平面, 再選擇 Sketch 繪製平面輪廓, 輪廓繪圖, 可以直接在 3D 環境畫圖, 或者利用滑鼠右鍵帶出 View normal to sketch plane 的功能, 以垂直繪圖面的平面上進行繪圖.

##Onshape 可以轉出各式檔案

各種基本的平面繪圖與尺寸標定或約束條件設定, 都與其他傳統的單機 MCAD 大同小異, 雖然 Onshape 與 Solid Edge 採用相同的 PARASOLID kernel, 但是所有的零組件檔案, 可以直接以點選下方的零組件 Tab, 再以滑鼠右鍵帶出 Export 功能, 然後轉成 PARASOLID 或 ACIS 核心檔,甚至也能直接轉成 Solidworks 格式檔案, 當然也能轉成 IGES, STEP, RHINO, STL 等格式.

##Onshape 擁有直覺的組立約束

當使用者在 Onshape 零件繪製模式下完成基本零件, 就可以利用左下方的 + 建立組立檔, 將各零件一一放入進行組裝.

&lt;a href="https://cad.onshape.com/help/Content/mate-fastened.htm"&gt;Fastened mate&lt;/a&gt; 主要用於焊接式的組合, 約束條件置入後, 兩個零件間已經沒有任何自由度而結為一體.

&lt;a href="https://cad.onshape.com/help/Content/mate-revolute.htm"&gt;Revolute mate&lt;/a&gt; 主要用於旋轉軸式的組合, 約束條件置入後, 兩個零件間只留下一個旋轉自由度.

&lt;a href="https://cad.onshape.com/help/Content/mate-slider.htm"&gt;Slider mate&lt;/a&gt; 主要用於滑塊式的組合, 約束條件置入後, 兩個零件間只留下一個平移自由度.

&lt;a href="https://cad.onshape.com/help/Content/mate-planar.htm"&gt;Planar mate&lt;/a&gt; 主要用於面接式組合, 約束條件置入後, 兩個零件面對面靠接, 只允許兩個方向的移動自由度, 以及垂直靠接面方向的一個旋轉自由度.

&lt;a href="https://cad.onshape.com/help/Content/mate-cylindrical.htm&gt;Cylindrical mate&lt;/a&gt; 主要用於圓柱螺栓式的組合, 約束條件置入後, 兩個零件將具有旋轉與前進或後退的兩個自由度.

&lt;a href="https://cad.onshape.com/help/Content/mate-pin_slot.htm"&gt;Pin slot mate&lt;/a&gt; 主要用於插銷式組合, 約束條件置入後, 兩個零件具有旋轉與側向平移等兩個自由度.

&lt;a href="https://cad.onshape.com/help/Content/mate-ball.htm"&gt;Ball mate&lt;/a&gt; 主要用於球接頭式的組合, 約束條件置入後, 將保留3個方向的旋轉自由度.

&lt;a href="https://cad.onshape.com/help/Content/mate-ball.htm"&gt;Tangent mate&lt;/a&gt; 則是比較特殊的相切組立, 約束條件置入後, 兩個零件將始終保持相切的關係.

##簡單的組立應用

根據上述基本功能, 就可以完成下列腳踏車鏈條的基本組立:

&lt;img src="http://cad-lab.github.io/cadlab_data/files/onshape_bike_chain_assembly.png" width="800" /&gt;

教育版對應帳號下所完成的 &lt;a href="https://cad.onshape.com/documents/29d1a262b055745e59be7c09/w/1f25948ad73282e2440ffdcf"&gt;Bike chain Document&lt;/a&gt;.





</t>
<t tx="amd.20160506230749.1"></t>
<t tx="amd.20160506230801.1">@language md
Title: Wordpress 網誌文章中的網際程式碼
Category:導引
Tags: Wordpress, MCAD
Author: kmol
@others
從 &lt;a href="https://www.w3.org/Graphics/SVG/History"&gt;SVG 歷史&lt;/a&gt; 與 &lt;a href="https://en.wikipedia.org/wiki/WebGL#History"&gt;WebGL 歷史&lt;/a&gt;, 以及 &lt;a href="https://github.com/socketio/socket.io/blob/master/History.md"&gt; socket.io 歷史&lt;/a&gt;, 也許不難發現, 多人協同在瀏覽器為基礎的應用程式環境, 已然成型.

&lt;!-- PELICAN_END_SUMMARY --&gt;

儘管如此, 要將所有的工作全時在網路連線的環境中完成, 可能仍言之過早, 比較讓人確定的是, 多點觸控的平台伴隨著本地端的桌機或者是筆電, 還會繼續是主流的電腦輔助設計環境.

在這樣的所謂 Web Based (網際) 環境中, 身為一位機械設計工程師, 除了要關注傳統的 2D/3D 靜態與動態內容表達外, 能否逐步導入多點觸控裝置的資料, 便成為重點.

以網際 2D 繪圖而言, 2013 年推出的 &lt;a href="http://snapsvg.io/"&gt;http://snapsvg.io/&lt;/a&gt;, 就是一套能夠順應未來電腦輔助機械設計繪圖的工具之一.

從 &lt;a href="http://chiamingyen.github.io/kmolab/blog/dao-ru-brython-yu-snapsvg-wang-ji-hui-tu.html"&gt;導入 Brython 與 Snap.svg 網際繪圖&lt;/a&gt; 的說明中, 我們已經知道能夠透過網際的 Brython 來呼叫並運用 snap.svg 程式庫, 但是假如希望完成如 &lt;a href="http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html"&gt;Pelican 靜態網頁與 Wordpress 的整合方案&lt;/a&gt; 中所談到的資料整合, 並且導入 snap.svg 到 Wordpress 與 Pelican 網誌系統, 需要注意到 Wordpress 對於內文中處理程式碼的用法, 否則由 Pelican 靜態網誌轉進 Wordpress 系統中的所有 Brython 或 Javascript 程式內容, 將會全數被 Wordpress 當作一般文字資料處理.

應對的方法很簡單, 只需要明確利用 html 的註解標註, 跳過 Wordpress 對於 Brython 與 Javascript 程式碼的額外處理就行.

以下舉 Snap.svg 典型的動態模擬為例:

&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"&gt;&lt;/script&gt;
 
&lt;script&gt;
//&lt;!--
window.onload=function(){
brython(1);
}
//--&gt;
&lt;/script&gt;
 
&lt;svg width="800" height="600" viewBox="0 0 800 600" id="svgout"&gt;&lt;/svg&gt;
 
&lt;script type="text/python"&gt;
#&lt;!--
from javascript import JSConstructor
from browser import alert
from browser import window, document
 
# 透過 window 與 JSConstructor 從 Brython 物件 snap 擷取 Snap 物件的內容
snap = JSConstructor(window.Snap)
 
# 使用 id 為 "svgout" 的 svg 標註進行繪圖
s = snap("#svgout")
 
offsetY = 50
 
# 是否標示出繪圖範圍
#borderRect = s.rect(0,0,800,640,10,10).attr({ 'stroke': "silver", 'fill': "silver", 'strokeWidth': "3" })
 
g = s.group().transform('t250,120')
r0 = s.rect(150,150,100,100,20,20).attr({ 'fill': "orange", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c0 = s.circle(225,225,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4"  }).attr({ 'id': 'c0' })
g0 = s.group( r0,c0 ).attr({ 'id': 'g0' })
#g0.animate({ 'transform' : 't250,120r360,225,225' },4000)
g0.appendTo( g )
g0.animate({ 'transform' : 'r360,225,225' },4000)
# 讓 g0 可以拖動
g0.drag()
 
r1 = s.rect(100,100,100,100,20,20).attr({ 'fill': "red", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c1 = s.circle(175,175,10).attr({ 'fill': "silver", 'stroke': "black" , 'strokeWidth': "4"}).attr({ 'id': 'c1' })
g1 = s.group( r1,c1 ).attr({ 'id': 'g1' })
g1.appendTo( g0 ).attr({ 'id': 'g1' })
g1.animate({ 'transform' : 'r360,175,175' },4000)
 
r2 = s.rect(50,50,100,100,20,20).attr({ 'fill': "blue", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c2 = s.circle(125,125,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c2' })
g2 = s.group(r2,c2).attr({ 'id': 'g2' })
 
g2.appendTo( g1 );
g2.animate( { 'transform' : 'r360,125,125' },4000);
 
r3 = s.rect(0,0,100,100,20,20).attr({ 'fill': "yellow", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c3 = s.circle(75,75,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c3' })
g3 = s.group(r3,c3).attr({ 'id': 'g3' })
 
g3.appendTo( g2 )
g3.animate( { 'transform' : 'r360,75,75' },4000)
 
r4 = s.rect(-50,-50,100,100,20,20).attr({ 'fill': "green", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c4 = s.circle(25,25,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c4' })
g4 = s.group(r4,c4).attr({ 'id': 'g4' });
g4.appendTo( g3 )
g4.animate( { 'transform' : 'r360,25,25' },4000)
#--&gt;
&lt;/script&gt;

 Brython 程式碼:
 
&lt;pre class="brush: python"&gt;
&amp;lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"&amp;gt;&amp;lt;/script&amp;gt;
 
&amp;lt;script&amp;gt;
//&amp;lt;!--
window.onload=function(){
brython(1);
}
//--&amp;gt;
&amp;lt;/script&amp;gt;
 
&amp;lt;svg width="800" height="600" viewBox="0 0 800 600" id="svgout"&amp;gt;&amp;lt;/svg&amp;gt;
 
&amp;lt;script type="text/python"&amp;gt;
#&amp;lt;!--
from javascript import JSConstructor
from browser import alert
from browser import window, document
 
# 透過 window 與 JSConstructor 從 Brython 物件 snap 擷取 Snap 物件的內容
snap = JSConstructor(window.Snap)
 
# 使用 id 為 "svgout" 的 svg 標註進行繪圖
s = snap("#svgout")
 
offsetY = 50
 
# 是否標示出繪圖範圍
#borderRect = s.rect(0,0,800,640,10,10).attr({ 'stroke': "silver", 'fill': "silver", 'strokeWidth': "3" })
 
g = s.group().transform('t250,120')
r0 = s.rect(150,150,100,100,20,20).attr({ 'fill': "orange", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c0 = s.circle(225,225,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4"  }).attr({ 'id': 'c0' })
g0 = s.group( r0,c0 ).attr({ 'id': 'g0' })
#g0.animate({ 'transform' : 't250,120r360,225,225' },4000)
g0.appendTo( g )
g0.animate({ 'transform' : 'r360,225,225' },4000)
# 讓 g0 可以拖動
g0.drag()
 
r1 = s.rect(100,100,100,100,20,20).attr({ 'fill': "red", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c1 = s.circle(175,175,10).attr({ 'fill': "silver", 'stroke': "black" , 'strokeWidth': "4"}).attr({ 'id': 'c1' })
g1 = s.group( r1,c1 ).attr({ 'id': 'g1' })
g1.appendTo( g0 ).attr({ 'id': 'g1' })
g1.animate({ 'transform' : 'r360,175,175' },4000)
 
r2 = s.rect(50,50,100,100,20,20).attr({ 'fill': "blue", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c2 = s.circle(125,125,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c2' })
g2 = s.group(r2,c2).attr({ 'id': 'g2' })
 
g2.appendTo( g1 );
g2.animate( { 'transform' : 'r360,125,125' },4000);
 
r3 = s.rect(0,0,100,100,20,20).attr({ 'fill': "yellow", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c3 = s.circle(75,75,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c3' })
g3 = s.group(r3,c3).attr({ 'id': 'g3' })
 
g3.appendTo( g2 )
g3.animate( { 'transform' : 'r360,75,75' },4000)
 
r4 = s.rect(-50,-50,100,100,20,20).attr({ 'fill': "green", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c4 = s.circle(25,25,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c4' })
g4 = s.group(r4,c4).attr({ 'id': 'g4' });
g4.appendTo( g3 )
g4.animate( { 'transform' : 'r360,25,25' },4000)
#--&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/pre&gt;</t>
<t tx="amd.20160506235635.1"></t>
<t tx="amd.20160514153227.1">@language md
Title: 常用 Python3 程式模組
Category:導引
Tags: Python3, module
Author: kmol
@others
&lt;a href="http://www.cherrypy.org/"&gt;CherryPy&lt;/a&gt;, &lt;a href="http://pytz.sourceforge.net/"&gt;pytz&lt;/a&gt;, &lt;a href="http://www.makotemplates.org/"&gt;mako&lt;/a&gt;, &lt;a href="https://www.crummy.com/software/BeautifulSoup/"&gt;beautifulsoup4&lt;/a&gt;, &lt;a href="https://github.com/PyMySQL/PyMySQL"&gt;pymysql&lt;/a&gt;, &lt;a href="https://github.com/coleifer/peewee"&gt;peewee&lt;/a&gt;, &lt;a href="https://github.com/sigmavirus24/github3.py"&gt;github3.py&lt;/a&gt;, &lt;a href="http://peterhudec.github.io/authomatic/"&gt;authomatic&lt;/a&gt; 等是 CADLab 網際程式開發流程中較常用的 Python3 模組.

&lt;!-- PELICAN_END_SUMMARY --&gt;

其中的 &lt;a href="http://www.cherrypy.org/"&gt;CherryPy&lt;/a&gt; 與 &lt;a href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt; 位階相似, 但是
特性卻有很大差別, CherryPy 小而自給自足, Flask 則架構較具彈性, 許多延伸功能都採 extension 方式補足, 有關 CherryPy 的各種用法, 請參考 &lt;a href="http://cad-lab.github.io/manual/post/cherrypy-shi-yong-shou-ce.html"&gt;http://cad-lab.github.io/manual/post/cherrypy-shi-yong-shou-ce.html&lt;/a&gt;.

&lt;a href="https://github.com/zzzeek/mako"&gt;https://github.com/zzzeek/mako&lt;/a&gt; 的最大特色, 是將 Python 的語法直接放到 template 文件中, 儘管如此可能會讓使用者將原本應該放在控制端的資料流程, 分散到展示端, 但是實際採用後, 也沒有發生太大問題, 反而可以利用相同的網際程式, 直接套用到 Mako 與 Flask 內建的 template 語法中, 進行比較.

github3.py 針對 Github 倉儲新增協同者的程式片斷範例:

&lt;pre class="brush: python"&gt;
@app.route('/yourrepoadd', methods=['POST'])
def yourrepoadd():
    account = request.form["account"]
    repository = "yourrepo"
    url = "https://github.com/youraccount/yourrepo.git"
    # 登入系統
    g = github3.login("youraccount", "yourpassword")
    # 以下則新增協同者
    #g.repository(倉儲帳號, 倉儲名稱).add_collaborator(協同者 github 帳號)
    # 若新增 collaborator 成功傳回 True 否則傳回 False
    if g.repository("youraccount", repository).add_collaborator(account):
        # 共同使用 cpaadd.html
        return render_template("cpaadd.html", account=account, repository=repository, url=url)
    else:
        return render_template("cpaerror.html")
&lt;/pre&gt;

至於 authomatic 的使用, 共有3個步驟:

## 1. 取得 key 與 secret

設定網址:

https://console.developers.google.com

總共有兩項設定:

1. 啟用 Google + API
2. 然後到憑證處建立專案, 設定授權的 URI

設定目的在希望透過 Google+ API 讓 Web browser (Javascript) 能夠擷取 User data, 這時需要的是 Create an OAuth 2.0 client ID, 建立專案後, 必須選擇 Authorized Javascript origins 為 http://your.server.domain.name 與 http://localhost:5000, 而 Authorized redirect URIs 為: http://your.server.domain.name/autho_login/google/ 與 http://localhost:5000/autho_login/google/

## 2. 導入模組, 進行設定

&lt;pre class="brush: python"&gt;
import authomatic
from authomatic.providers import oauth2

CONFIG = {
        'google': {
            'class_': oauth2.Google,
            'consumer_key': '1234567.apps.googleusercontent.com',
            'consumer_secret': '87654321',
            #'scope': oauth2.Google.user_info_scope
            # 以下只允許(瞭解您在 Google 上的身分)與(檢視電子郵件地址)
            'scope': ['email']
        }
    }
&lt;/pre&gt;

## 3. 配合建立登入連結

&lt;pre class="brush: python"&gt;
@app.route('/autho_login/&amp;lt;provider_name&amp;gt;/', methods=['GET', 'POST'])
def autho_login(provider_name):
    
    # We need response object for the WerkzeugAdapter.
    response = make_response()
    
    # Log the user in, pass it the adapter and the provider name.
    result = authomatic.login(WerkzeugAdapter(request, response), provider_name)
    
    # If there is no LoginResult object, the login procedure is still pending.
    if result:
        if result.user:
            # We need to update the user to get more info.
            result.user.update()
            
        # 利用 session 登記登入者的 email
        session['login_email'] = result.user.email
        
        # 這裡必須分近端與雲端, 因為 google logout redirect 的 url 不同
        if 'OPENSHIFT_REPO_DIR' in os.environ.keys():
            # 表示程式在雲端執行
            local = False
        else:
            # 表示在近端執行
            local = True
        # The rest happens inside the template.
        return render_template('autho_login.html', result=result, local=local)
    
    # Don't forget to return the response.
    return response
&lt;/pre&gt;

## oauth2 登入的情境

使用 oauth2 的目的, 在利用既有的使用者帳號進行應用程式的登入, 例如, 使用 facebook 或 gmail 帳號登入到我們所開發的網際應用程式, 好處是, 使用者無需在各類網際程式中額外再申請帳號, 而程式開發者也可以免去管理使用者帳號的難題.

但是, 為了在使用者被 oauth2 協定轉介到 gmail 登入頁面, 完成登入後, 就會再帶著帳號擁有者所允許的相關訊息, 回到網際應用程式中, 通常這些網際程式會利用 session 與 cookie 來儲存使用者登入的身份資料, 如此一來, 便有以下情境:

假如使用者在選擇登入到網際程式之前, 已經登入到 gmail, 那麼使用者無需再輸入帳號密碼, 只要同意允許擷取帳號資料 ,就會直接跳轉到網際程式功能中, 特別注意到, 這時 gmail 有使用者登入的 session 與 cookie, 而且使用者的瀏覽器還存在登入到網際應用程式的狀態.

第2種情況則是, 使用者被轉介到 gmail 登入畫面時, 才輸入帳號密碼登入, 之後情境就與上述第1種情況相同.

上述兩種情況, 在瀏覽器中, 使用者的狀態是同時登入到 gmail 與網際程式中, 即便使用者登入網際程式後, 若使用者沒有主動登出 gmail, 這位使用者在瀏覽器的狀態中, 仍然保持登入到 gmail 的狀態.

因此第3種情況則是, 使用者經由 oauth2 協定轉介到 gmail 登入後同意讓網際程式擷取帳號資料後, 就能登入到網際程式中, 隨後使用者主動登出 gmail, 並不會影響仍然登入到網際程式中的狀態, 一直到使用者選擇登出網際應用程式為止.

理論上, 假如我們所開發的網際程式, 只是透過一系列上述的設定, 藉由 gmail 的帳號, 來登入我們所開發的網際程式, 比較好的作法是一旦完成我們網際應用程式的登入後, 可以經由程式方法登出使用者的 gmail 帳號, 然後再由使用者決定何時要登出我們所開發的網際程式.

以下就是利用 Javascript 在登入應用程式之後, 設法登出使用者 gmail 帳號的設計, 並且同時支援本地端程式開發與雲端應用的情況:

&lt;pre class="brush: python"&gt;
{# autho_login.html #}
{% extends "autho_base.html" %}

{% block body %}

&amp;lt;!-- 這裡應該要再分近端與雲端的不同處理流程, 而且要在設定時便取得綁定的雲端網址 --&amp;gt;
{% if local %}
&amp;lt;script type="text/javascript"&amp;gt;
window.location="https://www.google.com/accounts/Logout?continue=https://appengine.google.com/_ah/logout?continue=http://localhost:5000/check_login";
&amp;lt;/script&amp;gt;
{% else %}
&amp;lt;script type="text/javascript"&amp;gt;
window.location="https://www.google.com/accounts/Logout?continue=https://appengine.google.com/_ah/logout?continue=http://your.server.domain.name/check_login";
&amp;lt;/script&amp;gt;
{% endif %}

{% endblock body %}
&lt;/pre&gt;

</t>
<t tx="amd.20160515165148.1">@language md
Title: 電腦輔助機械設計流程中的分散式版本管理
Category:導引
Tags: MCAD, DVCS
Author: kmol
@others
&lt;a href="http://bazaar.canonical.com/en/"&gt;Bazaar&lt;/a&gt; (2004 年從 &lt;a href="https://www.gnu.org/software/gnu-arch/"&gt;Gnu arch&lt;/a&gt; 分出), &lt;a href="http://www.bitkeeper.com/"&gt;BitKeeper&lt;/a&gt;, &lt;a href="http://darcs.net/"&gt;darcs&lt;/a&gt;, &lt;a href="https://github.com/git"&gt;Git&lt;/a&gt;, &lt;a href="https://www.mercurial-scm.org/"&gt;Mercurial&lt;/a&gt; 是目前較為常見的分散式版本管理 (Distributed Version Control Systems, DVCS) 技術, 其中自 1998 年前後推出, 唯一商用閉源的 Bitkeeper, 也終於在 2016.05.09, 宣佈轉為開放原始碼套件: &lt;a href="https://users.bitkeeper.org/t/bk-7-2ce-released-2016-05-09/93"&gt;https://users.bitkeeper.org/t/bk-7-2ce-released-2016-05-09/93&lt;/a&gt;.

&lt;!-- PELICAN_END_SUMMARY --&gt;

其實, 早在 1995 年左右的 &lt;a href="https://en.wikipedia.org/wiki/Sun_WorkShop_TeamWare"&gt;Sun WorkShop TeamWare&lt;/a&gt; 就已經擁有分散式版本的相關技術, 而且在許多與機械設計相關的 PDM/PLM 系統中, 也都提供各種分散式版本控管的功能, 只是大多與封閉的檔案系統格式搭配使用, 使得多人協同模式下的電腦輔助機械設計流程, 成本不斷推升, 而且造成導入新技術的步調緩慢.

當然, 這些國際大公司面對快速發展的數位虛擬與雲端技術, 眼看無法透過賣斷的使用授權來限制使用者, 也紛紛隨著許多創新的先行者 (例如: Onshape), 喊出不再販售大而無當的單機賣斷版本套件, 而改採較具彈性的網路訂閱授權.

接下來, 當快速進展的全球協同模式必得讓各方團隊開始自行打造各式本地端、區域網路端、廣域網路端與雲端上的網際服務系統時, 目前最佳的授權認証模式, 則多採取 &lt;a href="https://tools.ietf.org/html/rfc6749"&gt;oauth2&lt;/a&gt; 的協定進行, 例如: Onshape 已經釋出 node.js 相容的程式模組: &lt;a href="https://github.com/onshape/passport-onshape"&gt;https://github.com/onshape/passport-onshape&lt;/a&gt;.

儘管如此, 身為一般的機械設計產品開發團隊, 仍然無法像全球大量持續甩開 Microsoft 約束的程式開發者一樣, 熱烈擁抱諸如 Linux 與 FreeBSD 相關分支, 因為 &lt;a href="http://www.freecadweb.org/"&gt;http://www.freecadweb.org/&lt;/a&gt; 尚未大到可以取代許多封閉套件的地步, 現階段只能期待 Onshape 的授權方案能夠持續友善, 未來能夠有機會藉著清楚展示設計流程的分散式版本管理, 讓使用者能夠從此自混水中解脫.

儘管 Onshape 的 API 使用授權尚未全面釋出, 但是假如希望先利用 oauth2 自行打造一個網際產品設計開發系統, 可以參考下列的簡單程式開發描述:

1. 讓使用者以 Gmail 帳號, 經由 google 制式流程登入後轉回應用程式

    使用技術: oauth2
    
2. 網際程式可以在本地端、區域網路端與雲端平台上佈署, 得到相同執行結果

   使用技術: 利用物件案例的啟始, 建立所需的環境目錄架構,  以及起始資料庫檔案等, 利用操作系統模組讀取特定變數判定執行環境
   
3. 資料庫存取技術與分頁

4. 人性化的 Javascript 或 Brython 環境導入

5. 美化的 Template 與 css 導入

6. Github, bitbucket 與 &lt;a href="https://gogs.io/"&gt;gogs&lt;/a&gt; 的程式開發版本管理

7. 規劃所要維護的資料表: 

人員名單含角色管理

事件管理

網際運算 (結合 Jupyter)

參考資料:

flask

&lt;a href="http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-now-with-python-3-support"&gt;http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-now-with-python-3-support&lt;/a&gt;

oauth2

&lt;a href="http://oauth.net/2/"&gt;http://oauth.net/2/&lt;/a&gt;

&lt;a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-1-introduction/"&gt;https://blog.yorkxin.org/posts/2013/09/30/oauth2-1-introduction/&lt;/a&gt;

&lt;a href="https://tools.ietf.org/html/rfc6749"&gt;https://tools.ietf.org/html/rfc6749&lt;/a&gt;

git

&lt;a href="https://github.com/git"&gt;https://github.com/git&lt;/a&gt;

working flow

&lt;a href="https://www.drupal.org/node/803746"&gt;https://www.drupal.org/node/803746&lt;/a&gt;

Jupyter and oauth2

&lt;a href="https://github.com/jupyterhub/oauthenticator"&gt;https://github.com/jupyterhub/oauthenticator&lt;/a&gt;

&lt;a href="https://github.com/ryanlovett/jh-google-oauthenticator"&gt;https://github.com/ryanlovett/jh-google-oauthenticator&lt;/a&gt;</t>
<t tx="amd.20160517115058.1">@language md
Title: 網際機械設計 2D 繪圖
Category:導引
Tags: MCAD, Web based
Author: kmol
@others
&lt;a href="http://2015fallhw.github.io/arcidau/Flintlock.html"&gt;http://2015fallhw.github.io/arcidau/Flintlock.html&lt;/a&gt; 是一個典型的網際機械設計 2D 繪圖範例, CADLab 希望能夠利用 Brython 重新建立一個直接以 Python3 在網頁中繪圖的類似應用.

&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;style type="text/css" media="screen"&gt;

#flintlockImg {
  float: right;
  display: inline;  /* IE6 hack to fix double margin bug */
  width: 24em;
  margin: 1em 2em 1em 1em;
}

#flintlockImg img {
  width: 100%;
  padding: 0.5em;
  border: 1px solid #404040;
}

#cvsUpper, #cvsLower {
  position: relative;
  width: 600px;
  height: 300px;
  text-align: center;  /* this will center console if it has display:inline-block */
  background-color: #aabdd3;
}
&lt;/style&gt;

&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/Cango-8v03.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/Cango2D-7v01-min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/CangoAxes-1v33.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/flintlockPartDefs-02.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/CangoAnimation-4v01.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/gearUtils-05.js"&gt;&lt;/script&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;script type="text/javascript"&gt;

    if (typeof addLoadEvent === "undefined")
    {
      var addLoadEvent = function(func)
      {
      	var oldonload = window.onload;
      	if (typeof window.onload != 'function')
        {
          window.onload = func;
        }
      	else
        {
        	window.onload = function(){oldonload();	func();}
        }
      }
    }

    if (typeof addEvent === "undefined")
    {
      var addEvent = function(element, eventType, handler)
      {
        if (element.attachEvent)
        {
          return element.attachEvent('on'+eventType, handler);
        }
        return element.addEventListener(eventType, handler, false);
      };
    }

    function cancelBubble(e)
    {
      var evt = e ? e:window.event;
      if (evt.stopPropagation) evt.stopPropagation();
      if (evt.cancelBubble!=null) evt.cancelBubble = true;
    }
&lt;/script&gt;

&lt;script type="text/javascript"&gt;

function enableBtn(btnId)
{
  var btn = document.getElementById(btnId);
  btn.disabled = false;
}

function disableBtn(btnId)
{
  var btn = document.getElementById(btnId);
  btn.disabled = true;
}

function FlintlockDemo(cvsU, cvsL)
{
  "use strict"
  var innerGCL0, innerGCL1,
      outerGC,
      // Lock components (Cango2D groups)
      cockObj,
      fizzenObj,
      plateObj,
      searSpringObj,
      searObj,
      tumblerObj,
      mainSpringObj,
      screwsObj,
      // draw outside in lower canvas
      plateOutside,
      cockOutside,
      fizzenOutside,
      fizzenSpring,
      outScrews;

  this.fire_JS = function()
    {
    innerGCL0.playAnimation(0, 1000);   // play for 1000 then pause
    outerGC.playAnimation(0, 1000);

    disableBtn('cock');
    disableBtn('fire');
    setTimeout("enableBtn('load')", 1000);
  };

  this.load_JS = function()
  {
    innerGCL0.playAnimation(1000, 3500);    // resume from pause play until 3500
    outerGC.playAnimation(1000, 3500);

    disableBtn('load');
    disableBtn('fire');
    setTimeout("enableBtn('cock')", 2500);

  };

  this.cock_JS = function()
  {
    innerGCL0.playAnimation(3500, 5000);      // resume from pause play until 5000
    outerGC.playAnimation(3500, 5000);

    disableBtn('load');
    disableBtn('cock');
    setTimeout("enableBtn('fire')", 1500);
  };

  // Upper display
  innerGCL0 = new Cango(cvsU);                     // layer for the cock and fizzen
  innerGCL0.setWorldCoords(-250, -100, 500);       // square pixels origin in center of canvas
  innerGCL1 = new Cango(innerGCL0.createLayer());  // layer for main spring and sear
  innerGCL1.dupCtx(innerGCL0);

  // construct all the component objects
  cockObj = makeCock(innerGCL0);
  fizzenObj = makeFizzenInside(innerGCL0);
  plateObj = makePlate(innerGCL0);
  searSpringObj = makeSearSpring(innerGCL1);
  searObj = makeSear(innerGCL1);
  tumblerObj = makeTumbler(innerGCL1);
  mainSpringObj = makeMainSpring(innerGCL1);
  screwsObj = makeScrews(innerGCL1);

        var innerTwnr = new Tweener(0, 5000);
  var innerData = {
      cockRot:     [0, 54, 54, 18, 18,  0],
    cockRotTimes:[0, 10, 20, 60, 70, 90],
    fizzenRot:     [0, 0, 73, 73,  0],
    fizzenRotTimes:[0, 4,  8, 60, 70],
    searSpringRot:     [0, -5, -6, -3.5,  0, -2, -3.5, -3.5,  0,  0, -2, -3, -3.5,  0],
    searSpringRotTimes:[0,  5, 10,   15, 20, 30,   40,   50, 60, 70, 75, 80,   85, 90],
    searRot:     [0, 10, 12,  7,  0,  4,   7,   7,  0,  0,  4, 5.5,  7,  0],
    searRotTimes:[0,  5, 10, 15, 20, 30,  40,  50, 60, 70, 75,  80, 85, 90],
      tumblerRot:     [0, 54, 54, 18, 18,  0],
    tumblerRotTimes:[0, 10, 20, 60, 70, 90],
    mainSpringRot:     [0, -7, -7, -2, -2,  0],
    mainSpringRotTimes:[0, 10, 20, 60, 70, 90]
  };

  function initCock(opts)
  {
    this.nextState.x = cockCxOfs;
    this.nextState.y = -cockCyOfs;
  }

  function initFissen(opts)
  {
    this.nextState.x = fizzenCxOfs;
    this.nextState.y = -fizzenCyOfs;
  }

  function initSearSpring(opts)
  {
    this.nextState.x = searSpringCxOfs;
    this.nextState.y = -searSpringCyOfs;
  }

  function initSear(opts)
  {
    this.nextState.x = searCxOfs;
    this.nextState.y = -searCyOfs;
  }

  function initMainSpring(opts)
  {
    this.nextState.x = mainSpringCxOfs;
    this.nextState.y = -mainSpringCyOfs;
  }

  function cockPathFn(time, opts)
  {
    var cockRotVal = innerTwnr.getVal(time, opts.cockRot, opts.cockRotTimes);

    this.nextState.rot = cockRotVal;
  }

  function fizzenPathFn(time, opts)
  {
    var fizzenRotVal = innerTwnr.getVal(time, opts.fizzenRot, opts.fizzenRotTimes);

    this.nextState.rot = fizzenRotVal;
  }

  function searSpringPathFn(time, opts)
  {
    var searSpringRotVal = innerTwnr.getVal(time, opts.searSpringRot, opts.searSpringRotTimes);

    this.nextState.rot = searSpringRotVal;
  }

  function searPathFn(time, opts)
  {
    var searRotVal = innerTwnr.getVal(time, opts.searRot, opts.searRotTimes);

    this.nextState.rot = searRotVal;
  }

  function tumblerPathFn(time, opts)
  {
    var tumblerRotVal = innerTwnr.getVal(time, opts.tumblerRot, opts.tumblerRotTimes);

    this.nextState.rot = tumblerRotVal;
  }

  function mainSpringPathFn(time, opts)
  {
    var mainSpringRotVal = innerTwnr.getVal(time, opts.mainSpringRot, opts.mainSpringRotTimes);

    this.nextState.rot = mainSpringRotVal;
  }

  innerGCL0.animate(cockObj, initCock, cockPathFn, innerData);
  innerGCL0.animate(fizzenObj, initFissen, fizzenPathFn, innerData);
  innerGCL0.animate(plateObj);
  innerGCL1.animate(searSpringObj, initSearSpring, searSpringPathFn, innerData);
  innerGCL1.animate(searObj, initSear, searPathFn, innerData);
  innerGCL1.animate(tumblerObj, initCock, tumblerPathFn, innerData);
  innerGCL1.animate(mainSpringObj, initMainSpring, mainSpringPathFn, innerData);
  innerGCL1.animate(screwsObj);

  // Lower display
  outerGC = new Cango(cvsL);
  outerGC.setWorldCoords(-250, -100, 500);

  // construct all the component objects
  plateOutside = makePlateOutside(outerGC);
  cockOutside = makeCockOutside(outerGC);
  fizzenOutside = makeFizzenOutside(outerGC);
  fizzenSpring = makeFizzenSpring(outerGC);
  outScrews = makeOutScrews(outerGC);

        var outerTwnr = new Tweener(0, 5000);
  var outerData = {
      outerCockRot:     [0, -54, -54, -18, -18,  0],
    outerCockRotTimes:[0,  10,  20,  60,  70, 90],
    outerFizRot:     [0, 0, -73, -73,  0],
    outerFizRotTimes:[0, 4,   8,  60, 70],
    outerFizSpringRot:     [0, 0, 5, 6, 3.5, 0,  0,    3,  4,    3,  0],
    outerFizSpringRotTimes:[0, 4, 5, 6,   7, 8, 60, 62.5, 65, 67.5, 70]
  };

  function initCockOutside(opts)
  {
    this.nextState.x = -cockCxOfs;
    this.nextState.y = -cockCyOfs;
  }

  function initFissenOutside(opts)
  {
    this.nextState.x = -fizzenCxOfs;
    this.nextState.y = -fizzenCyOfs;
  }

  function initFissenSpring(opts)
  {
    this.nextState.x = -fizzenSpringCxOfs;
    this.nextState.y = -fizzenSpringCyOfs;
  }

  function outerCockPathFn(time, opts)
  {
    var cockRotVal = outerTwnr.getVal(time, opts.outerCockRot, opts.outerCockRotTimes);

    this.nextState.rot = cockRotVal;
  }

  function outerFizzenPathFn(time, opts)
  {
    var fizzenRotVal = outerTwnr.getVal(time, opts.outerFizRot, opts.outerFizRotTimes);

    this.nextState.rot = fizzenRotVal;
  }

  function fizzenSpringPathFn(time, opts)
  {
    var fizzenSpringRotVal = outerTwnr.getVal(time, opts.outerFizSpringRot, opts.outerFizSpringRotTimes);

    this.nextState.rot = fizzenSpringRotVal;
  }

  outerGC.animate(plateOutside);
  outerGC.animate(cockOutside, initCockOutside, outerCockPathFn, outerData);
  outerGC.animate(fizzenOutside, initFissenOutside, outerFizzenPathFn, outerData);
  outerGC.animate(fizzenSpring, initFissenSpring, fizzenSpringPathFn, outerData);
  outerGC.animate(outScrews);

  disableBtn('load');
  disableBtn('cock');
  enableBtn('fire');
}

var consoleBtns =
{
  f1:function(){demo.load_JS()},
  f2:function(){demo.cock_JS()},
  f3:function(){demo.fire_JS()},
  f4:function(){}
};

&lt;/script&gt;

&lt;script type="text/javascript"&gt;
addLoadEvent( function(){
  demo = new FlintlockDemo('cvsUpper', 'cvsLower');
  enableStickyNav();
});
&lt;/script&gt;

&lt;div class="consoleHolder"&gt;
&lt;div class="console"&gt;
&lt;div class="bezel"&gt;

    &lt;div class="scrnBevel"&gt;
    &lt;canvas id="cvsUpper" width="600" height="300"&gt;&lt;/canvas&gt;
    &lt;canvas id="cvsLower" width="600" height="300"&gt;&lt;/canvas&gt;
    &lt;/div&gt;  &lt;!-- scrnBevel --&gt;
    
    &lt;table class="btnHolder" cellspacing="0" cellpadding="0"&gt;
    &lt;tr align="center"&gt;
      &lt;td width="33%"&gt;&lt;button type="button" onclick="consoleBtns.f1()" class="button-link" id="load"&gt;HALF COCK&lt;/button&gt;&lt;/td&gt;
      &lt;td width="33%"&gt;&lt;button type="button" onclick="consoleBtns.f2()" class="button-link" id="cock"&gt;COCK&lt;/button&gt;&lt;/td&gt;
      &lt;td width="33%"&gt;&lt;button type="button" onclick="consoleBtns.f3()" class="button-link" id="fire"&gt;FIRE&lt;/button&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/table&gt;

&lt;/div&gt;  &lt;!-- bezel --&gt;
&lt;div style="clear: both;"&gt;&lt;/div&gt;
&lt;/div&gt; &lt;!-- console --&gt;
&lt;/div&gt;   &lt;!-- consoleHolder --&gt;

&lt;br /&gt;
&lt;br/&gt;

利用 &lt;a href="http://2015fallhw.github.io/cptocadp/static/gearUtils-05.js"&gt;http://2015fallhw.github.io/cptocadp/static/gearUtils-05.js&lt;/a&gt; 程式庫, 繪製正齒輪:

&lt;!-- 齒輪繪圖 --&gt;

&lt;canvas id='gear1' width='800' height='750'&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
# 針對 Javascript 既有的物件, 則必須透過 JSConstructor 轉換
from javascript import JSConstructor
import math

# 主要用來取得畫布大小
canvas = doc["gear1"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
#ctx = canvas.getContext("2d")
# 針對類別的轉換, 將 Cango.js 中的 Cango 物件轉為 Python cango 物件
cango = JSConstructor(window.Cango)
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
cobj = JSConstructor(window.Cobj)
creategeartooth = JSConstructor(window.createGearTooth)

# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="plotarea" 的 canvas 上
cgo = cango("gear1")

######################################
# 畫正齒輪輪廓
#####################################
# n 為齒數
n = 17
# pa 為壓力角
pa = 25
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
m = 0.8*canvas.width/n
# pr 為節圓半徑
pr = n*m/2 # gear Pitch radius
# generate gear
data = creategeartooth(m, n, pa)
# Brython 程式中的 print 會將資料印在 Browser 的 console 區
#print(data)
gearTooth = cobj(data, "SHAPE", {
        "fillColor":"#ddd0dd",
        "border": True,
        "strokeColor": "#606060" })
gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
# 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
gear = gearTooth.dup()
# gear 為單一齒的輪廓資料
#cgo.render(gearTooth)

# 利用單齒輪廓旋轉, 產生整個正齒輪外形
for i in range(1, n):
    # 將 gearTooth 中的資料複製到 newTooth
    newTooth = gearTooth.dup()
    # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
    newTooth.rotate(360*i/n)
    # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
    gear.appendPath(newTooth, True) # trim move command = True

# 建立軸孔
# add axle hole, hr 為 hole radius
hr = 0.6*pr # diameter of gear shaft
shaft = cobj(shapedefs.circle(hr), "PATH")
shaft.revWinding()
gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path
cx = canvas.width/2
cy = canvas.height/2
gear.translate(cx, cy)
# render 繪出靜態正齒輪輪廓
cgo.render(gear)
&lt;/script&gt;

&lt;br /&gt;
&lt;br /&gt;

上述正齒輪繪圖原始碼:

&lt;pre class="brush: python"&gt;
&amp;lt;canvas id='gear1' width='800' height='750'&amp;gt;&amp;lt;/canvas&amp;gt;

&amp;lt;script type="text/python"&amp;gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
# 針對 Javascript 既有的物件, 則必須透過 JSConstructor 轉換
from javascript import JSConstructor
import math

# 主要用來取得畫布大小
canvas = doc["gear1"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
#ctx = canvas.getContext("2d")
# 針對類別的轉換, 將 Cango.js 中的 Cango 物件轉為 Python cango 物件
cango = JSConstructor(window.Cango)
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
cobj = JSConstructor(window.Cobj)
creategeartooth = JSConstructor(window.createGearTooth)

# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="plotarea" 的 canvas 上
cgo = cango("gear1")

######################################
# 畫正齒輪輪廓
#####################################
# n 為齒數
n = 17
# pa 為壓力角
pa = 25
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
m = 0.8*canvas.width/n
# pr 為節圓半徑
pr = n*m/2 # gear Pitch radius
# generate gear
data = creategeartooth(m, n, pa)
# Brython 程式中的 print 會將資料印在 Browser 的 console 區
#print(data)
gearTooth = cobj(data, "SHAPE", {
        "fillColor":"#ddd0dd",
        "border": True,
        "strokeColor": "#606060" })
gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
# 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
gear = gearTooth.dup()
# gear 為單一齒的輪廓資料
#cgo.render(gearTooth)

# 利用單齒輪廓旋轉, 產生整個正齒輪外形
for i in range(1, n):
    # 將 gearTooth 中的資料複製到 newTooth
    newTooth = gearTooth.dup()
    # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
    newTooth.rotate(360*i/n)
    # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
    gear.appendPath(newTooth, True) # trim move command = True

# 建立軸孔
# add axle hole, hr 為 hole radius
hr = 0.6*pr # diameter of gear shaft
shaft = cobj(shapedefs.circle(hr), "PATH")
shaft.revWinding()
gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path
cx = canvas.width/2
cy = canvas.height/2
gear.translate(cx, cy)
# render 繪出靜態正齒輪輪廓
cgo.render(gear)
&amp;lt;/script&amp;gt;
&lt;/pre&gt;

&lt;br /&gt;&lt;br /&gt;

直接利用 Canvas 繪製正齒輪:

&lt;canvas id='gear2' width='800' height='700'&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
# 導入 browser 模組中的 document, 並設為 doc 變數
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

# 準備在 id="gear2" 的 canvas 中繪圖
canvas = doc["gear2"]
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2
r = 0.8*(canvas.width/2)
# 齒數
n = 53
# 壓力角
pa = 20
Spur(ctx).Gear(x, y, r, n, pa, "blue")
&lt;/script&gt;

&lt;br /&gt;&lt;br /&gt;

上述直接利用 Canvas 繪正齒輪的原始碼:

&lt;pre class="brush: python"&gt;
&amp;lt;canvas id='gear2' width='800' height='700'&amp;gt;&amp;lt;/canvas&amp;gt;

&amp;lt;script type="text/python3"&amp;gt;
# 導入 browser 模組中的 document, 並設為 doc 變數
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&amp;gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&amp;gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&amp;gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

# 準備在 id="gear2" 的 canvas 中繪圖
canvas = doc["gear2"]
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2
r = 0.8*(canvas.width/2)
# 齒數
n = 53
# 壓力角
pa = 20
Spur(ctx).Gear(x, y, r, n, pa, "blue")
&amp;lt;/script&amp;gt;
&lt;/pre&gt;
&lt;br /&gt;&lt;br /&gt;

正齒輪囓合繪圖:

&lt;canvas id='gear3' width='800' height='400'&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
# 導入 browser 模組中的 document, 並設為 doc 變數
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)

                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

# 準備在 id="gear3" 的 canvas 中繪圖
canvas = doc["gear3"]
ctx = canvas.getContext("2d")

# 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角
# 壓力角 pa 單位為角度
pa = 20
# 第1齒輪齒數
n_g1 = 17
# 第2齒輪齒數
n_g2 = 11
# 第3齒輪齒數
n_g3 = 13
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
m = (0.8*canvas.width)/(n_g1+n_g2+n_g3)
# 根據模數 m, 計算各齒輪的節圓半徑
rp_g1 = m*n_g1/2
rp_g2 = m*n_g2/2
rp_g3 = m*n_g3/2
#單一正齒輪繪圖呼叫格式 Spur(ctx).Gear(x, y, r, n, pa, "blue")
# 開始繪製囓合齒輪輪廓
# 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 的 80%, 所以兩邊各預留 10% 距離
x_g1 = canvas.width*0.1+rp_g1
# y 方向繪圖區域上方預留 canvas.height 的 20%
y_g1 = canvas.height*0.2+rp_g1
# 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同
x_g2 = x_g1 + rp_g1 + rp_g2
y_g2 = y_g1
# 第3齒輪的圓心座標
x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3
y_g3 = y_g1

# 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2
# 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g1, y_g1)
# rotate to engage
ctx.rotate(math.pi/2)
# put it back
ctx.translate(-x_g1, -y_g1)
# 繪製第一個齒輪輪廓
Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, "blue")
ctx.restore()

# 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g2, y_g2)
# rotate to engage
ctx.rotate(-math.pi/2-math.pi/n_g2)
# put it back
ctx.translate(-x_g2, -y_g2)
Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, "black")
ctx.restore()

# 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g3, y_g3)
# rotate to engage
# math.pi+math.pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度
# 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快
# 第1個 -math.pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度
# -math.pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合
# (math.pi+math.pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, 
# 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, 
# 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3
ctx.rotate(-math.pi/2-math.pi/n_g3+(math.pi+math.pi/n_g2)*n_g2/n_g3)
# put it back
ctx.translate(-x_g3, -y_g3)
Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, "red")
ctx.restore()
&lt;/script&gt;

&lt;br /&gt;&lt;br /&gt;

上述正齒輪囓合繪圖原始碼:

&lt;pre class="brush: python"&gt;
&amp;lt;canvas id='gear3' width='800' height='400'&amp;gt;&amp;lt;/canvas&amp;gt;

&amp;lt;script type="text/python3"&amp;gt;
# 導入 browser 模組中的 document, 並設為 doc 變數
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&amp;gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&amp;gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)

                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&amp;gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

# 準備在 id="gear3" 的 canvas 中繪圖
canvas = doc["gear3"]
ctx = canvas.getContext("2d")

# 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角
# 壓力角 pa 單位為角度
pa = 20
# 第1齒輪齒數
n_g1 = 17
# 第2齒輪齒數
n_g2 = 11
# 第3齒輪齒數
n_g3 = 13
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
m = (0.8*canvas.width)/(n_g1+n_g2+n_g3)
# 根據模數 m, 計算各齒輪的節圓半徑
rp_g1 = m*n_g1/2
rp_g2 = m*n_g2/2
rp_g3 = m*n_g3/2
#單一正齒輪繪圖呼叫格式 Spur(ctx).Gear(x, y, r, n, pa, "blue")
# 開始繪製囓合齒輪輪廓
# 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 的 80%, 所以兩邊各預留 10% 距離
x_g1 = canvas.width*0.1+rp_g1
# y 方向繪圖區域上方預留 canvas.height 的 20%
y_g1 = canvas.height*0.2+rp_g1
# 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同
x_g2 = x_g1 + rp_g1 + rp_g2
y_g2 = y_g1
# 第3齒輪的圓心座標
x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3
y_g3 = y_g1

# 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2
# 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g1, y_g1)
# rotate to engage
ctx.rotate(math.pi/2)
# put it back
ctx.translate(-x_g1, -y_g1)
# 繪製第一個齒輪輪廓
Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, "blue")
ctx.restore()

# 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g2, y_g2)
# rotate to engage
ctx.rotate(-math.pi/2-math.pi/n_g2)
# put it back
ctx.translate(-x_g2, -y_g2)
Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, "black")
ctx.restore()

# 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g3, y_g3)
# rotate to engage
# math.pi+math.pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度
# 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快
# 第1個 -math.pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度
# -math.pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合
# (math.pi+math.pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, 
# 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, 
# 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3
ctx.rotate(-math.pi/2-math.pi/n_g3+(math.pi+math.pi/n_g2)*n_g2/n_g3)
# put it back
ctx.translate(-x_g3, -y_g3)
Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, "red")
ctx.restore()
&amp;lt;/script&amp;gt;
&lt;/pre&gt;

&lt;br /&gt;&lt;br /&gt;

轉為 Brython 繪圖的模擬應用:

&lt;canvas id='robot' width='800' height='400'&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import window
 
cango2d = JSConstructor(window.Cango2D)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
tweener = JSConstructor(window.Tweener)

cgo = cango2d("robot")
# 清除畫面
cgo.clearCanvas("lightyellow")
cgo.setWorldCoords(-50, -50, 300)

# 加上基軸與第一桿
# 畫筆移到 -20, -10, 畫直線到 -10,-10 以及 -10,0 
standData = ['M', -20,-10, 'L', -10,-10, -10,0, 'A', 10,10,0,0,0,10,0, 'L',10,-10, 20,-10, 20,-40, -20,-40,'z']
stand = obj2d(standData, "SHAPE", {
        "fillColor":'darkgray',
        "border": True,
        "strokeColor": "#222222" })
axle0 = obj2d(shapedefs.circle(10), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222" })
armGrp = cgo.createGroup2D(stand, axle0)

segData = ['M',0,-8, 'A',8,8,0,0,0,0,8, 'L',50,8, 'A',8,8,0,0,0,50,-8, 'Z']
seg1 = obj2d(segData, "SHAPE", {
        "fillColor":'darkGray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": -1 })
# 利用 zIndex 決定疊層的先後次序
axle1 = obj2d(shapedefs.circle(8), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": 1 })
axle1.translate(50, 0)
seg1Grp = cgo.createGroup2D(seg1, axle1)
armGrp.addObj(seg1Grp)

# 加上第二軸
seg2 = obj2d(segData, "SHAPE", {
        "fillColor":'darkGray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": -1 })
axle2 = obj2d(shapedefs.circle(8), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": 1 })
axle2.translate(50, 0)
seg2Grp = cgo.createGroup2D(seg2, axle2)
cgo.render(seg2Grp)
# 請注意 seg2Grp 加上 seg1Grp 物件上
seg1Grp.addObj(seg2Grp)

seg3 = obj2d(segData, "SHAPE", {
        'fillColor':'darkGray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': -1 })
axle3 = obj2d(shapedefs.circle(6), "SHAPE", {
        'fillColor':'gray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': 1 })
axle3.translate(50, 0)
seg3Grp = cgo.createGroup2D(seg3, axle3)
seg2Grp.addObj(seg3Grp)

seg4Data = ['M',0,-6, 'A',6,6,0,0,0,0,6, 'L',40,6, 40,12, 50,12, 50,-12, 40,-12, 40,-6, 'Z']
seg4 = obj2d(seg4Data, "SHAPE", {
        'fillColor':'darkGray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': -1 })
seg3Grp.addObj(seg4)
      
# setup animation
animData = {'s1': [0, 80, 45, 0],
                  's2': [0, -60, -60, 0],
                  's3': [0, -90, 0, 90, 0],
                  's4': [0, 30, -90, 0]}

armTwnr = tweener(0, 3500, 'loop')

def initArm(opts):
    seg2Grp.transform.translate(50,0)
    seg3Grp.transform.translate(50,0)
    seg4.transform.translate(50,0)


def armPathFn(time, opts):
    seg1Rot = armTwnr.getVal(time, opts.s1)
    seg2Rot = armTwnr.getVal(time, opts.s2)
    seg3Rot = armTwnr.getVal(time, opts.s3)
    seg4Rot = armTwnr.getVal(time, opts.s4)

    seg1Grp.transform.rotate(seg1Rot)
    seg2Grp.transform.rotate(seg2Rot)
    seg2Grp.transform.translate(50,0)
    seg3Grp.transform.rotate(seg3Rot)
    seg3Grp.transform.translate(50,0)
    seg4.transform.rotate(seg4Rot)
    seg4.transform.translate(50,0)

cgo.animate(armGrp, initArm, armPathFn, animData)
cgo.playAnimation()
&lt;/script&gt;

&lt;br /&gt;&lt;br /&gt;

上述動態模擬的原始碼:

&lt;pre class="brush: python"&gt;
&amp;lt;canvas id='robot' width='800' height='400'&amp;gt;&amp;lt;/canvas&amp;gt;

&amp;lt;script type="text/python"&amp;gt;
from javascript import JSConstructor
from browser import window
 
cango2d = JSConstructor(window.Cango2D)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
tweener = JSConstructor(window.Tweener)

cgo = cango2d("robot")
# 清除畫面
cgo.clearCanvas("lightyellow")
cgo.setWorldCoords(-50, -50, 300)

# 加上基軸與第一桿
# 畫筆移到 -20, -10, 畫直線到 -10,-10 以及 -10,0 
standData = ['M', -20,-10, 'L', -10,-10, -10,0, 'A', 10,10,0,0,0,10,0, 'L',10,-10, 20,-10, 20,-40, -20,-40,'z']
stand = obj2d(standData, "SHAPE", {
        "fillColor":'darkgray',
        "border": True,
        "strokeColor": "#222222" })
axle0 = obj2d(shapedefs.circle(10), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222" })
armGrp = cgo.createGroup2D(stand, axle0)

segData = ['M',0,-8, 'A',8,8,0,0,0,0,8, 'L',50,8, 'A',8,8,0,0,0,50,-8, 'Z']
seg1 = obj2d(segData, "SHAPE", {
        "fillColor":'darkGray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": -1 })
# 利用 zIndex 決定疊層的先後次序
axle1 = obj2d(shapedefs.circle(8), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": 1 })
axle1.translate(50, 0)
seg1Grp = cgo.createGroup2D(seg1, axle1)
armGrp.addObj(seg1Grp)

# 加上第二軸
seg2 = obj2d(segData, "SHAPE", {
        "fillColor":'darkGray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": -1 })
axle2 = obj2d(shapedefs.circle(8), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": 1 })
axle2.translate(50, 0)
seg2Grp = cgo.createGroup2D(seg2, axle2)
cgo.render(seg2Grp)
# 請注意 seg2Grp 加上 seg1Grp 物件上
seg1Grp.addObj(seg2Grp)

seg3 = obj2d(segData, "SHAPE", {
        'fillColor':'darkGray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': -1 })
axle3 = obj2d(shapedefs.circle(6), "SHAPE", {
        'fillColor':'gray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': 1 })
axle3.translate(50, 0)
seg3Grp = cgo.createGroup2D(seg3, axle3)
seg2Grp.addObj(seg3Grp)

seg4Data = ['M',0,-6, 'A',6,6,0,0,0,0,6, 'L',40,6, 40,12, 50,12, 50,-12, 40,-12, 40,-6, 'Z']
seg4 = obj2d(seg4Data, "SHAPE", {
        'fillColor':'darkGray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': -1 })
seg3Grp.addObj(seg4)
      
# setup animation
animData = {'s1': [0, 80, 45, 0],
                  's2': [0, -60, -60, 0],
                  's3': [0, -90, 0, 90, 0],
                  's4': [0, 30, -90, 0]}

armTwnr = tweener(0, 3500, 'loop')

def initArm(opts):
    seg2Grp.transform.translate(50,0)
    seg3Grp.transform.translate(50,0)
    seg4.transform.translate(50,0)


def armPathFn(time, opts):
    seg1Rot = armTwnr.getVal(time, opts.s1)
    seg2Rot = armTwnr.getVal(time, opts.s2)
    seg3Rot = armTwnr.getVal(time, opts.s3)
    seg4Rot = armTwnr.getVal(time, opts.s4)

    seg1Grp.transform.rotate(seg1Rot)
    seg2Grp.transform.rotate(seg2Rot)
    seg2Grp.transform.translate(50,0)
    seg3Grp.transform.rotate(seg3Rot)
    seg3Grp.transform.translate(50,0)
    seg4.transform.rotate(seg4Rot)
    seg4.transform.translate(50,0)

cgo.animate(armGrp, initArm, armPathFn, animData)
cgo.playAnimation()
&amp;lt;/script&amp;gt;
&lt;/pre&gt;</t>
<t tx="amd.20160518215337.1">@language md
Title: Onshape 即將釋出 Featurescript 程式語言
Category: MISC
Tags: Onshape, Featurescript
Author: kmol
@others
今天早上參加 Onshape 在台灣所舉行的首次實體論壇，除了持續感受到 Onshape 團隊滿滿的誠意外，最大的收穫就是得知 Featurescript 特徵程式語言，即將開放各界使用。

&lt;!-- PELICAN_END_SUMMARY --&gt;

所謂的 Featurescript， 根據了解，是一種可以透過 Feature Studio， 讓使用者修改或延伸 Onshape 特徵指令的新程式語言，據悉，目前 Onshape 所指供的特徵指令功能，也是透過 Featurescript 打造。

並且，未來使用者所打造的各式客製化 Featurescript 程式，可以在 Onshape App store 中免費公開或販售。

</t>
<t tx="amd.20160518215339.1"></t>
<t tx="amd.20160521222238.1">@language md
Title: 大學教育政策白皮書讀後心得報告
Category: MISC
Tags: 大學教育
Author: kmol
@others
15 年前寫的&lt;a href="http://cad-lab.github.io/cadlab_data/files/90.07_taiwan_univ_white_paperpdf"&gt;大學教育政策白皮書&lt;/a&gt;讀後心得報告

&lt;!-- PELICAN_END_SUMMARY --&gt;

科技大學的本質在教導學生獲得知識的能力，二十一世紀知識經濟最大的特色，在於必須將知識迅速化為商品，由於市場全球化的影響，未能即時將本身所擁有的知識，快速轉化為商品，並被市場接受的企業，終將難逃被時代淘汰的命運，企業如此，教育界也正面臨同樣的挑戰。

教育部將大學的競爭力，視為國家競爭力的重要指標，全國各大學面對社會多元化的需求與全民終身學習的發展趨勢，如何在「大學教育政策白皮書」的基本方針下，強化各校的競爭力，建立各校的重點特色，便成為各大學今後所賴以生存的重要關鍵。

事實上，「大學教育政策白皮書」中所提到的觀點，或許是台灣一般大學與科技大學所共同面臨的問題，但，就基本體制上，仍然要有所區分，方能貫徹彼此的教育目標，為社會的現在與未來，提供充足的人力資源。吾人以為，一般大學的最高目標在追求學術的卓越，而科技大學則必須掌握技術的領先，學術強調的是其具備未來的主導性，卓越的學術指的是高瞻遠矚，是未來有用的技術；而技術的領先是要培養能馬上為企業所用的科技尖兵，是能馬上將知識轉化為商品的創新發明家。也許，隨著科技進化的速度日益增快，學術與技術的區隔，也就變得越來越小，但一般大學與科技大學應有的角色與定位，仍不失為各大學爭取重點特色時，所應強調的重點。

最後，談到本校在通過改名為科技大學後，如何在「大學教育政策白皮書」的指導方針下，爭取市場定位，並積極發展出屬於自己的特色，吾人以為，必須要先從小處做起，慢慢往大處做；必須要先由內做起，然後再漸漸往外落實。小處在哪裡，必須先用科學化與合理化來管理學校的每一個角落，然後才能談替企業診斷，為財團解憂。必須要先在校內建立起知識經濟的體系，然後才有可能與社會上全民學習的脈動相結合。未來，全球化經濟發展的趨勢或許很難臆測，但本校單類多科的包袱，如何逐步轉化為本校的重點特色，將是一項嚴酷的考驗，成敗的關鍵，就看現在。</t>
<t tx="amd.20160527201408.1">@language md
Title: 電腦輔助設計室的電腦開機磁區設置
Category: MISC
Tags: CADLab, Windows 10
Author: kmol
@others

第1磁區: Windows 10 Pro + &lt;a href="https://msdn.microsoft.com/zh-tw/virtualization/hyperv_on_windows/quick_start/walkthrough_install"&gt;Hyper-V&lt;/a&gt; 安裝 Windows 7 Professional

第2磁區: Windows 10 Pro + 可攜免安裝程式套件

第3磁區: &lt;a href="http://releases.ubuntu.com/16.04/"&gt;Ubuntu 16.04&lt;/a&gt; Server + ubuntu-desktop

&lt;!-- PELICAN_END_SUMMARY --&gt;

第1磁區擬舀採 Windows 10 Pro 開機, 並安裝常用的 CAD/CAE/CAM 相關軟體套件的安裝為主, 針對無法在 Windows 10 Pro 執行的套件, 則建議安裝在 Hyper-V 模式下的 Windows 7 Professional 開機磁區中.

第1磁區的網路設置以純 IPV4 為主, 並將最後一排的 9 台電腦, 以 IPV4/IPV6 雙支援的固定 IP 啟動 Ubuntu + &lt;a href="http://www.squid-cache.org/"&gt;Squid&lt;/a&gt; (選擇第3磁區開機), 讓上課師生自行選擇開機後透過 &lt;a href="https://en.wikipedia.org/wiki/Round-robin_DNS"&gt;Round Robin DNS&lt;/a&gt; 配置域名的代理主機增速上網.

第2磁區擬採 Windows 10 Pro 開機, 並全數使用無需安裝的程式套件, 以提升套件使用效能, 網路配置則彈性配置純 IPV4 或純 IPV6 位址上網, 當採用純 IPV6 上網時, 必須啟動電腦輔助設計室中的 9 台 IPV4/IPV6 雙支援代理主機 (以 Ubuntu 磁區開機).</t>
<t tx="amd.20160527213220.1">@language md
Title: 雲端平台上的電腦輔助機械設計
Category: MISC
Tags: CADLab, MCAD
Author: kmol
@others

&lt;a href="https://www.onshape.com/"&gt;Onshape&lt;/a&gt; 在 &lt;a href="http://wordpress-2015course.rhcloud.com/?p=4514"&gt;2015年12月&lt;/a&gt;正式全面對外公開之後, 已經啟動電腦輔助機械設計的雲端世代, 為了追求高效能的全球協同產品設計流程, 利用跨硬體裝置, 免安裝, 具備設計特徵版次管理, 而且提供類似 &lt;a href="https://cad.onshape.com/FsDoc/"&gt;Featurescript&lt;/a&gt; 客製化功能建構環境 (i.e. Feature Studio) 的全雲端電腦輔助機械設計工具, 將會日漸完備.

&lt;!-- PELICAN_END_SUMMARY --&gt;

面對 Onshape 的破壞性創新產品挑戰, SolidWorks 也以採用 &lt;a href="http://www.3ds.com/about-3ds/3dexperience-platform/"&gt;3dexperience platform&lt;/a&gt; 核心技術為主體, 推出全新的全雲端產品: &lt;a href="http://xdesign.solidworks.com/"&gt;Xdesign&lt;/a&gt; 回應.

目前, SolidWorks 單機版約佔全球市場&lt;a href="http://blog.cnccookbook.com/2015/01/20/results-2015-cad-survey/"&gt;超過五分之一&lt;/a&gt;, 未來將與自家的 Xdesign 與 Onshape 免安裝全雲端產品, 競逐全球電腦輔助機械設計軟體市場. 

因此, 2016 年可以說是電腦輔助機械設計的雲端元年, 正好比 2006 年推出的 &lt;a href="https://en.wikipedia.org/wiki/Google_Docs,_Sheets,_and_Slides"&gt;Google Doc&lt;/a&gt;, 晚了十年.</t>
<t tx="amd.20160529144234.1">@language md
Title: Onshape FeatureScript 程式語言
Category: MISC
Tags: CADLab, MCAD, Onshape, FeatureScript
Author: kmol
@others

在 &lt;a href="https://embedwistia-a.akamaihd.net/deliveries/02d2dfd77d4c465c42fa30e66e3bb53f26467cbc/file.mp4"&gt;FeatureScript 簡介&lt;/a&gt;的影片中, 可以看到 Onshape 打造了一個客製化特徵功能的程式語言與社群分享機制, 任何人利用 FeatureScript 建立的延伸功能, 都能夠透過 Add custom features 指令與其他使用者分享.

&lt;!-- PELICAN_END_SUMMARY --&gt;

FeatureScript 是 Onshape 發明, 一種可用來定義客製化參數特徵用的程式語言, 具有下列特點:

1. 各 Document 中用戶所建立的 FeatureScript 程式碼, 位於 Feature Studio (特徵工房) 分頁中.
2. FeatureScript 的整合開發環境 (Integrated Development Environment) 內建於 Onshape 中.
3. Onshape 原本系統中使用的特徵功能, 其對應的 FeatureScript 程式碼, 已經採&lt;a href="https://cad.onshape.com/documents/5749364ce4b0f60f1b7940fe/w/925a5467b6e725168eb9c993/e/ff3b765aacc32576f893ed23"&gt;開放源&lt;/a&gt; (Open Source) 模式釋出.
4. Onshape 同時提供 &lt;a href="https://cad.onshape.com/FsDoc/"&gt;FeatureScript 參考手冊&lt;/a&gt; 與 &lt;a href="https://forum.onshape.com/categories/featurescript"&gt;FeatureScript 論壇&lt;/a&gt;

登入 Onshape, 建立一個 Document 之後, 就可以透過左下角的 + 號中的 Create Feature Studio, 進入 FeatureScript 的整合開發環境, 開始編寫客製化的特徵程式碼, IDE 則提供下列相關功能:

Parameter (參數)

Length, Angle, Count, Query, Enum, Boolean and String

Query (查詢)

Everything, Nth element, Entity filter, Created by, Intersection, Subtraction, Symetric difference, Own by body, Own by body filter, Owner body, Entities adjacent to edge, Geometry type filter, Contains point, Intersects plane and Query evaluation

Evaluation (評量)

Tangent plane, Tangent line, Vertex point, Length measurement, Area measurement, Volume measurement, Query evaluation

Sketch, Line segment, Circle, Arc, Ellipse, Rectangle, Line segment chain

Cuboid, Cylinder, Extrude, Revolute, Fillet, Boolean, Transform, Import

Import (導入)

Format feature studio (整理特徵工房編輯格式)

Commit (提交)

FeatureScript 程式基本架構如下:

&lt;pre class="brush: jscript"&gt;
FeatureScript 355;
import(path : "onshape/std/geometry.fs", version : "355.0");
annotation { "Feature Type Name" : "My Feature" }
export const myFeature = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        // Define the parameters of the feature type
    }
    {
        // Define the function's action
    });
&lt;/pre&gt;

上層宣告, 列舉值與指令敘述都可以加上 annotations (註解). FeatureScript 的註解使用格式類似 Python 的 Dictionary, 但是 annotation 的索引值型別必須為字串, 而且索引值為 "Feature Type Name" 的 annotation 為每一個特徵指令的必要註解.

export 則可視為上述的程式碼中, 使用者所宣告的 myFeature 對應特徵物件會被優先置入 FeatureScript Template 中.

此外 Onshape 任一頁面送出時, 都帶有以下標頭設置, 除了利用 X-Frame-Options:SAMEORIGIN, 不允許使用者將頁面納入 iframe 或 object 標註中外, 也避免遭受可能的網路攻擊:

&lt;pre class="brush: jscript"&gt;
Cache-Control:must-revalidate,no-cache,no-store
Strict-Transport-Security:max-age=31536000; includeSubDomains
X-Content-Type-Options:nosniff
X-Frame-Options:SAMEORIGIN
X-XSS-Protection:1; mode=block
&lt;/pre&gt;

以下則為目前 Onshape 官方釋出的參考應用範例:

&lt;a href="https://cad.onshape.com/documents/57494220e4b04aa3f56f82c2/w/888534aeb52c4daa68bbfd05/e/4a55fd2861eaa83fae0221d9"&gt;Point Pattern FeatureScript 程式 Document&lt;/a&gt;

&lt;a href="https://cad.onshape.com/documents/57494152e4b05f50e871a72c/w/a4a3f09939bf1f43a8e4f133/e/2b865798923d6f648f7196f9"&gt;Spur Gear FeatureScript 程式 Document&lt;/a&gt;

&lt;a href="https://cad.onshape.com/documents/57494187e4b0f60f1b7941c8/w/b98b4de33c1d47713be20e7f/e/c1f8d65fc6196f728620b857"&gt;Wave Spring FeatureScript 程式 Document&lt;/a&gt;

Port feature 程式碼 (建立 SAE J1926 螺孔):

&lt;pre class="brush: jscript"&gt;
FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

export enum PortSize
{
    annotation { "Name" : "5/16-24" }
    fiveSixteen,
    annotation { "Name" : "3/8-24" }
    threeEights,
    annotation { "Name" : "7/16-20" }
    sevenSixteen,
    annotation { "Name" : "1/2-20" }
    half,
    annotation { "Name" : "9/16-18" }
    nineSixteen,
    annotation { "Name" : "3/4-16" }
    threeFour,
    annotation { "Name" : "7/8-14" }
    sevenEights,
    annotation { "Name" : "1 1/16-12" }
    oneSixteen
}

annotation { "Feature Type Name" : "Port Feature" }
export const portFeature = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Port Size" }
        definition.portSize is PortSize;

        annotation { "Name" : "Points", "Filter" : EntityType.VERTEX }
        definition.points is Query;

        annotation { "Name" : "Depth" }
        isLength(definition.depth, DEPTH_BOUNDS);
    }
    {
        var ports;
        var depth = definition.depth;
        //here the vector points for each port are added to an array depending on size chosen
        if (definition.portSize == PortSize.fiveSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .019 * inch, -.031 * inch),
                    vector(-.631, -.031) * inch,
                    vector(-.53, -.132) * inch,
                    vector(-.167, -.132) * inch,
                    vector(-.136, -.163) * inch,
                    vector(-.062, -.179) * inch,
                    vector(-.062, -.336) * inch,
                    vector(0, -.336) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.threeEights)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .038 * inch, -.063 * inch),
                    vector(-.629, -.063) * inch,
                    vector(-.53, -.162) * inch,
                    vector(-.169, -.162) * inch,
                    vector(-.136, -.195) * inch,
                    vector(-.062, -.211) * inch,
                    vector(-.062, -.375) * inch,
                    vector(0, -.375) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.sevenSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .052 * inch, -.086 * inch),
                    vector(-.663, -.086) * inch,
                    vector(-.547, -.202) * inch,
                    vector(-.176, -.202) * inch,
                    vector(-.155, -.224) * inch,
                    vector(-.062, -.243) * inch,
                    vector(-.062, -.414) * inch,
                    vector(0, -.414) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.half)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .07 * inch, -.117 * inch),
                    vector(-.71, -.117) * inch,
                    vector(-.607, -.22) * inch,
                    vector(-.188, -.22) * inch,
                    vector(-.153, -.255) * inch,
                    vector(-.062, -.275) * inch,
                    vector(-.062, -.453) * inch,
                    vector(0, -.453) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.nineSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .089 * inch, -.149 * inch),
                    vector(-.773, -.149) * inch,
                    vector(-.671, -.251) * inch,
                    vector(-.195, -.251) * inch,
                    vector(-.159, -.287) * inch,
                    vector(-.062, -.308) * inch,
                    vector(-.062, -.485) * inch,
                    vector(0, -.485) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.threeFour)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .117 * inch, -.196 * inch),
                    vector(-.928, -.196) * inch,
                    vector(-.782, -.341) * inch,
                    vector(-.237, -.341) * inch,
                    vector(-.194, -.384) * inch,
                    vector(-.094, -.406) * inch,
                    vector(-.094, -.594) * inch,
                    vector(0, -.594) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.sevenEights)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .145 * inch, -.242 * inch),
                    vector(-1.032, -.242) * inch,
                    vector(-.875, -.399) * inch,
                    vector(-.245, -.399) * inch,
                    vector(-.194, -.45) * inch,
                    vector(-.094, -.471) * inch,
                    vector(-.094, -.672) * inch,
                    vector(0, -.672) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.oneSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .183 * inch, -.304 * inch),
                    vector(-1.22, -.304) * inch,
                    vector(-1, -.525) * inch,
                    vector(-.246, -.525) * inch,
                    vector(-.224, -.546) * inch,
                    vector(-.094, -.574) * inch,
                    vector(-.094, -.813) * inch,
                    vector(0, -.813) * inch,
                    vector(0, 0) * inch];
        }
        const checkLength = (ports[3] - ports[2]); 
        if (checkLength[0] &lt; 0) // check the depth entered and throw error if depth causes feature to invert
        {
            throw regenError(ErrorStringEnum.SKETCH_DIMENSION_FAILED, ["depth"]);
        }
        var points = evaluateQuery(context, definition.points);
        var numberOfPoints = size(points);
        var sketchId = id + "sketch";
        var portId = "port1";
        for (var i = 0; i &lt; numberOfPoints; i += 1) //for each point selected create a sketch using port vertices and revolve cut
        {
            sketchId = sketchId + i;
            var point = points[i];
            var sketchPlane = evOwnerSketchPlane(context, { "entity" : point });
            var cSys = planeToCSys(sketchPlane);
            var pointVertex = evVertexPoint(context, { "vertex" : point });
            var sketchPlane2 = plane(pointVertex, cSys.xAxis, cSys.zAxis);
            var sketch = newSketchOnPlane(context, sketchId, { "sketchPlane" : sketchPlane2 });
            skPolyline(sketch, portId, { "points" : ports, "constrained" : false });
            skSolve(sketch);
            var axisQuery = sketchEntityQuery(sketchId, EntityType.EDGE, portId ~ ".line0");
            revolveCut(context, id, sketch, sketchId, axisQuery);
        }
        opDeleteBodies(context, id + "delete_sketch", { "entities" : qCreatedBy(id + "sketch", EntityType.BODY) });
        // delete the sketch
    }, { /* default parameters */ });

function revolveCut(context is Context, id is Id, sketch is Sketch, sketchId is Id, axisQuery is Query)
{
    var sketchQuery = qSketchRegion(sketchId, false);
    //revolve cut
    revolve(context, sketchId + "revolve", {
                "operationType" : NewBodyOperationType.REMOVE,
                "entities" : qUnion([sketchQuery]),
                "axis" : qUnion([axisQuery]),
                "revolveType" : RevolveType.FULL,
                "defaultScope" : true });
}

const DEPTH_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.0381, 500],
            (centimeter) : 3.81,
            (millimeter) : 38.1,
            (inch) : 1.5 // set the default depth to 1.5 inch
        } as LengthBoundSpec;
&lt;/pre&gt;

Screw Boss FeatureScript 原始碼:

&lt;pre class="brush: jscript"&gt;
/*    
    Screw Boss
    
    This custom feature creates a common fastening feature in plastic part design.
    
    The Screw Boss is just one version of this type of fastening feature 
    and could be easily extended to include many other types. This was built
    to show that you can create complex, compound features easily.

    Version 1 - April 26, 2016 - Neil Cooke, Onshape Inc.
*/ 

FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

annotation { "Feature Type Name" : "Screw Boss" }
export const ScrewBoss = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Sketch points to place bosses", "Filter" : EntityType.VERTEX &amp;&amp; SketchObject.YES &amp;&amp; ConstructionObject.NO }
        definition.locations is Query;

        annotation { "Name" : "Boss style" }
        definition.style is BossStyle;

        if (definition.style == BossStyle.BLIND)
        {
            annotation { "Name" : "Boss height", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.height, BOSS_HEIGHT);
        }
        else
        {
            annotation { "Name" : "Parallel face or plane", "Filter" : EntityType.FACE, "MaxNumberOfPicks" : 1 }
            definition.parallelFace is Query;
        }

        annotation { "Name" : "Boss diameter", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.diameter, BOSS_DIA);

        annotation { "Name" : "Ribs", "Default" : true, "UIHint" : "DISPLAY_SHORT" }
        definition.hasRibs is boolean;

        if (definition.hasRibs == true)
        {
            annotation { "Name" : "Number of ribs (max 6)", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
            isInteger(definition.ribCount, RIB_COUNT_BOUNDS);

            annotation { "Name" : "Flip rib direction", "UIHint" : "OPPOSITE_DIRECTION" }
            definition.ribFlipDirection is boolean;

            annotation { "Name" : "Edge to define rib direction", "Filter" : EntityType.EDGE, "MaxNumberOfPicks" : 1 }
            definition.ribDirection is Query;

            annotation { "Name" : "Rib diameter at top", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.ribDiameter, RIB_DIA);

            annotation { "Name" : "Rib distance from top", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.ribHeight, RIB_HEIGHT);

            annotation { "Name" : "Rib thickness", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.ribThickness, RIB_THK);

            annotation { "Name" : "Chamfer", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"], "Default" : true }
            definition.hasChamfer is boolean;

            if (definition.hasChamfer == true)
            {
                annotation { "Name" : "Chamfer size", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
                isLength(definition.chamferSize, CHAMFER_SIZE);
            }
        }

        annotation { "Name" : "Hole diameter", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.holeDiam, HOLE_DIA);

        annotation { "Name" : "Wall thickness", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.wallThickness, WALL_THK);

        annotation { "Name" : "Draft", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"], "Default" : true }
        definition.hasDraft is boolean;

        if (definition.hasDraft == true)
        {
            annotation { "Name" : "Draft angle", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
            isAngle(definition.draftAngle, DRAFT_ANGLE);
        }

        annotation { "Name" : "Merge scope", "Filter" : EntityType.BODY &amp;&amp; BodyType.SOLID }
        definition.booleanScope is Query;
    }

    {
        // get all the user selected locations
        const locations = evaluateQuery(context, definition.locations);

        // if a solid body intersects the first point in the list, automatically use that in the merge scope
        const targetBody = evaluateQuery(context, qContainsPoint(qBodyType(qEverything(EntityType.BODY), BodyType.SOLID), evVertexPoint(context, { "vertex" : locations[0] })));

        if (size(targetBody) == 0 &amp;&amp; definition.booleanScope != undefined)
            definition.targetBody = definition.booleanScope; // if not, get user to select merge scope
        else
            definition.targetBody = targetBody[0];

        var sketchPlane is Plane = evOwnerSketchPlane(context, { "entity" : locations[0] });
        var topPlane;
        var ribPlane;

        // define the plane for the top of the boss
        if (definition.style == BossStyle.PLANE &amp;&amp; definition.parallelFace != undefined)
            topPlane = evPlane(context, { "face" : definition.parallelFace });
        else
            topPlane = plane(sketchPlane.origin + definition.height * sketchPlane.normal, sketchPlane.normal);

        var nameId = 1;

        definition.sketch = newSketchOnPlane(context, id + "sketch1", { "sketchPlane" : topPlane });

        // Build first feature - extruded circle
        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skCircle(definition.sketch, "circle" ~ nameId, {
                        "center" : vector(point[0], point[1]),
                        "radius" : definition.diameter / 2
                    });
            nameId += 1;
        }
        skSolve(definition.sketch);

        extrude(context, id + ("extrude1"), {
                    "entities" : qSketchRegion(id + "sketch1"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.ADD,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        // Build second feature - extruded ribs
        if (definition.hasRibs)
        {
            // define top of ribs
            ribPlane = plane(topPlane.origin - definition.ribHeight * topPlane.normal, topPlane.normal);

            var ribVector = vector(0, 1); // by default pointing up in Y

            // if user has defined rib direction, work out the vector
            if (definition.ribDirection != undefined)
            {
                const directionResult = try(evAxis(context, { "axis" : definition.ribDirection }));

                if (directionResult != undefined)
                    ribVector = normalize(vector(directionResult.direction[0], directionResult.direction[1]));
            }

            if (definition.ribFlipDirection)
                ribVector = ribVector * -1;

            definition.sketch = newSketchOnPlane(context, id + "sketch2", { "sketchPlane" : ribPlane });

            const ribPlaneCSys = planeToCSys(ribPlane);
            var chamferPoints = [];

            nameId = 1;

            for (var location in locations)
            {
                var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

                const center = vector(point[0], point[1]);

                // Build a closed "star" shaped sketch to represent the ribs
                for (var j = 0; j &lt; definition.ribCount; j += 1)
                {
                    var angle = (360 / definition.ribCount) * j * degree;

                    // The angle for each rib
                    var angledRibVector = vector(ribVector[0] * cos(angle) - ribVector[1] * sin(angle),
                        ribVector[0] * sin(angle) + ribVector[1] * cos(angle));

                    var perpRibVector = vector(angledRibVector[1] * -1, angledRibVector[0]);

                    var ribOffset = definition.ribThickness / 2 / tan(180 / definition.ribCount * degree);

                    if (definition.ribCount == 1)
                        ribOffset = 0 * meter;

                    var points = [
                        center - (definition.ribThickness / 2) * perpRibVector + (ribOffset) * angledRibVector,
                        center - (definition.ribThickness / 2) * perpRibVector + (definition.ribDiameter / 2) * angledRibVector,
                        center + (definition.ribThickness / 2) * perpRibVector + (definition.ribDiameter / 2) * angledRibVector,
                        center + (definition.ribThickness / 2) * perpRibVector + (ribOffset) * angledRibVector];

                    for (var i = 0; i &lt; size(points); i += 1)
                    {
                        skLineSegment(definition.sketch, "line" ~ nameId,
                                { "start" : points[i],
                                    "end" : points[(i + 1) % size(points)]
                                });
                        nameId += 1;
                    }

                    // Keep a list of the centerpoints of the edges where the chamfers may go
                    var chamferPoint2d = center + (definition.ribDiameter / 2) * angledRibVector;
                    chamferPoints = append(chamferPoints, toWorld(ribPlaneCSys, vector(chamferPoint2d[0], chamferPoint2d[1], 0 * meter)));
                }
                nameId += 1;
            }
            skSolve(definition.sketch);

            extrude(context, id + ("extrude2"), {
                        "entities" : qSketchRegion(id + "sketch2"),
                        "endBound" : BoundingType.UP_TO_BODY,
                        "endBoundEntityBody" : definition.targetBody,
                        "oppositeDirection" : true,
                        "hasDraft" : definition.hasDraft,
                        "draftAngle" : definition.draftAngle,
                        "draftPullDirection" : false,
                        "operationType" : NewBodyOperationType.ADD,
                        "defaultScope" : false,
                        "booleanScope" : definition.targetBody
                    });

            // Build third feature - chamfers
            if (definition.hasChamfer)
            {
                var chamferEdges = [];

                for (var i = 0; i &lt; size(chamferPoints); i += 1)
                {
                    // Find the edges that intersect the points previously collected
                    chamferEdges = append(chamferEdges, qContainsPoint(qCreatedBy(id + "extrude2", EntityType.EDGE), chamferPoints[i]));
                }

                try(opChamfer(context, id + "chamfer1", {
                                "entities" : qUnion(chamferEdges),
                                "chamferType" : ChamferType.EQUAL_OFFSETS,
                                "width" : definition.chamferSize
                            }));
            }
        }

        nameId = 1;

        // Build fourth feature - through hole to outside of part
        var holePlane = plane(topPlane.origin - definition.wallThickness * topPlane.normal, topPlane.normal);

        definition.sketch = newSketchOnPlane(context, id + "sketch3", { "sketchPlane" : holePlane });

        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skCircle(definition.sketch, "circle" ~ nameId, {
                        "center" : vector(point[0], point[1]),
                        "radius" : definition.diameter / 2 - definition.wallThickness
                    });
            nameId += 1;
        }
        skSolve(definition.sketch);

        extrude(context, id + ("extrude3"), {
                    "entities" : qSketchRegion(id + "sketch3"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.REMOVE,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        nameId = 1;

        // Build fifth feature - screw hole
        definition.sketch = newSketchOnPlane(context, id + "sketch4", { "sketchPlane" : topPlane });

        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skCircle(definition.sketch, "circle" ~ nameId, {
                        "center" : vector(point[0], point[1]),
                        "radius" : definition.holeDiam / 2
                    });
            nameId += 1;
        }
        skSolve(definition.sketch);

        extrude(context, id + ("extrude4"), {
                    "entities" : qSketchRegion(id + "sketch4"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.REMOVE,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        // Remove sketch entities - no longer required
        var sketches = [qCreatedBy(id + "sketch1"), qCreatedBy(id + "sketch2"), qCreatedBy(id + "sketch3"), qCreatedBy(id + "sketch4")];
        opDeleteBodies(context, id + "delete", { "entities" : qUnion(sketches) });

    }, {});

const BOSS_HEIGHT =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.02, 500],
            (centimeter) : 2.0,
            (millimeter) : 20.0,
            (inch) : 0.8
        } as LengthBoundSpec;

const BOSS_DIA =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.008, 500],
            (centimeter) : 0.8,
            (millimeter) : 8.0,
            (inch) : 0.3125
        } as LengthBoundSpec;

const RIB_COUNT_BOUNDS =
{
            "min" : 1,
            "max" : 6,
            (unitless) : [1, 4, 6]
        } as IntegerBoundSpec;

const RIB_DIA =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.015, 500],
            (centimeter) : 1.5,
            (millimeter) : 15.0,
            (inch) : 0.6
        } as LengthBoundSpec;

const RIB_HEIGHT =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [0, 0.005, 500],
            (centimeter) : 0.5,
            (millimeter) : 5.0,
            (inch) : 0.2
        } as LengthBoundSpec;

const RIB_THK =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.001, 500],
            (centimeter) : 0.1,
            (millimeter) : 1.0,
            (inch) : 0.04
        } as LengthBoundSpec;

const CHAMFER_SIZE =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.002, 500],
            (centimeter) : 0.2,
            (millimeter) : 2.0,
            (inch) : 0.08
        } as LengthBoundSpec;

const HOLE_DIA =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.003, 500],
            (centimeter) : 0.3,
            (millimeter) : 3.0,
            (inch) : 0.12
        } as LengthBoundSpec;

const WALL_THK =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.0015, 500],
            (centimeter) : 0.15,
            (millimeter) : 1.5,
            (inch) : 0.06
        } as LengthBoundSpec;

const DRAFT_ANGLE =
{
            "min" : -TOLERANCE.zeroAngle * radian,
            "max" : (2 * PI + TOLERANCE.zeroAngle) * radian,
            (degree) : [0, 2, 360],
            (radian) : 0.035
        } as AngleBoundSpec;

export enum BossStyle
{
    annotation { "Name" : "Blind" }
    BLIND,
    annotation { "Name" : "Up to face" }
    PLANE
}
&lt;/pre&gt;
</t>
<t tx="amd.20160529155022.1">@language md
Title: Onshape FeatureScript 程式語言 (一)
Category: MISC
Tags: CADLab, MCAD, Onshape, FeatureScript
Author: kmol
@others

接續上一篇文章, 整理目前 Onshape 已經釋出的 FeatureScript 相關應用範例.

&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;a href="https://cad.onshape.com/documents/574941a2e4b05f50e871a75a/w/1c096ba7cb6b4bb6d74f8ffa/e/8c83ef9b92095a980e185cf8"&gt;Curve Pattern FeatureScript 程式 Document&lt;/a&gt;

&lt;a href="https://cad.onshape.com/documents/57494139e4b04aa3f56f8243/w/cad51c78bef702f93d689668/e/0cfa9d7c4606e1f2ae32be16"&gt;Helix in Fill FeatureScript 程式 Document&lt;/a&gt;

&lt;a href="https://cad.onshape.com/documents/57494120e4b04aa3f56f8206/w/d17e3ff3f757fabdb9084368/e/ab4048d5790d64d16e68e02d"&gt;3D Spline Fill FeatureScript 程式 Document&lt;/a&gt;

&lt;a href="https://cad.onshape.com/documents/57494101e4b04aa3f56f81ed/w/b2ffdc215aff14ea3817b535/e/1626934c31793c1d4d18eb6f"&gt;Brick FeatureScript 程式 Document&lt;/a&gt;

&lt;a href="https://cad.onshape.com/documents/57494096e4b05f50e871a70e/w/165ebc7b4103e5b6c91e3f5b/e/bfd58761a0e39c157f11bd42"&gt;Measure Distance FeatureScript 程式 Document&lt;/a&gt;

&lt;a href="https://cad.onshape.com/documents/5749420ae4b04aa3f56f8288/w/ed9f79b9809ffe7610f9c537/e/aa01cfec5e04037e7ca611b7"&gt;Lighten FeatureScript 程式 Document&lt;/a&gt;

Snap Hook FeatureScript 程式原始碼:

&lt;pre class="brush: jscript"&gt;
/*    
    Snap Hook
    
    This custom feature creates a common fastening feature in plastic part design.
    
    The Snap Hook is just one version of this type of fastening feature 
    and could be easily extended to include many other types. This was built
    to show that you can create complex, compound features easily.

    Version 1 - April 26, 2016 - Neil Cooke, Onshape Inc.
*/ 

FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

annotation { "Feature Type Name" : "Snap Hook" }
export const SnapHook = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Sketch point locations", "Filter" : EntityType.VERTEX &amp;&amp; SketchObject.YES &amp;&amp; ConstructionObject.NO }
        definition.locations is Query;

        annotation { "Name" : "Height type" }
        definition.style is HookStyle;

        if (definition.style == HookStyle.BLIND)
        {
            annotation { "Name" : "Height", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.height, HOOK_HEIGHT);
        }
        else
        {
            annotation { "Name" : "Parallel face or plane", "Filter" : EntityType.FACE, "MaxNumberOfPicks" : 1 }
            definition.parallelFace is Query;
        }

        annotation { "Name" : "Width", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.hookWidth, HOOK_WIDTH);

        annotation { "Name" : "Flip direction", "UIHint" : "OPPOSITE_DIRECTION" }
        definition.hookFlipDirection is boolean;

        annotation { "Name" : "Edge to define direction", "Filter" : EntityType.EDGE, "MaxNumberOfPicks" : 1 }
        definition.hookDirection is Query;

        annotation { "Name" : "Thickness", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.hookThickness, HOOK_THK);

        annotation { "Name" : "Undercut depth", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.hookDepth, HOOK_THK);

        annotation { "Name" : "Lip height", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.flatHeight, HOOK_LIP);

        annotation { "Name" : "Insertion angle", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isAngle(definition.deflectionAngle, HOOK_ANGLE);

        annotation { "Name" : "Draft", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"], "Default" : true }
        definition.hasDraft is boolean;

        if (definition.hasDraft == true)
        {
            annotation { "Name" : "Draft angle", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
            isAngle(definition.draftAngle, ANGLE_STRICT_90_BOUNDS);

            annotation { "Name" : "Back face draft angle", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isAngle(definition.backDraftAngle, ANGLE_STRICT_90_BOUNDS);
        }
        annotation { "Name" : "Cutout", "Default" : true }
        definition.hasCutout is boolean;

        annotation { "Name" : "Merge scope", "Filter" : EntityType.BODY &amp;&amp; BodyType.SOLID }
        definition.booleanScope is Query;
    }

    {
        // get all the user selected locations
        const locations = evaluateQuery(context, definition.locations);

        // if a solid body intersects the first point in the list, automatically use that in the merge scope
        const targetBody = evaluateQuery(context, qContainsPoint(qBodyType(qEverything(EntityType.BODY), BodyType.SOLID), evVertexPoint(context, { "vertex" : locations[0] })));

        if (size(targetBody) == 0 &amp;&amp; definition.booleanScope != undefined)
            definition.targetBody = definition.booleanScope; // if not, get user to select merge scope
        else
            definition.targetBody = targetBody[0];

        var sketchPlane is Plane = evOwnerSketchPlane(context, { "entity" : locations[0] });
        var topPlane;

        var hookVector = vector(1, 0); // by default pointing across in x

        // if user has defined hook direction, work out the vector
        if (definition.hookDirection != undefined)
        {
            const directionResult = try(evAxis(context, { "axis" : definition.hookDirection }));

            if (directionResult != undefined)
                hookVector = normalize(vector(directionResult.direction[0], directionResult.direction[1]));
        }

        if (definition.hookFlipDirection)
            hookVector = hookVector * -1;

        // get vector perpendicular to hook direction
        var perpHookVector = vector(hookVector[1] * -1, hookVector[0]);

        // define the plane for the top of the boss
        if (definition.style == HookStyle.PLANE &amp;&amp; definition.parallelFace != undefined)
            topPlane = evPlane(context, { "face" : definition.parallelFace });
        else
            topPlane = plane(sketchPlane.origin + definition.height * sketchPlane.normal, sketchPlane.normal);

        var nameId = 1;
        var chamferPoints = [];
        var frontFacePoints = [];
        var backFacePoints = [];

        const sketch1 = newSketchOnPlane(context, id + "sketch1", { "sketchPlane" : topPlane });
        const sketch2 = newSketchOnPlane(context, id + "sketch2", { "sketchPlane" : topPlane });
        const sketch3 = newSketchOnPlane(context, id + "sketch3", { "sketchPlane" : topPlane });

        definition.depth = definition.hookDepth / tan(definition.deflectionAngle) + definition.flatHeight;

        // Build 3 sketches each with a rectangle
        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skRectangle(sketch1, "rectangleHook" ~ nameId, {
                        "firstCorner" : vector(point[0], point[1]) + (definition.hookWidth / 2) * hookVector,
                        "secondCorner" : vector(point[0], point[1]) - (definition.hookWidth / 2) * hookVector - definition.hookDepth * perpHookVector
                    });

            skRectangle(sketch2, "rectangleThickness" ~ nameId, {
                        "firstCorner" : vector(point[0], point[1]) - (definition.hookWidth / 2) * hookVector,
                        "secondCorner" : vector(point[0], point[1]) + (definition.hookWidth / 2) * hookVector + definition.hookThickness * perpHookVector
                    });

            skRectangle(sketch3, "completeRectangle" ~ nameId, {
                        "firstCorner" : vector(point[0], point[1]) - (definition.hookWidth / 2) * hookVector - definition.hookDepth * perpHookVector,
                        "secondCorner" : vector(point[0], point[1]) + (definition.hookWidth / 2) * hookVector + definition.hookThickness * perpHookVector
                    });

            // Keep a list of the centerpoints of the edges where the chamfers may go
            var chamferPoint2d = vector(point[0], point[1]) - definition.hookDepth * perpHookVector;
            if (definition.hasDraft)
            {
                chamferPoint2d = vector(point[0], point[1]) - (definition.hookDepth - definition.depth * tan(definition.draftAngle)) * perpHookVector;
            }
            chamferPoints = append(chamferPoints, toWorld(planeToCSys(topPlane), vector(chamferPoint2d[0], chamferPoint2d[1], definition.depth)));

            var backFacePoint2d = vector(point[0], point[1]) + definition.hookThickness * perpHookVector;
            backFacePoints = append(backFacePoints, toWorld(planeToCSys(topPlane), vector(backFacePoint2d[0], backFacePoint2d[1], 0 * meter)));
            frontFacePoints = append(frontFacePoints, toWorld(planeToCSys(topPlane), vector(point[0], point[1], 0 * meter)));

            nameId += 1;
        }
        skSolve(sketch1);
        skSolve(sketch2);
        skSolve(sketch3);

        extrude(context, id + ("extrude1"), {
                    "entities" : qSketchRegion(id + "sketch2"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "depth" : definition.depth,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.ADD,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        extrude(context, id + ("extrude2"), {
                    "entities" : qSketchRegion(id + "sketch3"),
                    "endBound" : BoundingType.BLIND,
                    "depth" : definition.depth,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : false,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : true,
                    "operationType" : NewBodyOperationType.ADD,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        var chamferEdges = [];

        for (var i = 0; i &lt; size(chamferPoints); i += 1)
        {
            // Find the edges that intersect the points previously collected
            chamferEdges = append(chamferEdges, qContainsPoint(qCreatedBy(id + "extrude2", EntityType.EDGE), chamferPoints[i]));
        }

        try(opChamfer(context, id + "chamfer1", {
                        "entities" : qUnion(chamferEdges),
                        "chamferType" : ChamferType.OFFSET_ANGLE,
                        "width" : definition.depth - definition.flatHeight,
                        "angle" : definition.deflectionAngle,
                        "oppositeDirection" : true
                    }));

        if (definition.hasDraft)
        {
            var backFaces = [];
            var frontFaces = [];

            for (var i = 0; i &lt; size(backFacePoints); i += 1)
            {
                // Find the edges that intersect the points previously collected
                backFaces = append(backFaces, qContainsPoint(qCreatedBy(id + "extrude1", EntityType.FACE), backFacePoints[i]));
                frontFaces = append(frontFaces, qContainsPoint(qCreatedBy(id + "extrude1", EntityType.FACE), frontFacePoints[i]));
            }

            opPlane(context, id + "plane1", {
                        "plane" : topPlane,
                        "size" : 0.1 * meter
                    });

            opDraft(context, id + "draft1", {
                        "neutralPlane" : qCreatedBy(id + "plane1", EntityType.FACE),
                        "pullVec" : topPlane.normal,
                        "draftFaces" : qUnion(frontFaces),
                        "angle" : 0 * degree
                    });
                    
            opDraft(context, id + "draft2", {
                        "neutralPlane" : qCreatedBy(id + "plane1", EntityType.FACE),
                        "pullVec" : topPlane.normal,
                        "draftFaces" : qUnion(backFaces),
                        "angle" : definition.backDraftAngle + definition.draftAngle
                    });
        }

        if (definition.hasCutout)
        {
            extrude(context, id + ("extrude3"), {
                        "entities" : qSketchRegion(id + "sketch1"),
                        "endBound" : BoundingType.THROUGH_ALL,
                        "depth" : definition.depth,
                        "endBoundEntityBody" : definition.targetBody,
                        "oppositeDirection" : true,
                        "hasDraft" : definition.hasDraft,
                        "draftAngle" : definition.draftAngle,
                        "draftPullDirection" : false,
                        "operationType" : NewBodyOperationType.REMOVE,
                        "defaultScope" : false,
                        "booleanScope" : definition.targetBody
                    });
        }

        // Remove sketch entities and plane - no longer required
        var sketches = [qCreatedBy(id + "sketch1"), qCreatedBy(id + "sketch2"), qCreatedBy(id + "sketch3"), qCreatedBy(id + "plane1")];
        opDeleteBodies(context, id + "delete", { "entities" : qUnion(sketches) });

    }, {});

const HOOK_ANGLE =
{
            "min" : -TOLERANCE.zeroAngle * radian,
            "max" : (2 * PI + TOLERANCE.zeroAngle) * radian,
            (degree) : [15, 30, 60]
        } as AngleBoundSpec;

const HOOK_HEIGHT =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.015, 500],
            (centimeter) : 1.5,
            (millimeter) : 15.0,
            (inch) : 0.6
        } as LengthBoundSpec;

const HOOK_WIDTH =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.005, 500],
            (centimeter) : 0.5,
            (millimeter) : 5.0,
            (inch) : 0.2
        } as LengthBoundSpec;

const HOOK_THK =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.002, 500],
            (centimeter) : 0.2,
            (millimeter) : 2.0,
            (inch) : 0.08
        } as LengthBoundSpec;

const HOOK_LIP =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.001, 500],
            (centimeter) : 0.1,
            (millimeter) : 1.0,
            (inch) : 0.04
        } as LengthBoundSpec;

export enum HookStyle
{
    annotation { "Name" : "Blind" }
    BLIND,
    annotation { "Name" : "Up to face" }
    PLANE
}
&lt;/pre&gt;

Fill Pattern FeatureScript 程式碼:

&lt;pre class="brush: jscript"&gt;
FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");
import(path : "onshape/std/transform.fs", version : "336.0");

/**
 * Performs a pattern of faces within a face. The instances are placed in a hexagonal pattern and no instances will be 
 * created that cross the boundary of the face. If a border is set then no instances are created within a border of that size
 * @param definition {{
 *      @field entities A collection of faces that will be patterned
 *      @field target A planar face that contains the 'entities' faces and that will contain the pattern
 *      @field direction Specifies the alignment of the pattern in the face
 *      @field distance The distance between the center of the instances
 *      @field border The width of the "exclusion zone" at the edge of the target face     
 * }}
 */
annotation { "Feature Type Name" : "Fill pattern", "Filter Selector" : "allparts" }
export const fillPattern = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Faces to pattern",
                     "Filter" : EntityType.FACE &amp;&amp; ConstructionObject.NO &amp;&amp; SketchObject.NO }
        definition.entities is Query;
        annotation { "Name" : "Target face", "Filter" : GeometryType.PLANE, "MaxNumberOfPicks" : 1 }
        definition.target is Query;
        annotation { "Name" : "Direction", "Filter" : QueryFilterCompound.ALLOWS_AXIS, "MaxNumberOfPicks" : 1 }
        definition.direction is Query;        
        annotation { "Name" : "Distance" }
        isLength(definition.distance, LENGTH_BOUNDS);
        annotation { "Name" : "Border" }
        isLength(definition.border, NONNEGATIVE_ZERO_DEFAULT_LENGTH_BOUNDS);
    }
    {
        var transforms = [];
        var instanceNames = [];

        var direction = try(evAxis(context, { "axis" : definition.direction })).direction;
        println(direction);
        var normal = try(evPlane(context, {
            "face" : definition.target
        })).normal;
        
        // For a hexagonal pattern we have two directions, with one being at an angle of 60 degrees from the other.
        // If we pattern in both those directions then we get a hexagonal pattern with equal spacing
        var vertical = cross(normal, direction);
        var angled = (direction * cos(60 * degree)) + (vertical * sin(60 * degree));
                
        // We want to get the edges of the target face so that we can get the distance from the face boundary
        // However, because the tool faces ought to be "in" the target face we don't want to count those
        // We can use booleans on the queries, which is pretty nice. We can also take the opportunity to ensure
        // that at least some edges are shared
        var allTargetEdges = qEdgeAdjacent(definition.target, EntityType.EDGE);
        var toolEdges = qEdgeAdjacent(definition.entities, EntityType.EDGE);
        var targetEdges = qSubtraction(allTargetEdges, toolEdges);
        var edgesInFace = qIntersection([allTargetEdges, toolEdges]);
        if (size(evaluateQuery(context, edgesInFace)) == 0) {
            throw regenError("The entities must share edges with the target face");
        }
        
        // To prevent excessive calculation we do a quick exclusion of faces based on bounding boxes
        // It doesn't need to be perfect. Get the box of the target face and of the shared edges
        var faceBox = try(evBox3d(context, {
            "topology" : definition.target
        }));
        var toolBox = try(evBox3d(context, {
            "topology" : edgesInFace
        }));
        
        // Again, to prevent excessive computation we will estimate the maximum number of instances and
        // fail early if we exceed some limit.
        var diagonal = faceBox.maxCorner - faceBox.minCorner;    
        var maximumIndex = round((norm(diagonal) - (definition.border * 2)) / definition.distance);
        var toolSize = norm(toolBox.maxCorner - toolBox.minCorner);
        var estimatedIndexCount = maximumIndex * maximumIndex;
        if (estimatedIndexCount &gt; 2500)
        {
            throw regenError("Too many instances in the pattern (estimate: " ~ 
                estimatedIndexCount ~ " ). Try a larger spacing.");
        }
        
        // Now we loop and look to see if the instance should be included
        for (var i = -maximumIndex; i &lt;= maximumIndex; i += 1)
        {
            for (var j = -maximumIndex; j &lt;= maximumIndex; j += 1)
            {
                if (abs(i) &lt; 0.5 &amp;&amp; abs(j) &lt; 0.5)
                {
                    // Zero transform = initial position =&gt; Skip
                    continue;
                }
                var translation = ((direction * i) + (angled * j)) * definition.distance;
                var instanceTransform = transform(translation);
                // Now that we have the transform we transform the tool box and see if it is within the face
                // but not too close to the edges of the face
                // Note: this isn't exact, it uses the center of the face and the size of the face box 
                // rather than transforming the geometry every time.
                var xformed = box3d(toolBox.minCorner + translation, toolBox.maxCorner + translation);
                if (clash(xformed, faceBox))
                {
                    var minDistance = evDistance(context, {
                            "side0" : targetEdges,
                            "side1" : (xformed.minCorner + xformed.maxCorner) * 0.5
                    });
                    // Note: if border is zero this still results in a border that is half the size of the tool,
                    // the border is additional on top of that
                    if (minDistance.distance &gt; (toolSize + definition.border))
                    {
                        transforms = append(transforms, instanceTransform);
                        instanceNames = append(instanceNames, "" ~ i ~ "." ~ j);
                    }
                }                
            }
        }

        // Now we set the data as needed by the applyPattern function before calling it.
        definition.patternType = PatternType.FACE;
        definition.transforms = transforms;
        definition.instanceNames = instanceNames;
        definition.seed = definition.entities;

        var remainingTransform = getRemainderPatternTransform(context, { "references" : definition.entities });
        applyPattern(context, id, definition, remainingTransform);
    }, { });
    
/**
 * Utility function to do a quick clash of boxes
 */
function clash(box1 is Box3d, box2 is Box3d) returns boolean
{
    for (var index = 0; index &lt; 3; index += 1)
    {
        var min1 = box1.minCorner[index];
        var max1 = box1.maxCorner[index];
        var min2 = box2.minCorner[index];
        var max2 = box2.maxCorner[index];
        // Comparisons to zero are never a good idea because values that are calculated separately are
        // rarely the same to machine precision. FeatureScript provides tolerant equality methods
        // but not tolerant inequalities. No matter, we can fashion one ourselves by checking the
        // inequality and excluding approximate equality
        if ((max1 &lt; min2 &amp;&amp; !tolerantEquals(max1, min2)) || (max2 &lt; min1 &amp;&amp; !tolerantEquals(max2, min1)))
        {
            return false;
        }
    }
    return true;
}
&lt;/pre&gt;

Rib FeatureScript 程式碼:

&lt;pre class="brush: jscript"&gt;
FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

const RIB_THICKEN_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [0.0, 0.005, 500],
            (centimeter) : 0.5,
            (millimeter) : 5.0,
            (inch) : 0.25,
            (foot) : 0.025,
            (yard) : 0.01
        } as LengthBoundSpec;

/**
 * Specifies the direction of the rib extrusion starting from the profile
 * going up to the part.
 *
 * @value NORMAL_TO_SKETCH_PLANE : The direction of the rib extrusion goes normal to the profile sketch plane.
 * @value PARALLEL_TO_SKETCH_PLANE : The direction of the rib extrusion goes parallel to the profile sketch plane.
 */
export enum RibExtrusionDirection
{
    annotation { "Name" : "Normal to sketch plane" }
    NORMAL_TO_SKETCH_PLANE,
    annotation { "Name" : "Parallel to sketch plane" }
    PARALLEL_TO_SKETCH_PLANE
}

function isClosed(context is Context, edge is Query) returns boolean
{
    return size(evaluateQuery(context, qVertexAdjacent(edge, EntityType.VERTEX))) &lt; 2;
}

annotation { "Feature Type Name" : "Rib" }
export const rib = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Sketch profiles", "Filter" : EntityType.EDGE &amp;&amp; SketchObject.YES &amp;&amp; ConstructionObject.NO }
        definition.profiles is Query;

        annotation { "Name" : "Parts", "Filter" : EntityType.BODY }
        definition.parts is Query;

        annotation { "Name" : "Thickness" }
        isLength(definition.thickness, RIB_THICKEN_BOUNDS);

        annotation { "Name" : "Rib extrusion direction" }
        definition.ribExtrusionDirection is RibExtrusionDirection;

        annotation { "Name" : "Opposite direction", "UIHint" : "OPPOSITE_DIRECTION", "Default" : true }
        definition.oppositeDirection is boolean;

        annotation { "Name" : "Extend profiles up to part" }
        definition.extendProfilesUpToPart is boolean;

        annotation { "Name" : "Merge ribs", "Default" : true }
        definition.mergeRibs is boolean;
    }
    {
        const profiles = evaluateQuery(context, definition.profiles);
        const numberOfRibs = size(profiles);
        if (profiles == [])
        {
            throw regenError("Select sketch profiles for the rib contours");
        }

        if (evaluateQuery(context, definition.parts) == [])
        {
            throw regenError("Select parts where the rib will be fitted into");
        }
        
        // Create a transform for making the feature patternable via feature pattern.
        var remainingTransform = getRemainderPatternTransform(context,
                {"references" : qUnion([definition.profiles, definition.parts])});

        // Before evaluating the profiles to create the ribs, we find out how big the parts are
        // so if any extending is necessary for any rib end, we know how far we need to extend.
        // To ensure the extended profile will always go past the part(s), we use the
        // diagonal of the bounding box of the part(s) and profile(s) as the extend length.
        const partBoundingBox = evBox3d(context, {
                    "topology" : qUnion([definition.parts, definition.profiles])
                });
        const extendLength = norm(partBoundingBox.maxCorner - partBoundingBox.minCorner);

        // Create each rib (one rib per profile) as its own body.

        for (var i = 0; i &lt; numberOfRibs; i += 1)
        {
            const profile = profiles[i];
            const thickenId = id + (i ~ "thickenRib");

            try
            {
                // Keep track of the entities we will extrude as a surface which will later
                // be thickened to create the rib.  The profile and any
                // profile extensions will need to be included in the extrude operation.
                var entitiesToExtrude = [profile];

                // Get the endpoints of the profile and the normal direction at those endpoints
                // so we can determine what needs to be extended and what direction to extend.
                const profileEndTangentLines = evEdgeTangentLines(context, {
                            "edge" : profile,
                            "parameters" : [0, 1],
                            "arcLengthParameterization" : false
                        });

                // There  are 2 reasons we might need to extend the given profiles:
                // 1.  If the profile touches the part(s), make an extension of the profile past the part to ensure
                //     that there are no gaps when we thicken the profile (this can happen if the profile is not normal
                //     to the part where they intersect).
                // 2.  The extend profiles up to part checkbox has been selected.
                const partsContainPoint = function(point is Vector) returns boolean
                    {
                        return evaluateQuery(context, qContainsPoint(definition.parts, remainingTransform * point)) != [];
                    };

                var extendProfiles = makeArray(2);
                var extendedEndPoints = makeArray(2);
                const extendDirections = [-profileEndTangentLines[0].direction, profileEndTangentLines[1].direction];

                // If the profile is closed, then there is nothing to extend.
                const isProfileClosed = isClosed(context, profile);

                for (var end in [0, 1]) // Potentially extend both endpoints of the profile curve
                {
                    extendProfiles[end] = !isProfileClosed &amp;&amp; definition.extendProfilesUpToPart || partsContainPoint(profileEndTangentLines[end].origin);
                    if (extendProfiles[end])
                    {
                        extendedEndPoints[end] = profileEndTangentLines[end].origin + (extendDirections[end] * extendLength);
                        // This is actually a quick way to create a line in 3D
                        opFitSpline(context, id + (i ~ "extendProfile" ~ end), {
                                    "points" : [
                                            profileEndTangentLines[end].origin,
                                            extendedEndPoints[end]
                                        ]
                                });
                        entitiesToExtrude = append(entitiesToExtrude, qCreatedBy(id + (i ~ "extendProfile" ~ end), EntityType.EDGE));
                    }
                }

                // Find the direction to extrude a surface that will later be thickened to produce the rib.
                // First determine the normal or parallel direction, then, if specified,
                // choose the opposite of the normal or parallel direction.
                const profilePlane = evOwnerSketchPlane(context, { "entity" : profile });
                var ribDirection;
                if (definition.ribExtrusionDirection == RibExtrusionDirection.PARALLEL_TO_SKETCH_PLANE)
                {
                    // To get the parallel direction with the sketch plane, find the direction perpendicular
                    // to the sketch plane normal and the line that connects the start and end point of the profile.
                    const profileDirection = normalize(profileEndTangentLines[1].origin - profileEndTangentLines[0].origin);
                    ribDirection = cross(profilePlane.normal, profileDirection);
                }
                else
                {
                    ribDirection = profilePlane.normal;
                }

                if (definition.oppositeDirection)
                {
                    ribDirection = ribDirection * -1;
                }

                // Extrude a surface from the extended profile into the part(s), using the extend length
                // as the extrude depth to make sure the surface goes through the part(s).
                opExtrude(context, id + (i ~ "surfaceExtrude"), {
                            "entities" : qUnion(entitiesToExtrude),
                            "direction" : ribDirection,
                            "endDepth" : extendLength,
                            "endBound" : BoundingType.BLIND
                        });

                // Transform the extruded surface if needed to support feature pattern.
                transformResultIfNecessary(context, id + (i ~ "surfaceExtrude"), remainingTransform);

                // Thicken the surface to make the rib plus some excess material around the part(s).
                const halfThickness = definition.thickness / 2;
                opThicken(context, thickenId, {
                            "entities" : qCreatedBy(id + (i ~ "surfaceExtrude"), EntityType.FACE),
                            "thickness1" : halfThickness,
                            "thickness2" : halfThickness
                        });

                // Split the rib with the part(s) to separate the rib body from the thicken excess.
                var ribPartsQuery = qCreatedBy(thickenId, EntityType.BODY);
                opBoolean(context, id + (i ~ "splitOffRibExcess"), {
                            "tools" : definition.parts,
                            "targets" : ribPartsQuery,
                            "operationType" : BooleanOperationType.SUBTRACTION,
                            "keepTools" : true
                        });

                // Apply the remaining transform to the profile before doing collision testing.
                patternTransform(context, id + (i ~ "tr1"), profile, remainingTransform);
                // Do collision testing to help determine which parts of the thicken are excess.
                var clashes = evCollision(context, {
                        "tools" : ribPartsQuery,
                        "targets" : profile
                    });
                    
                // Since we don't want the profile to actually move
                // move it back to it's original location after checking for collisions.
                patternTransform(context, id + (i ~ "tr2"), profile, inverse(remainingTransform));
                var clashBodies = mapArray(clashes, function(clash)
                {
                    return clash.toolBody;
                });

                // Specify a point at the end of the surface extrude.
                // Any thicken body that intersects with this point is excess.
                const surfaceExtrudeEndPoint = profileEndTangentLines[0].origin + (extendLength * ribDirection);

                // Collect up all the thicken excess and any other entities we've created leading
                // up to the thicken operation, because all of these need to be deleted.
                var entitiesToDelete = [
                    // Remove rib thicken excess sections that don't intersect the original profile.
                    qSubtraction(ribPartsQuery, qUnion(clashBodies)),

                    // Remove rib thicken excess sections that extend all the way to the end of
                    // the surface extrude (which we deliberately had extend well past the part,
                    // i.e. well past where a rib should be created).
                    qContainsPoint(ribPartsQuery, remainingTransform * surfaceExtrudeEndPoint),

                    // Remove the surface extrude, now that the thicken is completed and we don't need it anymore.
                    qCreatedBy(id + (i ~ "surfaceExtrude"), EntityType.BODY)
                ];

                // Delete any profile extensions created now that we don't need them anymore.
                // Also, any thicken section that intersects with the far end of an extension
                // (i.e. not the end that intersects with the profile) is thicken excess and should be deleted.
                for (var end in [0, 1])
                {
                    if (extendProfiles[end])
                    {
                        entitiesToDelete = append(entitiesToDelete, qCreatedBy(id + (i ~ "extendProfile" ~ end), EntityType.BODY));
                        entitiesToDelete = append(entitiesToDelete, qContainsPoint(ribPartsQuery, extendedEndPoints[end]));
                    }
                }

                opDeleteBodies(context, id + (i ~ "deleteRibExcess"), {
                            "entities" : qUnion(entitiesToDelete)
                        });
            }
            catch
            {
                throw regenError('Failed to create a rib from a selected profile.',
                        profile);
            }

            // Fail early if the rib body can't be created.
            if (evaluateQuery(context, qCreatedBy(thickenId, EntityType.BODY)) == [])
            {
                throw regenError('Selected profile did not produce a rib body.  Make sure the rib direction and alignment are correct.',
                        profile);
            }
        }

        // Optionally, merge the new ribs with the original parts.
        if (definition.mergeRibs)
        {
            // The original parts are first in the tools query so that they
            // will maintain their names.
            var toMerge = [definition.parts];
            for (var i = 0; i &lt; numberOfRibs; i += 1)
            {
                toMerge = append(toMerge, qCreatedBy(id, EntityType.BODY));
            }

            try
            {
                opBoolean(context, id + "mergeRibsWithParts", {
                            "tools" : qUnion(toMerge),
                            "operationType" : BooleanOperationType.UNION
                        });
            }
            catch
            {
                throw regenError('Failed to merge ribs into parts.');
            }
        }
    },
        {
            oppositeDirection : true,
            ribExtrusionDirection : RibExtrusionDirection.NORMAL_TO_SKETCH_PLANE,
            extendProfilesUpToPart : false,
            mergeRibs : true
        });
        
function patternTransform(context, id, query, transform)
{
    if (transform == identityTransform())
        return;
    opTransform(context, id, {
            "bodies" : qOwnerBody(query),
            "transform" : transform
    });
}
&lt;/pre&gt;
</t>
<t tx="amd.20160531094803.1"></t>
<t tx="amd.20160531095449.1"></t>
<t tx="amd.20160531095458.1">from browser import document, alert
from browser.timer import set_timeout
import browser.html as html
from random import randrange, choice, shuffle, sample
#from time import time

class Board(html.DIV):
    def __init__(self, boardwidth, boardheight, pattern):
        html.DIV.__init__(self, "", style={"position":"absolute", "background-color":"#dc8264", "border":"{0}px solid #820a0a".format(borderwidth)})
        self.boardwidth = boardwidth
        self.boardheight = boardheight
        self.left = innersize*5
        self.top = 0
        self.width = outersize*boardwidth
        self.height = outersize*boardheight
        self.squaredict = {}
        self.poslist = []
        self.currentpos = None
        for pos in pattern:
            p = Position(pos)
            self.poslist.append(p)
            for square in pos:
                self.squaredict[square] = p
            self &lt;= p

class Position(html.DIV):
    def __init__(self, pos):
        html.DIV.__init__(self, "", style={"position":"absolute", "border":"{0}px solid #820a0a".format(borderwidth), "background-color":"inherit"})
        self.orientation = "V" if pos[0][0] == pos[1][0] else "H"
        self.width = innersize if self.orientation == "V" else innersize+outersize
        self.height = innersize+outersize if self.orientation == "V" else innersize
        self.left = outersize*pos[0][0]
        self.top = outersize*pos[0][1]
        self.squares = pos
        self.domino = None

class RowTotals(html.DIV):
    def __init__(self, board):
        html.DIV.__init__(self, "", style={"position":"absolute", "border":"{0}px solid #820a0a".format(borderwidth), "font-size":"{0}px".format(innersize*0.7), "text-align":"center", "line-height":"{0}px".format(innersize)})
        self.left = board.left+board.width+int(innersize/2)
        self.top = board.top
        self.width = outersize*2
        self.height = outersize*board.boardheight
        self.requiredtotals = []
        self.currenttotals = []
        for rowindex in range(board.boardheight):
            t = RequiredTotal("R", rowindex, 17)
            self.requiredtotals.append(t)
            self &lt;= t
            t = CurrentTotal("R", rowindex, 0)
            self.currenttotals.append(t)
            self &lt;= t
        
class ColumnTotals(html.DIV):
    def __init__(self, board):
        html.DIV.__init__(self, "", style={"position":"absolute", "border":"{0}px solid #820a0a".format(borderwidth), "font-size":"{0}px".format(innersize*0.7), "text-align":"center", "line-height":"{0}px".format(innersize)})
        self.left = board.left
        self.top = board.top + board.height + int(innersize/2)
        self.width = outersize*board.boardwidth
        self.height = outersize*2
        self.requiredtotals = []
        self.currenttotals = []
        for colindex in range(board.boardwidth):
            t = RequiredTotal("C", colindex, 17)
            self.requiredtotals.append(t)
            self &lt;= t
            t = CurrentTotal("C", colindex, 0)
            self.currenttotals.append(t)
            self &lt;= t
        
class RequiredTotal(html.DIV):
    def __init__(self, line, index, total):
        html.DIV.__init__(self, "", style={"position":"absolute", "border":"{0}px solid #820a0a".format(borderwidth), "background-color":"limegreen"})
        self.left = outersize*index if line == "C" else outersize
        self.top = outersize*index if line == "R" else outersize
        self.width = self.height = innersize
        self.total = total
        self.text = total
        
class CurrentTotal(html.DIV):
    def __init__(self, line, index, total):
        html.DIV.__init__(self, "", style={"position":"absolute", "border":"{0}px solid #820a0a".format(borderwidth), "background-color":"inherit"})
        self.left = outersize*index if line == "C" else 0
        self.top = outersize*index if line == "R" else 0
        self.width = self.height = innersize
        self.text = total

class Dotpattern(html.DIV):
    def __init__(self, n):
        html.DIV.__init__(self, "", style={"position":"absolute", 'height':"80%", 'width':"40%", "background-color":"#1F1F1F"})
        if n%2 == 1:
            self &lt;= html.DIV(Class="dot", style={'left':"40%", 'top':"40%"})
        if n &gt; 1:
            self &lt;= html.DIV(Class="dot", style={'left':"0%", 'top':"0%"})
            self &lt;= html.DIV(Class="dot", style={'left':"80%", 'top':"80%"})
        if n &gt; 3:
            self &lt;= html.DIV(Class="dot", style={'left':"80%", 'top':"0%"})
            self &lt;= html.DIV(Class="dot", style={'left':"0%", 'top':"80%"})
        if n == 6:
            self &lt;= html.DIV(Class="dot", style={'left':"0%", 'top':"40%"})
            self &lt;= html.DIV(Class="dot", style={'left':"80%", 'top':"40%"})


class Domino(html.DIV):
    def __init__(self, n1, n2):
        html.DIV.__init__(self, "", style={"position":"absolute", "background-color":"black"})
        self.values = (n1, n2)
        self.pos = None
        self.width = innersize+outersize
        self.height = innersize
        dots = Dotpattern(n1)
        dots.style={'left':"5%", 'top':"10%"}
        self &lt;= dots
        dots = Dotpattern(n2)
        dots.style={'left':"55%", 'top':"10%"}
        self &lt;= dots
        self.rotation = 0
        self.bind("mousedown", self.mousedown)
        self.bind("mouseup", self.mouseup)
        self.bind("touchstart", self.mousedown)
        self.bind("touchend", self.mouseup)

    def place(self, pos):
        if pos:
            self.pos = pos
            pos.domino = self
            self.style.transition = "all 0.5s"
            (self.left, self.top) = (game.board.left + self.pos.left + 2*borderwidth, game.board.top + self.pos.top + 2*borderwidth)
            if pos.orientation == "V":
                if self.rotation in [0, 180]: self.setrotation((self.rotation + 90) % 360)
            else:
                if self.rotation in [90, 270]: self.setrotation((self.rotation - 90) % 360)
        else:
            self.pos = None
            self.style.transition = "all 1s"
            (self.left, self.top) = (self.originalleft, self.originaltop)
            self.setrotation(0)
        (self.startleft, self.starttop) = (self.left, self.top)
        self.style.backgroundColor = "black"
        
    def rotate(self):
        self.style.transition = "all 1s"
        self.setrotation((self.rotation + 180) % 360)
        if self.pos:
            (self.left, self.top) = (game.board.left+self.pos.left + 2*borderwidth, game.board.top+self.pos.top + 2*borderwidth)
        else:
            (self.left, self.top) = (self.originalleft, self.originaltop)
        
    def setrotation(self, rotation):
        self.rotation = rotation
        if rotation in [90, 270]:
            self.transform = "translate(-{0}px,{0}px) rotate({1}deg)".format(outersize/2, self.rotation)
        else:
            self.transform = "rotate({0}deg)".format(self.rotation)
        self.style.transform = self.transform
        self.style.webkitTransform = self.transform
        
    def mousedown(self, event):
        global touchevents
        if event.type == "touchstart": touchevents = True
        if touchevents and event.type == "mousedown":
            event.preventDefault()
            event.stopPropagation()
            return
            
        global drag, dragobject, Xdragstart, Ydragstart
        Xdragstart = event.targetTouches[0].clientX if event.type == "touchstart" else event.clientX
        Ydragstart = event.targetTouches[0].clientY if event.type == "touchstart" else event.clientY
        self.style.transition = ""
        document["game"] &lt;= self
        drag = True
        dragobject = self
        event.preventDefault()
        event.stopPropagation()
    
    def mouseup(self, event):
        if touchevents and event.type == "mouseup":
            event.preventDefault()
            event.stopPropagation()
            return

        global drag, dragobject
        if drag:
            drag = False
            dragobject = None
            board = game.board
            currentX = event.changedTouches[0].clientX if event.type == "touchend" else event.clientX
            currentY = event.changedTouches[0].clientY if event.type == "touchend" else event.clientY
            dx = currentX-Xdragstart
            dy = currentY-Ydragstart
            if dx*dx+dy*dy &lt; 25:
                self.rotate()
            else:
                if self.pos: self.pos.domino = None
                if board.currentpos:
                    if board.currentpos.domino: board.currentpos.domino.place(self.pos)
                    board.currentpos.style.backgroundColor = "inherit"
                    self.place(board.currentpos)
                else:
                    self.place(None)
            game.updatetotals()
        event.stopPropagation()

class Game(html.DIV):
    def __init__(self, level):
        html.DIV.__init__(self, "", id="game", style={"position":"relative", "display":"inline-block", "width":12*outersize, "height":"100%", "padding":0})
        self.bind("mousemove",self.mousemove)
        self.bind("mouseup",self.mouseup)
        self.bind("touchmove",self.mousemove)
        self.level = level
        #diffs = rowdiffs[level]
        pattern = patterns[choice(patternnumbers[level])]
        domcount = len(pattern)
        (boardwidth, boardheight) = (4, 3) if domcount == 6 else (5, 4) if domcount == 10 else (6, 4)
            
        self.board = Board(boardwidth, boardheight, pattern)
        self &lt;= self.board
        self.rowtotals = RowTotals(self.board)
        self &lt;= self.rowtotals
        self.coltotals = ColumnTotals(self.board)
        self &lt;= self.coltotals
    
        dotcount = {(i,j):0 for i in range(boardwidth) for j in range(boardheight)}
        """
        direction = "H" if randrange(2) else "V"
        if direction == "H":
            shuffle(list(diffs))
            for rowno, diff in enumerate(diffs):
                for i, spots in enumerate(randomline(boardwidth, diff)):
                    dotcount[(i, rowno)] = spots
        else:
            diffs += "H" if level == 6 else "M"
            shuffle(list(diffs))
            for colno, diff in enumerate(diffs):
                for j, spots in enumerate(randomline(boardheight, diff)):
                    dotcount[(colno, j)] = spots
        """
        extradoms = 1 if domcount == 6 else 2
        hi = True if randrange(2) else False
        (firstdom, lastdom) = mainrange[level]
        if hi: (firstdom, lastdom) = (28-lastdom, 28-firstdom)
        dots = sample(domdots[firstdom:lastdom], domcount-extradoms)
        (firstdom, lastdom) = extrarange[level]
        if hi: (firstdom, lastdom) = (28-lastdom, 28-firstdom)
        dots.extend(sample(domdots[firstdom:lastdom], extradoms))
        shuffle(dots)
        for i in range(domcount):
            j = randrange(2)
            dotcount[pattern[i][0]] = dots[i][j]
            dotcount[pattern[i][1]] = dots[i][1-j]
            
        for rowno in range(boardheight):
            total = sum(dotcount[(i, rowno)] for i in range(boardwidth))
            self.rowtotals.requiredtotals[rowno].total = total
            self.rowtotals.requiredtotals[rowno].text = total
        for colno in range(boardwidth):
            total = sum(dotcount[(colno, j)] for j in range(boardheight))
            self.coltotals.requiredtotals[colno].total = total
            self.coltotals.requiredtotals[colno].text = total
            
        self.dominos = dominos = [Domino(*dotcounts) for dotcounts in dots]
        """
        dominos = []
        for pos in pattern:
            (n1, n2) = (dotcount[pos[0]], dotcount[pos[1]])
            if n1&gt;n2: (n1, n2) = (n2, n1)
            dominos.append(Domino(n1, n2))
        """
        dominos.sort(key = lambda domino: domino.values)
        C = len(dominos)/2
        for (i, d) in enumerate(dominos):
            L, T = divmod(i, C)
            d.originalleft = d.startleft = d.left = (2*outersize+5*borderwidth)*L
            d.originaltop = d.starttop = d.top = (outersize+2*borderwidth)*T
            d.index = i
            self &lt;= d

    def clearboard(self):
        #tt = time()
        for p in self.board.poslist:
            if p.domino:
                p.domino.place(None)
                p.domino = None
        self.updatetotals()
        #print (time() - tt)

    def updatetotals(self):
        (boardwidth, boardheight) = (self.board.boardwidth, self.board.boardheight)
        dotcount = {(i,j):0 for i in range(boardwidth) for j in range(boardheight)}
        winner = True
        for pos in self.board.poslist:
            domino = pos.domino
            if domino:
                for (i, square) in enumerate(pos.squares):
                    dotcount[square] = domino.values[i] if domino.rotation in [0,90] else domino.values[1-i]
            else:
                winner = False

        for rowno in range(boardheight):
            total = sum(dotcount[(i, rowno)] for i in range(boardwidth))
            self.rowtotals.currenttotals[rowno].text = total
            if total == self.rowtotals.requiredtotals[rowno].total:
                self.rowtotals.currenttotals[rowno].style.backgroundColor = "limegreen"
            elif total &gt; self.rowtotals.requiredtotals[rowno].total:
                self.rowtotals.currenttotals[rowno].style.backgroundColor = "red"
                winner = False
            else:
                self.rowtotals.currenttotals[rowno].style.backgroundColor = "inherit"
                winner = False
            
        for colno in range(boardwidth):
            total = sum(dotcount[(colno, j)] for j in range(boardheight))
            self.coltotals.currenttotals[colno].text = total
            if total == self.coltotals.requiredtotals[colno].total:
                self.coltotals.currenttotals[colno].style.backgroundColor = "limegreen"
            elif total &gt; self.coltotals.requiredtotals[colno].total:
                self.coltotals.currenttotals[colno].style.backgroundColor = "red"
                winner = False
            else:
                self.coltotals.currenttotals[colno].style.backgroundColor = "inherit"
                winner = False
        
        if winner:
            set_timeout(showwin, 1500)

    def mousemove(self, event):
        if drag:
            currentX = event.targetTouches[0].clientX if event.type == "touchmove" else event.clientX
            currentY = event.targetTouches[0].clientY if event.type == "touchmove" else event.clientY
            dx = currentX-Xdragstart
            dy = currentY-Ydragstart
            dragobject.left = dragobject.startleft+dx
            dragobject.top = dragobject.starttop+dy
            board = self.board
            (i, j) = ((currentX - board.abs_left)//outersize, (currentY - board.abs_top)//outersize)
            if board.currentpos and (i, j) != board.currentpos:
                board.currentpos.style.backgroundColor = "inherit"
                if board.currentpos.domino: board.currentpos.domino.style.backgroundColor = "black"
            if (i, j) in board.squaredict:
                board.currentpos = board.squaredict[(i,j)]
                board.currentpos.style.backgroundColor = "white"
                if board.currentpos is not dragobject.pos and board.currentpos.domino:
                    board.currentpos.domino.style.transition = ""
                    board.currentpos.domino.style.backgroundColor = "white"
            else:
                board.currentpos = None
            event.preventDefault()
            event.stopPropagation()
        
    def mouseup(self, event):
        global drag, dragobject
        drag = False
        dragobject = None
        event.stopPropagation()

def setupgame(event):
    global game
    document["winner"].style.display = "none"
    del document["game"]
    level = int(document["level"].value)
    game = Game(level)
    document["drawarea"] &lt;= game

def randomline(count, difficulty):
    difficulty += "H" if randrange(2) else "L"
    rlist = choice(alllists[difficulty])
    while len(rlist) &lt; count:
        rlist.append(choice(extralists[difficulty]))
    shuffle(rlist)
    return rlist

def showwin():
    document["rank"].text = levels[game.level]+" Dominator"
    document["winner"].style.display = "block"

def restart(event):
    game.clearboard()

def showrules(event):
    alert(rules)        

rules = """How to play:
Drag the dominos onto the board, arranging them so that the total number of spots in each row and column is equal to the number in the green box.

To rotate a domino, click or tap on it.

To replace a domino, drag another one on top of it.  The dominos will swap places.

To start a new game, choose a different level, or click "New game".

To remove a domino from the board, just drag it anywhere off the board.
To remove all dominos from the board, click "Restart".
"""

touchevents = False
Xdragstart = 0
Ydragstart = 0
drag = False
dragobject = None

patterns = [
[((0,0), (1,0)), ((2,0), (3,0)), ((0,1), (0,2)), ((1,1), (1,2)), ((2,1), (2,2)), ((3,1), (3,2))],
[((0,0), (1,0)), ((2,0), (3,0)), ((0,1), (0,2)), ((1,1), (2,1)), ((1,2), (2,2)), ((3,1), (3,2))],
[((0,0), (1,0)), ((2,2), (3,2)), ((0,1), (0,2)), ((1,1), (1,2)), ((2,0), (2,1)), ((3,0), (3,1))],
[((0,0), (1,0)), ((3,0), (4,0)), ((0,1), (1,1)), ((3,1), (4,1)), ((0,2), (1,2)), ((3,2), (4,2)), ((0,3), (1,3)), ((3,3), (4,3)), ((2,0), (2,1)), ((2,2), (2,3))],
[((0,0), (1,0)), ((0,1), (0,2)), ((1,1), (1,2)), ((0,3), (1,3)), ((3,0), (4,0)), ((3,1), (3,2)), ((4,1), (4,2)), ((3,3), (4,3)), ((2,0), (2,1)), ((2,2), (2,3))],
[((0,0), (1,0)), ((0,1), (1,1)), ((0,2), (0,3)), ((1,2), (1,3)), ((3,0), (3,1)), ((4,0), (4,1)), ((3,2), (4,2)), ((3,3), (4,3)), ((2,0), (2,1)), ((2,2), (2,3))],
[((0,0), (0,1)), ((1,0), (2,0)), ((3,0), (4,0)), ((1,1), (2,1)), ((3,1), (4,1)), ((0,2), (1,2)), ((2,2), (3,2)), ((0,3), (1,3)), ((2,3), (3,3)), ((4,2), (4,3))],
[((0,0), (1,0)), ((0,1), (1,1)), ((0,2), (0,3)), ((1,2), (1,3)), ((2,0), (2,1)), ((3,0), (3,1)), ((2,2), (3,2)), ((2,3), (3,3)), ((4,0), (5,0)), ((4,1), (5,1)), ((4,2), (4,3)), ((5,2), (5,3))],
[((0,0), (1,0)), ((0,1), (0,2)), ((1,1), (1,2)), ((0,3), (1,3)), ((2,0), (2,1)), ((3,0), (3,1)), ((2,2), (2,3)), ((3,2), (3,3)), ((4,0), (5,0)), ((4,1), (4,2)), ((5,1), (5,2)), ((4,3), (5,3))],
[((0,0), (0,1)), ((0,2), (0,3)), ((1,0), (2,0)), ((3,0), (4,0)), ((1,1), (1,2)), ((2,1), (3,1)), ((2,2), (3,2)), ((4,1), (4,2)), ((1,3), (2,3)), ((3,3), (4,3)), ((5,0), (5,1)), ((5,2), (5,3))]
]

domdots = [(0,0),(0,1),(0,2),(1,1),(0,3),(1,2),(0,4),(1,3),(2,2),(0,5),(1,4),(2,3),(0,6),(1,5),(2,4),(3,3),(1,6),(2,5),(3,4),(4,4),(3,5),(2,6),(4,5),(3,6),(5,5),(4,6),(5,6),(6,6)]

mainrange = {1:(0,9), 2:(0,19), 3:(3,25), 4:(0,19), 5:(0,19), 6:(3,25), 7:(0,28), 8:(3,25)}
extrarange = {1:(0,9), 2:(0,19), 3:(3,25), 4:(0,19), 5:(20,28), 6:(0,28), 7:(0,28), 8:(0,28)}


alllists = {
"EL": [ [0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 1, 1] ],
"ML": [ [1, 1, 1], [1, 1, 2], [1, 1, 3], [1, 2, 2] ],
"HL": [ [2, 2, 2], [2, 2, 3], [2, 2, 4], [2, 3, 3], [2, 3, 4] ],
"HH": [ [3, 3, 3], [2, 4, 4], [3, 3, 4], [3, 4, 4], [4, 4, 4] ],
"MH": [ [3, 5, 5], [4, 4, 5], [4, 5, 5], [5, 5, 5] ],
"EH": [ [4, 6, 6], [5, 5, 6], [5, 6, 6], [6, 6, 6] ] }

extralists = {
"EL": [0, 1],
"ML": [0, 1, 2, 3],
"HL": [1, 2, 3, 4, 5, 6],
"HH": [0, 1, 2, 3, 4, 5],
"MH": [3, 4, 5, 6],
"EH": [5, 6] }

rowdiffs = {1:"EEM", 2:"EMM", 3:"MMH", 4:"EMMM", 5:"MMMH", 6:"HHHH"}
levels = {1:"Novice", 2:"Apprentice", 3:"Qualified", 4:"Senior", 5:"Expert", 6:"Master", 7:"Grand Master", 8:"Supreme Master"}
patternnumbers = {1:[0], 2:[1], 3:[2], 4:[3,4], 5:[4,5], 6:[5,6], 7:[7,8], 8:[8,9]}

document['level'] &lt;= (html.OPTION(str(i)+" - "+levels[i], value=i) for i in range(1,9))
document["level"].bind("change",setupgame)
document["startgame"].bind("click",setupgame)
document["restart"].bind("click",restart)
document["showrules"].bind("click",showrules)

(boxwidth, boxheight) = (document["drawarea"].clientWidth, document["drawarea"].clientHeight)
headerheight = document["header"].height
controlsheight = document["controls"].height
innersize = int(min(boxwidth/14, (boxheight-headerheight-controlsheight)/7))
borderwidth = int(innersize/20)
outersize = innersize+2*borderwidth

setupgame(None)</t>
<t tx="amd.20160531120758.1"></t>
<t tx="amd.20160603225335.1">@language md
Title: Virtualbox 的應用與網路設定
Category: MISC
Tags: CADLab, 虛擬機器
Author: kmol
@others

&lt;a href="https://www.virtualbox.org/"&gt;Virtualbox&lt;/a&gt; 是一套能在 Windows, Linux, Mac 與 Solaris 操作系統上使用的虛擬器 (Virtualizer).

&lt;!-- PELICAN_END_SUMMARY --&gt;

##Virtualbox 功能

虛擬器的功能有下列幾點:

1. 在任一操作系統開機後, 可以同時啟動多種虛擬的操作系統平台, 並且透過虛擬硬體的配置與設定, 執行各種老舊的操作系統應用程式 , 畢竟老應用程式不死, 只是慢慢凋零!

2. 以檔案的架構保留各種電腦軟硬體的配置, 可提升軟體開發效能外, 並可在軟體推銷過程避開多次煩雜的設定 (當然 Docker based 的虛擬技術, 已經逐漸超越這種整套操作系統虛擬的應用).

3. 程式開發者可以在虛擬機器中廣泛透過虛擬的硬體配置, 大膽進行各項操作與測試, 無需擔心損毀電腦週邊實體.

4. 在開機的一台電腦實體中, 可同時模擬多台電腦的運作, 省下操作可能消耗的電力, 降低實體運作與硬體維護成本.

Virtualbox 的參考手冊: &lt;a href="https://www.virtualbox.org/manual/"&gt;https://www.virtualbox.org/manual/&lt;/a&gt;

以下將針對 Virtualbox 的網路設定與應用加以說明:

Virtualbox 的網路設定模式分為 NAT, Bridged, Internal, Host-only, UDP tunnel 與 VDE 等.

NAT 使用情境為啟動虛擬機器後, 當作一般客戶端電腦使用, 虛擬機的連網是透過 NAT 轉址, 以 Host 電腦的網路 IP 對外抓取資料.

Bridged 使用情境為啟動虛擬機器後, 當作一般伺服器電腦使用, 在 Host 操作系統中模擬出的虛擬網卡, 可以與 Host 電腦的實體網路卡進行橋接與設定外部 IP 後, 視為網路幹線上的一台伺服器.

Interal 使用情境主要關注在虛擬機器之間的網路彼此相連, 但卻自外於與 Host 連接的區域或廣域網路, Internal networking 的特性通常用來當作資料庫伺服器, 可以透過 internal 網路, 提供對外連線的全球資訊網伺服器資料, 但是外部電腦無法跨越 internal 網路架構直接連線.

Host-only 使用情境則將網路服務的範圍界定在 Host 主機範圍內, 在虛擬機器所啟動的各種服務, 可以讓 Host 連線, 但是因為沒有像 Bridged 網路設置, 與 Host 的實體網路卡進行橋接, 因此 Host-only 的網路環境通常讓操作 Host 的程式設計師將 Host-only 的電腦當作跨網路的虛擬伺服器使用.

UDP tunnel 網路用來串接位於不同 Hosts 的虛擬機器, 而 VDE 則是 Virtual Distributed Ethernet 則是一種虛擬網路基礎架構.

以機械設計的電腦輔助設計應用而言, Virtualbox 網路中的 NAT 與 Host-only 模式最為常用, 而 NAT 網路的設定非常直覺, 只要在所新增的虛擬機器中的網路設定, 選擇 NAT, 然後開機之後, 就可以直接在虛擬機器中使用轉址的網路服務.

##Host-only 虛擬網路設定

Host-only 的網路設置則稍微複雜, 其中牽涉到 Virtualbox 應用程式的網路偏好設定, 以及虛擬機器本身的網路設定搭配, 才能讓 Host 中的應用程式透過 Host 操作系統中的 Host-only 虛擬網路卡, 與位於同一網段的虛擬機器設置連線.

###Virtualbox 網路偏好設定

Virtualbox 的網路相關設定分為兩個層次, 有關整個 Virtualbox 的設定位於 File-&gt;Preferences-&gt;Network, 而第二個層次為各虛擬機器的個別設定. 若以 File-&gt;Preferences-&gt;Network 中, 有關 Host-only 網路設定的目的, 在讓 Virtualbox 的 Host 本體, 可以透過虛擬的網路卡與 Virtualbox 中的虛擬機器網路卡處於同一個區域網路中.

換言之, 如 Host-only 這個名稱本身的所謂 Host only, 就是虛擬機器的網路能見度, 僅止於 Host only, 外部電腦無法與這些虛擬機器連線, 甚至若虛擬機器沒有透過 Host 電腦中的代理主機, 虛擬機器中的瀏覽器也無法連線上網.

至於 File-&gt;Preferences-&gt;Network 中的 Host-only 設定, 總共決定兩件虛擬功能, 其一為位於 Host 中的虛擬網路卡, 要採用的網路協定與網址, 所謂的網路協定就是可以使用 IPV4 或 IPV6 網路協定, 至於虛擬網卡的網址, 就會決定這個所謂的 Host-only 網路, 位於那一個內部網段, 例如, 可以使用 IPV4 協定, 並將虛擬網路卡的網址設為 192.168.56.1, 也就是將 Host-only 的網段設為 192.168.56.0.

File-&gt;Preferences-&gt;Network 中的 Host-only 第 2 個設定, 就是在這個上述設定的虛擬網段中, 是否要再虛擬出一台 DHCP 伺服器, 例如, 選擇要在這個虛擬 Host-only 網段中啟用虛擬的 DHCP 伺服器, 就可以決定這個虛擬的 DHCP 伺服器的 IP (當然要與第 1 項設定的網段相同, 也就是必須位於 192.168.56.0 網段中), 例如, 將虛擬的 DHCP server IP 設為 192.168.56.100, 並且將 DHCP IP 範圍設為 192.168.56.101-200.

儘管 Virtualbox 中的 File-&gt;Preferences-&gt;Network 中的 Host-only 第 2 個設定, 可以啟用 DHCP, 但是通常使用 Host-only 虛擬網路模式的目的, 大多要在 Host 中連接虛擬機器中的伺服器, 使用特定的服務內容, 因此一般都停用 Host-only 網路設定中的虛擬 DHCP server 服務, 而採手動設定虛擬機器中的 IP 與 Gateway.

###虛擬機器的網路設定

例如, 可以將其中第一台使用 Host-only 網路模式的虛擬機器網路 IP 設為 192.168.56.101, 並將 Gateway 設為 192.168.56.1 (也就是 Host 中對應虛擬網卡的 IP 位址), 第 2 台則設可為 192.168.56.102, 依此類推採用固定的 IP 位址來界定虛擬機器所提供的不同服務.

Host-only 虛擬網路相關設定的參考畫面如下:

&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/virtualbox_host_only_1.png" width="800" /&gt;

&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/virtualbox_host_only_2.png" width="800" /&gt;

&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/virtualbox_host_only_3.png" width="800" /&gt;

&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/virtualbox_host_only_4.png" width="800" /&gt;

&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/virtualbox_host_only_5.png" width="800" /&gt;
</t>
<t tx="amd.20160605104719.1">@language md
Title: CADLab 新電腦系統
Category: MISC
Tags: 電腦輔助設計室, 電腦硬體
Author: Cad Lab
@others
CPU 選擇: &lt;span style="background-color: #ffff00;"&gt;Intel i7-6700&lt;/span&gt;

Ram  選擇: &lt;span style="background-color: #ffff00;"&gt;16GB (8GBx2) DDR4-3000 (至少還可再升級 8GBx2)&lt;/span&gt;

HD: &lt;span style="background-color: #ffff00;"&gt;2TB (64MB) SATA III&lt;/span&gt;

Video Card: &lt;span style="background-color: #ffff00;"&gt;NVIDIA GEFORCE GTX950 2GB GDDR5&lt;/span&gt;

NIC: &lt;span style="background-color: #ffff00;"&gt;1Gbits/s*5 (除了主機板上的兩片網路卡之外 ,再加上 3 片外接式網路卡, 以便與各開機磁區中的虛擬機橋接出虛擬的多台連外伺服器)&lt;/span&gt;

參考:

i7: &lt;a href="https://en.wikipedia.org/wiki/List_of_Intel_Core_i7_microprocessors"&gt;https://en.wikipedia.org/wiki/List_of_Intel_Core_i7_microprocessors&lt;/a&gt;

i7-6700: &lt;a href="http://ark.intel.com/products/88196"&gt;http://ark.intel.com/products/88196&lt;/a&gt;
</t>
<t tx="amd.20160605104725.1"></t>
<t tx="amd.20160605104803.1">@language md
Title: 電腦輔助設計室電腦磁區規劃
Category: MISC
Tags: 電腦輔助設計室, 電腦硬體
Author: Cad Lab
@others
&lt;div&gt;希望能根據不同性質課程, 將軟體分為 3 個開機磁區:&lt;/div&gt;
 
&lt;ol&gt;
 	&lt;li&gt;安裝所有老師提出的上課套件, 集中在第 1 磁區, 其中包括 CAD, CAE, CAM, 數值分析與自動控制相關所有套件.&lt;/li&gt;
 	&lt;li&gt;只安裝 Solidworks, PTC Creo, AutoDesk Inventor, AutoCAD, A360, Ansys, Comsol, Matlab 與 Mathematica, 等 CAD, CAE 與數值分析相關套件.&lt;/li&gt;
 	&lt;li&gt;只安裝操作系統, 加上無需安裝的綠色套件 (PTC, Creo, Comsol, Matlab 等).&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;

&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;/div&gt;
&lt;div&gt;至於以上 3 個開機磁區則傾向將新購買的 Windows 10 Pro 操作系統降為 Windows 7 Pro, 以提升使用效能. 但是仍然在第 2 磁區利用 Virtualbox 建立安裝 Windows 10 Pro 的兩台虛擬機器, 其中一台虛擬機配合安裝 Solidworks, PTC Creo, AutoDesk Inventor 與 Matlab , 而另一台虛擬機也採用 Windows 10 Pro 開機, 但只配置各軟體的原始 DVD, 可以讓老師教導學生執行各套件安裝與設定的教學.&lt;/div&gt;
 
&lt;div&gt;至於第 3 磁區則將利用 Virtualbox 建立一台配置&lt;a href="http://www.squid-cache.org/"&gt;網路代理功能&lt;/a&gt; (IPV4/IPV6 雙支援) 的 Ubuntu Server 虛擬伺服器, 以及一台空白的 Windows 10 Pro 虛擬機, 以便在純 IPV6 環境下進行課程教學.&lt;/div&gt;
 
&lt;div&gt;註解:&lt;/div&gt;
根據 &lt;a href="https://en.wikipedia.org/wiki/X86_virtualization#Intel-VT-x"&gt;https://en.wikipedia.org/wiki/X86_virtualization#Intel-VT-x&lt;/a&gt; 與 &lt;a href="https://en.wikipedia.org/wiki/List_of_Intel_Core_i7_microprocessors"&gt;https://en.wikipedia.org/wiki/List_of_Intel_Core_i7_microprocessors&lt;/a&gt; 的說明, 幾乎所有的 Intel CPU 都已經支援 VT-x 虛擬技術, 只要電腦的其他軟硬體配合啟動 VT-x, 就可以在 64 位元的操作系統主體, 模擬 64 位元的虛擬機, 假如再配合 Oracle 的新聞稿: &lt;a href="http://www.oracle.com/us/corporate/press/1842885"&gt;http://www.oracle.com/us/corporate/press/1842885&lt;/a&gt; 說明, Virtualbox 中的一台虛擬機 (Virtual Machine) 最多可以啟用 36 片虛擬網路卡, 因此只要電腦主體的硬體支援許可, 利用虛擬機就能有效模擬出相當複雜的網路伺服器架構.

&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/virtualbox5_upto_36_NIC.png" width="800" /&gt;
</t>
<t tx="amd.20160605104803.2"></t>
<t tx="amd.20160605111320.1"></t>
<t tx="amd.20160605111404.1"></t>
<t tx="amd.20160608105837.1">@language md
Title: Onshape Featurescript Tutorial 導引
Category: MISC
Tags: Onshape, FeatureScript
Author: Cad Lab
@others
Onshape 配合公開 FeatureScript 特徵程式語言的過程, 特別製作了一個詳細的教學導引:&lt;a href="https://cad.onshape.com/FsDoc/tutorials/create-a-slot-feature.html"&gt;https://cad.onshape.com/FsDoc/tutorials/create-a-slot-feature.html&lt;/a&gt;, 從這個導引中, 可以一窺 FeatureScript 的基本用法.

&lt;!-- PELICAN_END_SUMMARY --&gt;

左下角所謂的頁面創建功能 (也就是 + 號所在), 增加了創建 Feature Studio (特徵工房) 的選項, 可以讓使用者利用特徵工房中的 IDE (Integrated Development Environment) 環境, 開發獨特的客製化特徵程式.

所以 Feature Studio 是 Onshape 的一種特殊頁面 (Tab), 其中提供編修 FeatureScript 程式的各種工具.

進入 Feature Studio 後, 通常第一件事就是按下 New Feature 按鈕, 可以在特徵程式編輯區 (採用 &lt;a href="https://github.com/ajaxorg/ace"&gt;Ace.js&lt;/a&gt;) 中帶出 FeatureScript 程式的 Template codes (程式模版). 程式模版中包含所導入的 FeatureScript 程式庫版本, 以及即將讓使用者定義的客製化特徵函式區, 模版程式如下:

&lt;pre class="brush: jscript"&gt;
// 宣告所使用的 FeatureScript 版次
FeatureScript 355;
// 配合所使用的 FeatureScript 版次, 導入 geometry 標準程式庫
import(path : "onshape/std/geometry.fs", version : "355.0");

// 利用 New Feature 所產生的程式模版, 包含 annotation 與 myFeature 常數的 export
// 其中使用了匿名函式的立即實例化, 使用者負責填入此一匿名函式的 precondition 與函式內容
// precondition 區主要在設定 FeatureScript 的 GUI 介面, 而函式內容則可實際產生各式特徵操作
annotation { "Feature Type Name" : "My Feature" }
export const myFeature = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        // 特徵程式的使用者介面對話設計, 包括輸入表單, 各式選單以及使用者動態選擇的各種幾何特徵
    }
    {
        // 定義函式的幾何操作內容
    });
&lt;/pre&gt;

在 precondition 的大括號中間, 以鍵盤輸入 qu, FeatureScript Studio 就會啟動 Autocompletion 功能, 列出可以選用的 Query 設定, 並且列出詳細的使用說明, 其中的 Query parameter 是 snippet 小程式段外, 其餘都是查詢函式.

Query parameter 的程式段如下:

&lt;pre class="brush: jscript"&gt;
annotation { "Name" : "My Query", "Filter" : EntityType.FACE, "MaxNumberOfPicks" : 1 }
definition.myQuery is Query;
&lt;/pre&gt;

當使用者在 precondition 對話區建立兩個查詢變數後, 就可以提交 (commit) 所增加的 FeatureScript 程式, 提交程式的目的在讓其他的頁面 (Tabs) 可以使用此一特徵程式. 另外假如 Feature Studio 中有新增資料尚未提交, 頁面上的特徵程式名稱前面會多一個 * 號, 一旦提交後, 此一 * 符號就會消失, 表示所有新增或編修的 FeatureScript 程式都已經提交到 Document 的模型本體.

FeatureScript 語法中的 annotation 資料型別為 map, 類似 Python 的 Dictionary 資料型別, 且 map 的 key 一律為字串, 以 slot 程式範例而言, annotation { "Feature Type Name" : "Slot" } 中的 "Feature Type Name" 為每一個特徵函式的必要字串鍵值, 這裡的對應名稱為 "slot".

從導引影片的操作, 也可以看到當使用者利用某一個平面草圖執行擠出後, 原先的草圖將會內定隱藏, 但隨後將需要選擇此一草圖上的其他線段, 因此必須在特徵瀏覽視窗中, 將此草圖顯示出來.

另外, 當使用者在設計 FeatureScript 程式的 Query 對話區表單時, 可以透過 "Filter" 字串鍵進行控制可選的幾何元素, 例如, "Slot path" 對應的 "Filter" 為 EntityType.EDGE, 表示只能選擇 EDGE 幾何元件, 且透過 "MaxNumberOfPicks", 限定只能選擇一個 EDGE.
"Part to cut" 的 Query 則以 EntityType.BODY &amp;&amp; BodyType.SOLID 界定, 表示只能選擇 SOLID BODY.

其次, FeatureScript 的所有尺寸, 角度與重量變數, 都隨使用者所選擇的單位而自動換算, 而且支援不同單位的&lt;a href="https://cad.onshape.com/FsDoc/intro.html"&gt;混合運算&lt;/a&gt;, 因此除了在互動區設定的 definition.variable_name 會根據 Onshape Document 中的單位為準外, 其他在函式定義過程中新增的其他變數, 必須自行加註單位, 否則會產生具單位尺寸與無單位設定的變數運算的錯誤.

接下來, 當使用者開始進入函式內容的幾何模型操作時, 就必須對 id 型別有些認識. 模型主體 (Context) 中的所有特徵, 子特徵與操作, 都配置獨特的 id 加以辨識. 獨特的 id 可以在查詢, 錯誤回報或者取用特徵或操作時有所依據. id 的標示依照模型本體中各特徵與操作的關係, 以從屬架構表示. 也就是說 ,每一個操作項目的 id 都有其上層對應項目的 id. 過程中可以利用 newId() 函式來產生根項目 id, 隨後的子 id 則利用 + 運算子進行附加.

在 Onshape FeatureScript 手冊中舉例, id + "foo" 中的 "foo" 就是子項目的 id 名稱, 而其父項目就是 id 變數. 依此類推, id + "foo" + "bar" 的就是以 "bar" 作為子項目的 id, 而其父項目的 id 就是 id + "foo". 而且在 FeatureScript 中 id 的資料型別為陣列, 其算元素為字串, 可以經過陣列元素表示各項目的路徑. 

例如, newId() + "foo" + "bar" 等同 id 值為 ["foo", "bar"], 但是實際操作仍以前面的用法為主.

slot 教學導引的後段操作, 接續在互動介面區所設定的兩個 Query 與一個 Parameter 輸入, Query1 是選擇 "Slot path", 並將選擇與 definition.slotPath 變數對應, Query2 則選擇 "Part to cut", 以 definition.partToCut 表示, 而切槽的寬度則由使用者在欄位中輸入, 以 definition.width 變數表示.

接下來, 則以 definition.slotPath 透過 opExtrude 操作長出橫貫 "Part to cut" 本體的平面, 接著利用 opThicken 操作, 對用來切槽的平面增加厚度, 而且一旦平面加厚成為實體之後, 就利用 opDeleteBodies 操作, 將此平面刪除, 最後的操作則是利用 opBoolean 操作, 以增厚的平面實體對 "Part to cut" 進行除料, 就完成 slot 客製 FeatureScript 程式的製作.

slot FeatureScript 程式碼如下:

&lt;pre class="brush: jscript"&gt;
FeatureScript 355;
import(path : "onshape/std/geometry.fs", version : "355.0");

annotation { "Feature Type Name" : "Slot" }
export const slot = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        // Query for EDGE entity
        annotation { "Name" : "Slot path", "Filter" : EntityType.EDGE, "MaxNumberOfPicks" : 1 }
        definition.slotPath is Query;
        // Query for Body entity
        annotation { "Name" : "Part to cut", "Filter" : EntityType.BODY &amp;&amp; BodyType.SOLID, "MaxNumberOfPicks" : 1 }
        definition.partToCut is Query;
        // parameter input field for width
        annotation { "Name" : "Width" }
        isLength(definition.width, LENGTH_BOUNDS);
    }
    {
        // Extrude operation, id is extrude1
        opExtrude(context, id + "extrude1", {
               "entities" : definition.slotPath,
               "direction" : evOwnerSketchPlane(context, {"entity" : definition.slotPath}).normal,
               "endBound" : BoundingType.THROUGH_ALL,
               "startBound" : BoundingType.THROUGH_ALL
        });
        
        // Thicken operation for extrude1 entity
        opThicken(context, id + "thicken1", {
               "entities" : qCreatedBy(id + "extrude1", EntityType.BODY),
               "thickness1" : definition.width / 2,
               "thickness2" : definition.width / 2
        });
        
        // DeleteBodies operation to delete extrude1
        opDeleteBodies(context, id + "delete1", {
               "entities" : qCreatedBy(id + "extrude1", EntityType.BODY)
        });

        // Boolean operation to subtract the thicken1 from partToCut part
        opBoolean(context, id + "boolean1", {
               "tools" : qCreatedBy(id + "thicken1", EntityType.BODY),
               "targets" : definition.partToCut,
               "operationType" : BooleanOperationType.SUBTRACTION
        });

    });
&lt;/pre&gt;

有了 slot 操作基礎後, 就可以進一步完成繪製齒輪與鏈輪輪廓的程式模版:

&lt;pre class="brush: jscript"&gt;
FeatureScript 355;
import(path : "onshape/std/geometry.fs", version : "355.0");
 
annotation { "Feature Type Name" : "Gear test" }
export const gearTest = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        // 圓半徑直接輸入表單為 radius 的欄位中
        annotation { "Name" : "radius" }
        isLength(definition.radius, LENGTH_BOUNDS);
        // 在 Select a point 輸入區為查詢, 只能選擇既有的 VERTEX, 且只選一個點
        annotation { "Name" : "Select a point", "Filter" : EntityType.VERTEX, "MaxNumberOfPicks" : 1 }
        definition.point is Query;
    }
    {
        // Precondition 中的查詢, 需要 evalue 才能傳回對應的 entity
        var location = evaluateQuery(context, definition.point)[0];
        // location 變數為點座標對應的 entity, 必須透過 evVetexPoint 的評量才能傳回對應的點座標
        var center3D = evVertexPoint(context, {
                "vertex" : location
        });
 
        // 作圖面利用 evOwnerSketch 評量, 與 location entity 同一個平面
        var sketchPlane = evOwnerSketchPlane(context, {
                "entity" : location
        });
        // 利用 worldToPlane, 將 center3D 轉換為 sketchPlane 上的平面點座標
        const center2D = worldToPlane(sketchPlane, center3D);
        // 接下來利用 sketchPlane 建立一個草圖畫布元件
        const gearSketch = newSketchOnPlane(context, id + "gearSketch", {
                "sketchPlane" : sketchPlane
        });
   
        // 有了草圖畫布元件, 就可以在其上進行各式平面繪圖, 這裡利用 center2D 點作為圓心, definition.radius 作為半徑畫圓
        skCircle(gearSketch, "circle1", {
                "center" : center2D,
                "radius" : definition.radius
        });
        
        // 接著從圓心, 沿 x 軸方向畫一條長度為半徑的直線
        skLineSegment(gearSketch, "line1", {
                "start" : center2D,
                "end" : center2D + vector(1, 0) * definition.radius
        });
        
        // 這裡使用固定點在畫布上繪製平滑曲線, 之後可以直接用來繪製各種齒輪或鏈輪輪廓
        skFitSpline(gearSketch, "spline1", {
                "points" : [
                    vector( 0,  0) * inch,
                    vector( 0, -1) * inch,
                    vector( 1,  1) * inch,
                    vector(-1,  0) * inch,
                    vector( 0,  0) * inch
                ]
        });
         
        // 利用 skSolve 解出畫布上的所有繪圖內容, 並顯示出來
        skSolve(gearSketch);
    });
&lt;/pre&gt;



</t>
<t tx="amd.20160614093804.1">@language md
Title: 電腦輔助設計室相關區域網路設定
Category: MISC
Tags: 電腦輔助設計室, IPV6, IPV4
Author: Cad Lab
@others
今天早上發現一台 Asus 電腦, 裝了 IIS 8 的伺服器佔用了 17.9 的 IPV4 網路位址, 導致原先配置的 Ubuntu 16.04 代理主機無法正常連線.

&lt;!-- PELICAN_END_SUMMARY --&gt;

其實自從 2012 年起台灣就已經逐步完善 IPV6 的網路環境, 而且各種最新的操作系統也都已經提供 IPV6 相關協定的支援, 但是許多用戶仍然只用 IPV4 協定, 而且無論是客戶端或伺服器端, 一律搶佔已經不敷分配的 IPV4 網路位址.

當然, 電腦輔助設計室周遭相關的區域網路, 目前只有兩種伺服器非採用 IPV4 協定不可, 一種是各式 CAD/CAE/CAM/PLM 軟體的網路認証主機, 一種則是同時支援 IPV4/IPV6 的 Proxy Servers.

各式 CAD/CAE/CAM/PLM 軟體的網路認証主機, 早就已經支援 IPV6, 因此採用 IPV6 協定設置的認証主機, 可以服務純 IPV6 的客戶端, 但是仍然有許多的客戶端仍然使用純 IPV4 協定上網, 因此這些客戶端除非採用內部虛擬主機的自我認証, 否則仍然必須採用 IPV4 協定, 連接到區域或廣域網路上的認証伺服器.

在台灣教育界有一個非常有趣的現象, 假如用戶堅持要使用合法購買的各式 CAD/CAE/CAM/PLM 軟體, 負責管理的團隊就必須花錢買罪受, 肩負多元合法軟體的認証伺服器的管理, 而且大部份負責代理這些軟體套件的公司, 都希望將網路認証授權綁在特定的封閉區域網路上, 一來, 可以多賣些套數, 二來也能避開紛擾較多的廣域網路認証主機的管理工作.

上面提到佔用合法 IP 位址的電腦, 網卡的硬體位址以 9c:5c:8e 開頭, 這個網卡從 &lt;a href="http://aruljohn.com/mac/9C5C8E"&gt;http://aruljohn.com/mac/9C5C8E&lt;/a&gt; 就可以得知來自 Asus, 因此合理的推論, 是一台 Asus 的伺服器, 並且從 http 連線可以看到 IIS 8, 因此應該是安裝 MS 2012 Server 以上的伺服操作系統. 並且從已經開啟的 3389 埠號, 也可以確定 Remote Desktop 已經啟用, 並且允許廣域網路上的任何主機連線. 比較特殊的是沒有任何的 https 埠號啟用, 因此假如這台伺服器提供任何需要使用者輸入帳號密碼的應用, 這些帳號密碼已經透過明碼傳遞曝露在區域網路的封包中.

其實, 上述合法 IPV4 位址被搶佔的問題, 早就可以透過 MAC 綁定 IPV4 的方案解決, 但是因為電腦輔助設計室中的伺服器數量超過 30 台, 許多伺服器的任務多元, 且經常更換, 因此自 2015 年秋季開始, 已經透過校方建置的雲端虛擬主機逐步取代實體主機, 而且部份上課的網路連線也將採純 IPV6 設定上網, 一旦各 Proxy Server 的任務確定, 就可以將伺服器 MAC 位址與 IPV4 位址綁定, 上述的網址佔用問題就不會存在.

接下來, 看一下有關電腦輔助設計室相關區域網路的 IPV6 網路設定, 虎尾科技大學機械設計工程系的 IPV6 網址區段為 2001:288:6004:17, 路由器的通道為 2001:288:6004:17::254, 而校方的 DNS 為 2001:288:6004:1::2, 中華電信的 DNS 則為 2001:b000:168::1, 因此使用者要設定 IPV6 網路連線, 只需要知道自己電腦所配置的網段即可.

從 IPV6 的網路定址格式, 機械設計工程系可用網段為 2001:288:6004:17:0000:0000:0000:0000 ~ 2001:288:6004:17:FFFF:FFFF:FFFF:FFFF, 總共可配置 IPV6 總數為 16^16 = 1.8446744e+19, 可以透過教師編號 (例如為 3001), 將則其所屬的學生與實習研究室 IPV6 分配網段為 2001:288:6004:17:3001:0000:0000:0000 ~ 2001:288:6004:17:3001:FFFF:FFFF:FFFF (可配置位址總數為 16^12 = 2.8147498e+14), 且將 2001:288:6004:17:0000:0000:0000:0000 ~ 2001:288:6004:17:0000:0000:0000:FFFF 保留給電腦輔助設計室與工作站室相關主機使用 (可配置 IPV6 位址總數為 16^4 = 65536), 而行政管理相關的 IPV6 網段則使用 2001:288:6004:17:168:0000:0000:0000 ~ 2001:288:6004:17:168:FFFF:FFFF:FFFF (可配置位址總數為 16^12 = 2.8147498e+14).

之後, 將要利用回收的 20 個 IPV4 網址來配置同時支援 IPV4/IPV6 的 Proxy Server, 並且利用雙協定支援的 DNS 來配置這些伺服器, 遙望 IPV6 的世界, 應該再沒有 IPV6 網址短缺的機會了!

</t>
<t tx="amd.20160614172648.1">@language md
Title: Onshape Featurescript Spur Gear 輪廓繪圖
Category: MISC
Tags: Onshape, FeatureScript
Author: Cad Lab
@others
學習 Onshape 可以從 614 頁的 pdf 格式導引手冊: &lt;a href="https://cad.onshape.com/help/PDF/Onshape.pdf"&gt;https://cad.onshape.com/help/PDF/Onshape.pdf&lt;/a&gt; 下手, 在手動操作逐漸熟悉之後, 就可以透過下列的 FeatureScript 程式客製化理想中的各種零件, 這裡先來看看漸開線正齒輪輪廓繪圖, 有關齒輪的參考資料, 請參閱 &lt;a href="http://khkgears.net/gear-knowledge/"&gt;http://khkgears.net/gear-knowledge/&lt;/a&gt;.

&lt;!-- PELICAN_END_SUMMARY --&gt;

從 &lt;a href="http://chiamingyen.github.io/kmolab/blog/ji-jie-she-ji-gong-cheng-shi-de-she-ji-mo-ni-yu-shi-zuo.html"&gt;機械設計工程師的設計模擬與實作&lt;/a&gt; 文章中, 可以看到利用 Brython 直接在網際畫布上以小段直線繪製漸開線正齒輪輪廓的程式原始碼. 類似的正齒輪繪圖可以參考 &lt;a href="http://web.mit.edu/harishm/www/papers/involuteEWC.pdf"&gt;Approximation of Involute Curves for CAD-System Processing&lt;/a&gt; 論文中的說明, 完成 &lt;a href="http://www.arc.id.au/GearDrawing.html"&gt;靜態與動態的漸開線正齒輪繪圖與模擬&lt;/a&gt; .

以下主要以教導 FeatureScript 為目的, 依據下列圖示作為參考:

&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/spur_gear_dimension_4.png" width="800" /&gt;

假設齒數為 n, 模數為 m, 壓力角為 pa, 則正齒輪的節圓半徑為 $rp = m*n/2$, 且基圓半徑 $rb = rp*cos(pa)$, 假設齒根 $d = 2.5*rp/n$, 齒頂圓半徑 $ra = rp + m$, 齒根圓半徑 $rd = rp - d$, 接著當齒數 n 小於 $2.5/(1-cos(pa))$ 時就能夠從基圓開始繪製漸開線到齒頂圓, 若 n 大於 $2.5/(1-cos(pa))$, 則漸開線必須從齒根圓畫起, 而不是從基圓畫起 (因為基圓半徑已經小於齒根圓半徑). 有關這一點, Onshape 官方釋出的漸開線&lt;a href="https://cad.onshape.com/documents/57494152e4b05f50e871a72c/w/a4a3f09939bf1f43a8e4f133/e/2b865798923d6f648f7196f9"&gt;正齒輪繪圖 FeatureScript 程式第1版&lt;/a&gt;也未能納入考量, 因此當選擇壓力角 20 度時, 若齒數超過 43 齒, 或者選擇壓力角 15.5 度, 當齒數超過 70 齒, 正齒輪的輪廓就會出錯. 之後當以下的練習完成後, 就可以將漸開線納入 spline 中, 並且加上齒輪底部的導倒圓角後, 就能夠修正上述的錯誤.

以下為 17 齒, 模數 20 mm, 壓力角 20 度的漸開線正齒輪輪廓繪圖:

&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/onshape_spur_gear1.png" width="800" /&gt;

以下為 170 齒, 模數 20 mm, 壓力角 20 度的漸開線正齒輪輪廓繪圖:

&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/onshape_spur_gear2.png" width="800" /&gt;

以下為對應的 FeatureScript 正齒輪輪廓繪圖程式碼:

&lt;pre class="brush: jscript"&gt;
FeatureScript 355;
import(path : "onshape/std/geometry.fs", version : "355.0");

annotation { "Feature Type Name" : "Spur2" }
export const spur = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        // 正齒輪齒數, 由使用者輸入, 型別為整數
        annotation { "Name" : "Number of Gear Tooth" }
        isInteger(definition.n, POSITIVE_COUNT_BOUNDS);
        // 正齒輪模數, 由使用者輸入, 型別為長度, 為內建尺寸單位
        annotation { "Name" : "Module" }
        isLength(definition.module, LENGTH_BOUNDS);
        // 正齒輪壓力角, 由使用者輸入, 型別為角度, 為內建角度單位
        annotation { "Name" : "Pressure Angle" }
        isAngle(definition.pa, ANGLE_360_BOUNDS);
        // 正齒輪圓心座標點, 由使用者選擇
        annotation { "Name" : "Select a point", "Filter" : EntityType.VERTEX, "MaxNumberOfPicks" : 1 }
        definition.point is Query;
    }
    {
        // Precondition 中的查詢, 需要 evalue 才能傳回對應的 entity
        var location = evaluateQuery(context, definition.point)[0];
        // location 變數為點座標對應的 entity, 必須透過 evVetexPoint 的評量才能傳回對應的點座標
        var center3D = evVertexPoint(context, {
                "vertex" : location
        });
 
        // 作圖平面利用 evOwnerSketch 評量, 與 location entity 同一個平面
        var sketchPlane = evOwnerSketchPlane(context, {
                "entity" : location
        });
        // 作圖畫
        const gearSketch = newSketchOnPlane(context, id + "gearSketch", {
                "sketchPlane" : sketchPlane
        });
        // 利用 worldToPlane, 將 center3D 轉換為 sketchPlane 上的平面點座標
        const center2D = worldToPlane(sketchPlane, center3D);
        //print(center2D);
        // 漸開線近似點數
        var imax = 5;
        // 使用者所選的齒輪圓心 x 座標
        var midx = center2D[0];
        // 使用者所選的齒輪圓心 y 座標
        var midy = center2D[1];
        // 齒數
        var n = definition.n;
        // 模數
        var m = definition.module;
        // 壓力角, 單位為角度
        var pa = definition.pa;
        // 齒輪的節圓半徑
        var rp = m*n/2;
        skLineSegment(gearSketch, "line", {
        "start" : vector(midx,midy),
        "end" : vector(midx,midy+rp)
        });
        // 齒根
        var d = 2.5*rp/n;
        // 齒頂圓半徑
        var ra = rp + m;
        // 基圓半徑
        var rb = rp*cos(pa);
        //print(rb);
        // 齒根圓半徑
        var rd = rp - d;
        // 分段後齒頂與齒根半徑差增量
        var dr = 0*meter;
        // 若 rb &amp;gt; rd 時從基圓開始繪製漸開線, 但是若 rd &amp;gt; rb, 則漸開線從 rd 畫到齒頂圓
        if (rd &amp;gt; rb)
        {
            // 半徑差的分段, 由齒根圓到齒頂圓
            dr = (ra-rd)/imax;
        }
        else
        {
            // 半徑差的分段, 由基圓到齒頂圓
            dr = (ra-rb)/imax;
        }
        // PI 為實數值沒有單位, tan(pa)也沒有單位, pa 已經設定單位為 degree, 這裡為了與 radian 運算
        // 系統會自動轉為 radian
        var rot = PI/(2*n)*radian;
        //print(sigma);
        // 分別用來設定 entity id 用的增量變數
        var nameId = 1;
        var nameId2 = 1;
        var r = 0*meter;
        // theta 為浮點數字
        var theta = 0;
        var inv = 0*radian;
        var inc = 0*radian;
        // 當 r=rp 時 ,計算 inv_rp 用來旋轉漸開線用
        // theta 為沒有單位的實數
        theta = sqrt((rp*rp)/(rb*rb)-1);
        // atan(theta) 為 radian
        var inv_rp = theta*radian-atan(theta);
        // 漸開線上點的 x 座標
        var xpt = 0*meter;
        // 漸開線上點的 y 座標
        var ypt = 0*meter;
        // 左側漸開線第1點座標 left first x and y
        var lfx = 0*meter;
        var lfy = 0*meter;
        // 右側漸開線第1點座標 right first x and y
        var rfx = 0*meter;
        var rfy = 0*meter;
        // 左側齒根圓上點座標 left x of dedendum point
        var lxd = 0*meter;
        var lyd = 0*meter;
        // 右側齒根圓上點座標 right x of dedendum point
        var rxd = 0*meter;
        var ryd = 0*meter;
        // 左側齒根圓上點座標 right x of dedendum point (advanced)
        var lxd_ad = 0*meter;
        var lyd_ad = 0*meter;
        var inc_ad = 0*radian;
        for (var j=0;j&amp;lt;n;j+=1)
        {
            // 當 j 增量時, 按照齒數輪廓繞行旋轉增量角度
            inc = (2.*j*PI/n)*radian;
            inc_ad = (2.*(j+1)*PI/n)*radian;
            if (rd&amp;gt;rb)
            {
                // 當齒根半徑因為齒數增多後大於基圓半徑時, 漸開線從齒根圓長起
                theta = sqrt((rd*rd)/(rb*rb)-1.);
                inv = theta*radian-atan(theta);
                // 左側漸開線第1點座標
                // 左側輪廓線配合逆時針旋轉 inc 角度
                lfx = midx+rd*sin(inv-rot-inv_rp+inc);
                lfy = midy+rd*cos(inv-rot-inv_rp+inc);
                lxd = lfx;
                lyd = lfy;
                lxd_ad = midx+rd*sin(inv-rot-inv_rp+inc_ad);
                lyd_ad = midy+rd*cos(inv-rot-inv_rp+inc_ad);
                // 右側漸開線第1點座標
                // 右側輪廓線配合順時針旋轉 inc 角度
                rfx = midx-rd*sin(inv-rot-inv_rp-inc);
                rfy = midy+rd*cos(inv-rot-inv_rp-inc);
                rxd = rfx;
                ryd = rfy;
                // 齒根圓上的直線 on dedendum points
                skLineSegment(gearSketch, "line_dd" ~ nameId, {
                "start" : vector(rxd,ryd),
                "end" : vector((lxd_ad),(lyd_ad))
                });
            }
            else
            {
                // 當基圓半徑大於齒根圓時, 漸開線從基圓長起
                theta = sqrt((rb*rb)/(rb*rb)-1.);
                inv = theta*radian-atan(theta);
                // 左側漸開線第1點座標
                lfx = midx+rb*sin(inv-rot-inv_rp+inc);
                lfy = midy+rb*cos(inv-rot-inv_rp+inc);
                lxd = midx+rd*sin(inv-rot-inv_rp+inc);
                lyd = midy+rd*cos(inv-rot-inv_rp+inc);
                lxd_ad = midx+rd*sin(inv-rot-inv_rp+inc_ad);
                lyd_ad = midy+rd*cos(inv-rot-inv_rp+inc_ad);
                // 從基圓點到齒根圓點, 畫直線 left from base point to dedendum point
                skLineSegment(gearSketch, "line_lbd" ~ nameId, {
                "start" : vector(lfx,lfy),
                "end" : vector((lxd),(lyd))
                });
                // 右側漸開線第1點座標
                rfx = midx-rb*sin(inv-rot-inv_rp-inc);
                rfy = midy+rb*cos(inv-rot-inv_rp-inc);
                rxd = midx-rd*sin(inv-rot-inv_rp-inc);
                ryd = midy+rd*cos(inv-rot-inv_rp-inc);
                // 從基圓點到齒根圓點, 畫直線 right from base point to dedendum point
                skLineSegment(gearSketch, "line_rbd" ~ nameId, {
                "start" : vector(rfx,rfy),
                "end" : vector((rxd),(ryd))
                });
                // 齒根圓上的直線 on dedendum points
                skLineSegment(gearSketch, "line_dd" ~ nameId, {
                "start" : vector(rxd,ryd),
                "end" : vector((lxd_ad),(lyd_ad))
                });
            }

            for (var i=1; i&amp;lt;imax+1; i+= 1)
            {
                // 先處理中線左側的漸開線
                // 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if (rd&amp;gt;rb)
                {
                    r = rd+i*dr;
                }
                else
                {
                    r = rb+i*dr;
                }
                theta = sqrt((r*r)/(rb*rb)-1);
                var inv = theta*radian-atan(theta);
                // 漸開線上的點座標
                xpt = midx+r*sin(inv-rot-inv_rp+inc);
                ypt = midy+r*cos(inv-rot-inv_rp+inc);
                // lxd, lyd 為漸開線上的繪線起點座標
                skLineSegment(gearSketch, "lineb" ~ nameId, {
                "start" : vector(lfx,lfy),
                "end" : vector((xpt),(ypt))
                });
                // 更新漸開線點座標
                lfx = xpt;
                lfy = ypt;
                nameId += 1;
            }
            // 紀錄左側漸開線的最後一點, 也就是齒頂圓上的點座標
            var lastlx = xpt;
            var lastly = ypt;
            // another side
            for (var i=1; i&amp;lt;imax+1; i+= 1)
            {
                if (rd&amp;gt;rb)
                {
                    r = rd+i*dr;
                }
                else
                {
                    r = rb+i*dr;
                }
                theta = sqrt((r*r)/(rb*rb)-1);
                var inv = theta*radian-atan(theta);
                // 漸開線上的點座標
                xpt = midx-r*sin(inv-rot-inv_rp-inc);
                ypt = midy+r*cos(inv-rot-inv_rp-inc);
                // rxd, ryd 為漸開線上的繪線起點座標
                skLineSegment(gearSketch, "linec" ~ nameId, {
                "start" : vector(rfx,rfy),
                "end" : vector((xpt),(ypt))
                });
                // 更新漸開線點座標
                rfx = xpt;
                rfy = ypt;
                nameId += 1;
            }
            var lastrx = xpt;
            var lastry = ypt;
            // 齒頂連線
            skLineSegment(gearSketch, "lined" ~ nameId2, {
            "start" : vector(lastlx,lastly),
            "end" : vector(lastrx,lastry)
            });
            nameId2 += 1;
        }
    skSolve(gearSketch);
    });
&lt;/pre&gt;



</t>
<t tx="amd.20160615082003.1">@language md
Title: Onshape Featurescript Spur Gear 零件
Category: MISC
Tags: Onshape, FeatureScript
Author: Cad Lab
@others
從 &lt;a href="https://forum.onshape.com/discussion/4064/use-opfillet-for-a-sketch"&gt;https://forum.onshape.com/discussion/4064/use-opfillet-for-a-sketch&lt;/a&gt; 的討論, 我們得知, 目前無法利用 FeatureScript 在繪圖平面中利用 opFillet, 對特定平面圖元進行倒圓角運算, 因此延續&lt;a href="http://cadlab.mde.tw/post/onshape-featurescript-spur-gear-lun-kuo-hui-tu.html"&gt;上一篇利用漸開線正齒輪輪廓&lt;/a&gt;轉換為正齒輪零件, 就必須在實體模型中進行倒圓角運算.

&lt;!-- PELICAN_END_SUMMARY --&gt;

這裡的 FeatureScript 程式碼, 基本架構引用 &lt;a href="https://cad.onshape.com/documents/57494152e4b05f50e871a72c/w/a4a3f09939bf1f43a8e4f133/e/2b865798923d6f648f7196f9"&gt;Onshape 官方正齒輪繪圖 FeatureScript 程式第1版&lt;/a&gt; 的內容, 只將推導的漸開線點座標, 透過 skFitSpline 轉為平滑曲線, 但是原版的 offset 參數, 目前只導入 offsetAngle, 以便產生的正齒輪, 可以在組立件中進行囓合.

17 齒漸開線正齒輪 FeatureScript 程式繪圖:

&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/summer_featurescript_spur_17t.png" width="800" /&gt;

170 齒漸開線正齒輪 FeatureScript 程式繪圖:

&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/summer_featurescript_spur_170t.png" width="800" /&gt;

2016 Spring 的協同產品設計實習課程, 就要在這個 Onshape FeatureScript 正齒輪零件程式的練習中劃下句點, 下學期的電腦輔助設計實習課程仍將採用 Onshape 與 FreeCAD, 當然 PTC Creo Parametric 年久失修的 Pro/Web.Link 仍可列入參考, 只是 Onshape 加上 FeatureScript 的魅力, 至今沒有其他 MCAD 套件可以比擬, 假如您是隸屬於特定團隊的電腦輔助機械設計工程師, 一定要試試 Onshape, 並且利用 FeatureScript 程式客製化產品開發流程中特定的重要零件. 一旦領略雲端電腦輔助機械設計套件的威力之後, 應該就再也回不去了.

我們當然也知道台灣有許多創新產品開發公司, 至今仍然使用著多年前的 MACD 套件, 忍受著系統更新維護與版本老舊的諸多問題, 假如以購買一套桌上版的商用中端 MCAD 套件, 等於可以連續付月費使用 Onshape 5 年來說, 在日新月異的當下, 5 年前的任何一套 MCAD, 即便功能再強, 也早就應該要更迭換新了, 何況, 檢查一下過去 5 年來工程師為了應付機電整合與製程規劃, 儲存在特定電腦硬碟中的紛亂版本, 將設計研發重心逐步轉換到 Onshape 應該才是解決之道.

以下為上述漸開線正齒輪零件繪圖的 FeatureScript 原始碼:

&lt;pre class="brush: jscript"&gt;
FeatureScript 355;
import(path : "onshape/std/geometry.fs", version : "355.0");
 
annotation { "Feature Type Name" : "Summer Spur Gear", "Feature Name Template" : "Spur Gear (#teeth teeth)", "Filter Selector" : "fs", "Editing Logic Function" : "editGearLogic" }
export const SpurGear = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "teeth", "UIHint" : "ALWAYS_HIDDEN" }
        definition.teeth is string; //used to name the feature only
        
        annotation { "Name" : "Number of teeth" }
        isInteger(definition.numTeeth, TEETH_BOUNDS);

        annotation { "Name" : "Input type" }
        definition.GearInputType is GearInputType;

        if (definition.GearInputType == GearInputType.module)
        {
            annotation { "Name" : "Module" }
            isLength(definition.module, MODULE_BOUNDS);
        }

        if (definition.GearInputType == GearInputType.diametralPitch)
        {
            annotation { "Name" : "Diametral pitch" }
            isReal(definition.diametralPitch, POSITIVE_REAL_BOUNDS);
        }

        if (definition.GearInputType == GearInputType.circularPitch)
        {
            annotation { "Name" : "Circular pitch" }
            isLength(definition.circularPitch, LENGTH_BOUNDS);
        }

        annotation { "Name" : "Pitch circle diameter" }
        isLength(definition.pitchCircleDiameter, LENGTH_BOUNDS);

        annotation { "Name" : "Pressure angle" }
        isAngle(definition.pressureAngle, PRESSURE_ANGLE_BOUNDS);

        annotation { "Name" : "Center hole" }
        definition.centerHole is boolean;

        if (definition.centerHole)
        {
            annotation { "Name" : "Hole diameter" }
            isLength(definition.centerHoleDia, CENTERHOLE_BOUNDS);

            annotation { "Name" : "Keyway" }
            definition.key is boolean;

            if (definition.key)
            {
                annotation { "Name" : "Key width" }
                isLength(definition.keyWidth, KEY_BOUNDS);

                annotation { "Name" : "Key height" }
                isLength(definition.keyHeight, KEY_BOUNDS);
            }
        }

        annotation { "Name" : "Select origin position" }
        definition.centerPoint is boolean;

        if (definition.centerPoint)
        {
            annotation { "Name" : "Sketch vertex for center", "Filter" : EntityType.VERTEX &amp;amp;&amp;amp; SketchObject.YES, "MaxNumberOfPicks" : 1 }
            definition.center is Query;
        }
        
        annotation { "Name" : "Extrude depth" }
        isLength(definition.gearDepth, BLEND_BOUNDS);

        annotation { "Name" : "Extrude direction", "UIHint" : "OPPOSITE_DIRECTION" }
        definition.flipGear is boolean;

        annotation { "Name" : "Offset" }
        definition.offset is boolean;

        if (definition.offset)
        {
            annotation { "Name" : "Root diameter" }
            isLength(definition.offsetClearance, ZERO_DEFAULT_LENGTH_BOUNDS);

            annotation { "Name" : "Outside diameter" }
            isLength(definition.offsetDiameter, ZERO_DEFAULT_LENGTH_BOUNDS);

            annotation { "Name" : "Tooth angle" }
            isAngle(definition.offsetAngle, ANGLE_360_ZERO_DEFAULT_BOUNDS);
        }
    }
    {
        var offsetDiameter = 0 * meter;
        var offsetClearance = 0 * meter;
        var offsetAngle = 0 * degree;

        if (definition.offset)
        {
            offsetDiameter = definition.offsetDiameter;
            offsetClearance = definition.offsetClearance;
            offsetAngle = definition.offsetAngle;
        }

        if (definition.centerHole &amp;amp;&amp;amp; definition.centerHoleDia &amp;gt;= definition.pitchCircleDiameter - 4 * definition.module)
        {
            throw regenError("Center hole diameter must be less than the root diameter", ["centerHoleDia"]);
        }
        
        if (definition.key &amp;amp;&amp;amp; definition.keyHeight / 2 + definition.centerHoleDia &amp;gt;= definition.pitchCircleDiameter - 4 * definition.module)
        {
            throw regenError("Center hole diameter plus Key height must be less than the root diameter", ["keyHeight"]);
        }
        // if no center vertex selected build gear on the front plane at the origin
        var location = vector(0, 0, 0) * meter;
        var sketchPlane = plane(location, vector(0, -1, 0), vector(1, 0, 0));
        var center3D = location;

        // else find location of selected vertex and its sketch plane and create a new sketch for the gear profile
        if (definition.centerPoint)
        {
            location = evaluateQuery(context, definition.center)[0];
            sketchPlane = evOwnerSketchPlane(context, { "entity" : location });
            center3D = evVertexPoint(context, { "vertex" : location });
        }

        const gearSketch = newSketchOnPlane(context, id + "gearSketch", { "sketchPlane" : sketchPlane });
        const center2D = worldToPlane(sketchPlane, center3D);

        var filletEdges = [];
        var regionPoint;
        // 漸開線近似點數
        var imax = 5;
        // 使用者所選的齒輪圓心 x 座標
        var midx = center2D[0];
        // 使用者所選的齒輪圓心 y 座標
        var midy = center2D[1];
        // 齒數
        var n = definition.numTeeth;
        // 模數
        var m = definition.module;
        // 壓力角, 單位為角度
        var pa = definition.pressureAngle;
        // 齒輪的節圓半徑
        var rp = m*n/2;
        
        // 正齒輪囓合用的定位線
        skLineSegment(gearSketch, "line", {
        "start" : vector(midx,midy),
        "end" : vector(midx,midy+rp)
        });
        
        // 齒根, 暫時不考慮納入 offsetClearance
        var d = 2.5*rp/n;
        // 齒頂圓半徑, 暫不考慮納入 offsetDiameter
        var ra = rp + m;
        // 基圓半徑
        var rb = rp*cos(pa);
        //print(rb);
        // 齒根圓半徑
        var rd = rp - d;
        // 分段後齒頂與齒根半徑差增量
        var dr = 0*meter;
        // 若 rb &amp;gt; rd 時從基圓開始繪製漸開線, 但是若 rd &amp;gt; rb, 則漸開線從 rd 畫到齒頂圓
        if (rd &amp;gt; rb)
        {
            // 半徑差的分段, 由齒根圓到齒頂圓
            dr = (ra-rd)/imax;
        }
        else
        {
            // 半徑差的分段, 由基圓到齒頂圓
            dr = (ra-rb)/imax;
        }
        // PI 為實數值沒有單位, tan(pa)也沒有單位, pa 已經設定單位為 degree
        var rot = PI/(2*n)*radian;
        // 用來設定 entity id 用的增量變數
        var nameId = 1;
        var r = 0*meter;
        // theta 為浮點數字
        var theta = 0;
        var inv = 0*radian;
        var inc = 0*radian;
        // 當 r=rp 時 ,計算 inv_rp 用來旋轉漸開線用
        // theta 為沒有單位的實數
        theta = sqrt((rp*rp)/(rb*rb)-1);
        // atan(theta) 為 radian
        // Onshape SG 的 const alpha 就是這裡的 inv_rp
        // Onshape SG 的 const beta 就是這裡的 rot-inv_rp
        var inv_rp = theta*radian-atan(theta);
        // 漸開線上點的 x 座標
        var xpt = 0*meter;
        // 漸開線上點的 y 座標
        var ypt = 0*meter;
        // 左側漸開線第1點座標 left first x and y
        var lfx = 0*meter;
        var lfy = 0*meter;
        // 右側漸開線第1點座標 right first x and y
        var rfx = 0*meter;
        var rfy = 0*meter;
        // 左側齒根圓上點座標 left x of dedendum point
        var lxd = 0*meter;
        var lyd = 0*meter;
        // 右側齒根圓上點座標 right x of dedendum point
        var rxd = 0*meter;
        var ryd = 0*meter;
        // 左側齒根圓上點座標 right x of dedendum point (advanced)
        var lxd_ad = 0*meter;
        var lyd_ad = 0*meter;
        var inc_ad = 0*radian;

        for (var j=0;j&amp;lt;n;j+=1)
        {
            var involute1 = [];
            var involute2 = [];
            var arcDone = false;
            var point1;
            var point2;
            
            // 當 j 增量時, 按照齒數輪廓繞行旋轉增量角度, 加入 offsetAngle 參數
            inc = (2.*j*PI/n)*radian+offsetAngle;
            inc_ad = (2.*(j+1)*PI/n)*radian+offsetAngle;
            if (rd&amp;gt;rb)
            {
                // 當齒根半徑因為齒數增多後大於基圓半徑時, 漸開線從齒根圓長起
                theta = sqrt((rd*rd)/(rb*rb)-1.);
                inv = theta*radian-atan(theta);
                // 左側漸開線第1點座標
                // 左側輪廓線配合逆時針旋轉 inc 角度
                lfx = midx+rd*sin(inv-rot-inv_rp+inc);
                lfy = midy+rd*cos(inv-rot-inv_rp+inc);
                point1 = vector(lfx, lfy);
                lxd = lfx;
                lyd = lfy;
                lxd_ad = midx+rd*sin(inv-rot-inv_rp+inc_ad);
                lyd_ad = midy+rd*cos(inv-rot-inv_rp+inc_ad);
                // 右側漸開線第1點座標
                // 右側輪廓線配合順時針旋轉 inc 角度
                rfx = midx-rd*sin(inv-rot-inv_rp-inc);
                rfy = midy+rd*cos(inv-rot-inv_rp-inc);
                point2 = vector(rfx, rfy);
                rxd = rfx;
                ryd = rfy;
            }
            else
            {
                // 當基圓半徑大於齒根圓時, 漸開線從基圓長起
                //theta = sqrt((rb*rb)/(rb*rb)-1.);
                theta = 0;
                inv = theta*radian-atan(theta);
                // 左側漸開線第1點座標
                lfx = midx+rb*sin(inv-rot-inv_rp+inc);
                lfy = midy+rb*cos(inv-rot-inv_rp+inc);
                point1 = vector(lfx, lfy);
                lxd = midx+rd*sin(inv-rot-inv_rp+inc);
                lyd = midy+rd*cos(inv-rot-inv_rp+inc);
                lxd_ad = midx+rd*sin(inv-rot-inv_rp+inc_ad);
                lyd_ad = midy+rd*cos(inv-rot-inv_rp+inc_ad);
                // 左側從基圓點到齒根圓點, 畫直線 left from base point to dedendum point
                skLineSegment(gearSketch, "line_lbd" ~ nameId, {
                "start" : vector(lfx,lfy),
                "end" : vector((lxd),(lyd))
                });
                // 右側漸開線第1點座標
                rfx = midx-rb*sin(inv-rot-inv_rp-inc);
                rfy = midy+rb*cos(inv-rot-inv_rp-inc);
                point2 = vector(rfx, rfy);
                rxd = midx-rd*sin(inv-rot-inv_rp-inc);
                ryd = midy+rd*cos(inv-rot-inv_rp-inc);
                // 右側從基圓點到齒根圓點, 畫直線 right from base point to dedendum point
                skLineSegment(gearSketch, "line_rbd" ~ nameId, {
                "start" : vector(rfx,rfy),
                "end" : vector((rxd),(ryd))
                });
            }
            // 處理齒根的圓弧
            if (!arcDone) // create base arc between involutes once per tooth
            {
                var mid = getArcMidPoint(center2D, vector(lxd_ad,lyd_ad), vector(rxd,ryd)); // sketch arc is arc 3 points so need addtional point on arc

                if (mid != undefined) // if no base cylinder present (due to pressure angle), don't draw it
                {
                    // 齒根圓上的圓弧
                    skArc(gearSketch, "arc-d" ~ nameId, {
                                "start" : vector(lxd_ad,lyd_ad),
                                "mid" : mid,
                                "end" : vector(rxd,ryd)
                            });
                }
                if (rd&amp;gt;rb)
                {   
                    // 只有在齒根圓半徑大於基圓時, 將漸開線起點作為倒圓角的基準點
                    // find points in 3D space where edges need to be filleted later
                    filletEdges = append(filletEdges, toWorldVector(planeToCSys(sketchPlane), point2, definition.gearDepth, definition.flipGear));
                    filletEdges = append(filletEdges, toWorldVector(planeToCSys(sketchPlane), point1, definition.gearDepth, definition.flipGear));
                }
                else
                {
                    // 當小齒數時, 從基圓到齒根圓有一條直線, 因此倒圓角基準點必須以齒根圓上的點為基準
                    // find points in 3D space where edges need to be filleted later
                    filletEdges = append(filletEdges, toWorldVector(planeToCSys(sketchPlane), vector(rxd, ryd), definition.gearDepth, definition.flipGear));
                    filletEdges = append(filletEdges, toWorldVector(planeToCSys(sketchPlane), vector(lxd, lyd), definition.gearDepth, definition.flipGear));
                }
                // find area to extrude
                regionPoint = vector(point1[0] * 0.95 + center2D[0]*0.05, point1[1] * 0.95+center2D[1]*0.05, 0 * meter);
                arcDone = true;
            }
            // 將漸開線第1點存入 involute1 與 involute2 陣列中
            involute1 = append(involute1, point1);
            involute2 = append(involute2, point2);
 
            for (var i=1; i&amp;lt;imax+1; i+= 1)
            {
                // 先處理中線左側的漸開線
                // 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if (rd&amp;gt;rb)
                {
                    r = rd+i*dr;
                }
                else
                {
                    r = rb+i*dr;
                }
                theta = sqrt((r*r)/(rb*rb)-1);
                var inv = theta*radian-atan(theta);
                // 漸開線上的點座標
                xpt = midx+r*sin(inv-rot-inv_rp+inc);
                ypt = midy+r*cos(inv-rot-inv_rp+inc);
                point1 = vector(xpt, ypt);
                // 更新漸開線點座標
                lfx = xpt;
                lfy = ypt;
                //nameId += 1;
                involute1 = append(involute1, point1);
            }
            // 紀錄左側漸開線的最後一點, 也就是齒頂圓上的點座標
            var lastlx = xpt;
            var lastly = ypt;
            // another side
            for (var i=1; i&amp;lt;imax+1; i+= 1)
            {
                if (rd&amp;gt;rb)
                {
                    r = rd+i*dr;
                }
                else
                {
                    r = rb+i*dr;
                }
                theta = sqrt((r*r)/(rb*rb)-1);
                var inv = theta*radian-atan(theta);
                // 漸開線上的點座標
                xpt = midx-r*sin(inv-rot-inv_rp-inc);
                ypt = midy+r*cos(inv-rot-inv_rp-inc);
                point2 = vector(xpt, ypt);
                // 更新漸開線點座標
                rfx = xpt;
                rfy = ypt;
                //nameId += 1;
                involute2 = append(involute2, point2);
            }
            var lastrx = xpt;
            var lastry = ypt;

            // create involute sketch splines
            skFitSpline(gearSketch, "spline-a" ~ nameId, {
                        "points" : involute1
                    });
            skFitSpline(gearSketch, "spline-b" ~ nameId, {
                        "points" : involute2
                    });
            // 要注意, 若對調 vector(lastrx, lastry) 與 vector(lastlx, lastly) 則無法求得中點
            var mid_a = getArcMidPoint(center2D, vector(lastrx,lastry), vector(lastlx,lastly));
            if (mid_a != undefined)
            {
                skArc(gearSketch, "arc-a" ~ nameId, {
                            "start" : vector(lastlx,lastly),
                            "mid" : mid_a,
                            "end" : vector(lastrx,lastry)
                        }); 
            }
            nameId += 1;
        }
        if (definition.centerHole)
        {
            if (definition.key)
            {
                var keyVector = vector(0, 1);
                var perpKeyVector = vector(-1, 0);
                var keyHeight = (definition.keyHeight + definition.centerHoleDia) / 2;

                var points = [
                    center2D - (definition.keyWidth / 2) * perpKeyVector,
                    center2D - (definition.keyWidth / 2) * perpKeyVector + keyHeight * keyVector,
                    center2D + (definition.keyWidth / 2) * perpKeyVector + keyHeight * keyVector,
                    center2D + (definition.keyWidth / 2) * perpKeyVector];

                for (var i = 0; i &amp;lt; size(points); i += 1)
                {
                    skLineSegment(gearSketch, "line" ~ nameId,
                            { "start" : points[i],
                                "end" : points[(i + 1) % size(points)]
                            });
                    nameId += 1;
                }
            }

            // center hole circle sketch
            skCircle(gearSketch, "Center", {
                        "center" : center2D,
                        "radius" : definition.centerHoleDia / 2
                    });
        }
    skSolve(gearSketch);
    
    extrude(context, id + "extrude1", {
                "entities" : qContainsPoint(qCreatedBy(id + "gearSketch", EntityType.FACE), toWorld(planeToCSys(sketchPlane), regionPoint)),
                "endBound" : BoundingType.BLIND,
                "depth" : definition.gearDepth,
                "oppositeDirection" : definition.flipGear
            });
    

    var filletEdges3D = [];

    for (var i = 0; i &amp;lt; size(filletEdges); i += 1)
    {
        // Find the edges that intersect the points previously collected
        filletEdges3D = append(filletEdges3D, qContainsPoint(qCreatedBy(id + "extrude1", EntityType.EDGE), filletEdges[i]));
    }

    const filletRadius = norm(filletEdges[1] - filletEdges[0]) / 4; // arbitrary fillet size = one fourth the distance between the edges

    if (filletRadius &amp;gt;= 0.2 * millimeter) // arbitrary small size assuming tooling cannot hold a fillet radius smaller than this
    {
        
        try(opFillet(context, id + "fillet1", {
                        "entities" : qUnion(filletEdges3D),
                        "radius" : filletRadius
                    }));
        
    }

    // Remove sketch entities - no longer required
    opDeleteBodies(context, id + "delete", { "entities" : qCreatedBy(id + "gearSketch") });

    // created PCD sketch
    const PCDSketch = newSketchOnPlane(context, id + "PCDsketch", { "sketchPlane" : sketchPlane });
    skCircle(PCDSketch, "PCD", {
                "center" : center2D,
                "radius" : definition.pitchCircleDiameter / 2,
                "construction" : true
            });
    skSolve(PCDSketch);
    });
    
function getArcMidPoint(center is Vector, start is Vector, end is Vector)
{
    // need to convert 2D vectors back to 3D for vector angle calculation
    const center3D = vector(center[0], center[1], 0 * meter);
    const start3D = vector(start[0], start[1], 0 * meter);
    const end3D = vector(end[0], end[1], 0 * meter);

    const angle = vectorAngle(center3D - start3D, center3D - end3D) / 2;
    // if angle is less than zero then arc was flipped
    if (angle &amp;lt;= 0 * radian)
        return;
    start = center - start;

    var ca = cos(angle); // in radians
    var sa = sin(angle);
    return center - vector(ca * start[0] - sa * start[1], sa * start[0] + ca * start[1]);
}

function vectorAngle(vector1 is Vector, vector2 is Vector)
{
    // function assumes vectors are on a 2D plane so Z is always zero and the normal vector is always [0, 0, 1]
    return atan2(dot(vector(0, 0, 1), cross(vector1, vector2)), dot(vector1, vector2));
}

function toWorldVector(csys is CoordSystem, point is Vector, depth is map, direction is boolean) returns Vector
{
    var dir = direction ? -1 : 1;
    var vector3D = vector(point[0], point[1], dir * depth / 2);
    return toWorld(csys, vector3D);
}

export function editGearLogic(context is Context, id is Id, oldDefinition is map, definition is map, isCreating is boolean, specifiedParameters is map, hiddenBodies is Query) returns map
{
    // isCreating is required in the function definition for edit logic to work when editing an existing feature
    if (oldDefinition.numTeeth != definition.numTeeth)
    {
        definition.module = definition.pitchCircleDiameter / definition.numTeeth;
        definition.circularPitch = definition.module * PI;
        definition.diametralPitch = 1 * inch / definition.module;
        definition.teeth = toString(definition.numTeeth); //to name the feature
        return definition;
    }
    
    if (oldDefinition.circularPitch != definition.circularPitch)
    {
        definition.module = definition.circularPitch / PI;
        definition.pitchCircleDiameter = (definition.circularPitch * definition.numTeeth) / PI;
        definition.diametralPitch = 1 * inch / definition.module;
        return definition;
    }
    
    if (oldDefinition.pitchCircleDiameter != definition.pitchCircleDiameter)
    {
        definition.module = definition.pitchCircleDiameter / definition.numTeeth;
        definition.circularPitch = (PI * definition.pitchCircleDiameter) / definition.numTeeth;
        definition.diametralPitch = 1 * inch / definition.module;
        return definition;
    }
    
    if (oldDefinition.module != definition.module)
    {
        definition.circularPitch = definition.module * PI;
        definition.pitchCircleDiameter = definition.numTeeth * definition.module;
        definition.diametralPitch = 1 * inch / definition.module;
        return definition;
    }
    
    if (oldDefinition.diametralPitch != definition.diametralPitch)
    {
        definition.circularPitch = PI / (definition.diametralPitch / inch);
        definition.module = definition.circularPitch / PI;
        definition.pitchCircleDiameter = (definition.circularPitch * definition.numTeeth) / PI;
        return definition;
    }

    return definition;
}

const TEETH_BOUNDS =
{
            "min" : 4,
            "max" : 250,
            (unitless) : [4, 25, 250]
        } as IntegerBoundSpec;

const PRESSURE_ANGLE_BOUNDS =
{
            "min" : 12 * degree,
            "max" : 35 * degree,
            (degree) : [12, 20, 35]
        } as AngleBoundSpec;

const MODULE_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.001, 500],
            (centimeter) : 0.1,
            (millimeter) : 1.0,
            (inch) : 0.04
        } as LengthBoundSpec;

const CENTERHOLE_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.01, 500],
            (centimeter) : 1.0,
            (millimeter) : 10.0,
            (inch) : 0.375
        } as LengthBoundSpec;

const KEY_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.003, 500],
            (centimeter) : 0.3,
            (millimeter) : 3.0,
            (inch) : 0.125
        } as LengthBoundSpec;

export enum GearInputType
{
    annotation { "Name" : "Module" }
    module,
    annotation { "Name" : "Diametral pitch" }
    diametralPitch,
    annotation { "Name" : "Circular pitch" }
    circularPitch
}
&lt;/pre&gt;</t>
<t tx="amd.20160618114526.1">@language md
Title: Virtualbox 的應用與網路設定 (二)
Category: MISC
Tags: cadlab, virtualbox, 虛擬機器
Author: Cad Lab
@others
透過 Virtualbox 的使用說明: &lt;a href="https://www.virtualbox.org/manual/"&gt;https://www.virtualbox.org/manual/&lt;/a&gt; 可以了解一個 Virtualbox 的虛擬機器, 若啟用 ICH9 Chipset, 最多可以&lt;a href="https://www.virtualbox.org/manual/ch03.html#settings-motherboard"&gt;支援 36 片網路卡&lt;/a&gt;.

&lt;!-- PELICAN_END_SUMMARY --&gt;

如下圖所示:

&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/virtualbox_ich9_36_nic.png" width="800" /&gt;

至於 &lt;a href="https://www.virtualbox.org/manual/ch06.html#network_hostonly"&gt;host-only 的網路卡設定&lt;/a&gt; 正好介於 bridged 與 internal 網路設定特性之間. 也就是說 host-only 網路卡設定與 bridged 網路卡設定類似, 可以想像各採用 host-only 設定的虛擬機器與 host 機器的網路線全部接到同一台network switch (網路交換器), 不僅可以彼此連線, 也能與 host 連線. 但是 host-only 網路卡設定與 bridged network 設定的差異是, host-only 無需與任何實體網路卡進行橋接, 而是透過位於 host 機器上的虛擬網路卡達到與各虛擬機器及 host 網路相連的目的. 

而 host-only 網路卡設定與 internal 網路設定類似的地方, 在於這些設定為 host-only 網路卡相連的虛擬機器無法與 host 以外的網路相連.

另外, 透過 bridged 網路卡設定說明: &lt;a href="https://www.virtualbox.org/manual/ch06.html#network_bridged"&gt;https://www.virtualbox.org/manual/ch06.html#network_bridged&lt;/a&gt;, 我們也可以得知, 所謂虛擬機器的橋接網路連線設定, 就是要讓虛擬機器透過 host 上的實體網路卡, 與外部的網路相連, 成為一台與 host 位階相同的伺服機器.

至於在使用 Virtualbox 的過程, 當使用者需要設定虛擬機器的 uuid 時, 可以透過下列 Python3 程式產生 uuid.

&lt;pre class="brush: python"&gt;
import uuid
print(uuid.uuid1())
#UUID('5361a11b-615c-42bf-9bdb-e2c3790ada14')
&lt;/pre&gt;

接著再利用:

VBoxManage startvm "Your VM name", 使用 Virtualbox 指定的 uuid, 或者自行指定虛擬機器的 uuid.

VBoxManage startvm "Your VM name" 5361a11b-615c-42bf-9bdb-e2c3790ada14

由於虛擬機器的 uuid 只用於 global configuration data 的設定, 以及各虛擬機器啟動時的基本辨識, 因此也可以直接在設定檔案中更改, 只要前後呼應即可. 但是虛擬硬碟的對應 uuid 則與 .vdi 檔案綁定, 因此根據 &lt;a href="https://www.virtualbox.org/manual/ch08.html#vboxmanage-clonevdi"&gt;https://www.virtualbox.org/manual/ch08.html#vboxmanage-clonevdi&lt;/a&gt; 中的說明, 可以利用:

VBoxManage clonemedium Master.vdi Clone.vdi

手動進行 vdi 檔案的複製, 基本概念是存在同一個 host 中的虛擬機器個別要有一個 uuid 編號, 而這個編號會在 host 中所安裝的 Virtualbox 套件中, 經由 preferances 設定檔案與個別虛擬機器引用時進行對應, 至於虛擬硬碟的 uuid, 除了與 .vdi 綁定, 也會在個別虛擬機器的設定檔案中前後出現兩次.

至於 Global configuration data 檔案的存放位置, 根據 &lt;a href="https://www.virtualbox.org/manual/ch10.html#idm8784"&gt;https://www.virtualbox.org/manual/ch10.html#idm8784&lt;/a&gt; 的說明, 在視窗操作系統會存在 HOME/.VirtualBox 目錄, 以 xml 格式儲存, 在 Linux 與 Solaris 操作系統中, 則儲存在 HOME/.config/VirtualBox 目錄中, 假如是 OS X 操作系統, 則會儲存在 HOME/Library/VirtualBox.

最後一點提示則是, 當操作系統中 Virtualbox 沒有開啟時, 使用者可以直接修改上述的相關設定檔案, 例如, Virtualbox 的 GUI 介面中 ,只能讓一個虛擬機器啟用 4 片網路卡, 假如使用者需要啟用第 5 ~ 36 片網路卡時, 可以根據 &lt;a href="https://www.virtualbox.org/manual/ch08.html#idm4023"&gt;https://www.virtualbox.org/manual/ch08.html#idm4023&lt;/a&gt; 的說明, 利用 VBoxManage modifyvm 指令進行設定, 或者直接編輯相關的設定檔案達成.



</t>
<t tx="amd.20160618115606.1">@language md
Title: 機械設計工程系 IPV6 網址分配
Category: MISC
Tags: cadlab, IPV6
Author: Cad Lab
@others
虎尾科大機械設計工程系將自即日起逐步啟用 IPV6 網路協定, 目前只有與軟體授權認証 (因為要服務廣域網路上僅支援 IPV4 協定的用戶連線) 及同時支援 IPV4/IPV6 協定的代理主機, 一定需要配置固定的 IPV4 網路位址外, 其他單純的網路連線均可採用純 IPV6 協定配置, 以純 IPV6 協定上網者, 若須連線到僅支援 IPV4 網路協定的主機, 請透過提供 IPV4/IPV6 雙支援的代理主機進行連線.

&lt;!-- PELICAN_END_SUMMARY --&gt;

以下為各 MDE 使用群組的 IPV6 網址分配:

&lt;style type="text/css"&gt;
table, th, td {
    border: 1px solid black;
    border-collapse: collapse;
}
th, td {
    padding: 15px;
}
&lt;/style&gt;
&lt;table&gt;
&lt;tr&gt;
    &lt;th&gt;MDE 群組&lt;/th&gt;
    &lt;th&gt;分配 IPV6 網段&lt;/th&gt; 
    &lt;th&gt;說明&lt;/th&gt;
    &lt;th&gt;備註&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td rowspan="2"&gt;MDE 行政專用&lt;/td&gt;
        &lt;td&gt;2001:288:6004:17:168:0000:0000:0000 ~&lt;br /&gt;2001:288:6004:17:168:FFFF:FFFF:FFFF&lt;/td&gt;
        &lt;td&gt;所有行政支援相關的裝置均採此網段設定,&lt;br /&gt;各行政人員再依員工編號設定所屬的裝置網址&lt;/td&gt;
        &lt;td&gt;prefix 設為 64&lt;br/&gt;gateway 設為 2001:288:6004:17::254&lt;br/&gt;dns 伺服器設為:&lt;br/&gt; 2001:288:6004:1:2 (虎科大) 與&lt;br/&gt;2001:b000:168::1 (中華電信)&lt;/td&gt;
    &lt;tr&gt;
        &lt;td&gt;(以管理人員員工編號尾碼為 3026 為例)&lt;br /&gt;2001:288:6004:17:168:3026:0000:0000 ~&lt;br /&gt;2001:288:6004:17:168:3026:FFFF:FFFF&lt;/td&gt;
        &lt;td&gt;以管理人員編號 B03026 為例, 取 3026 作為設定代號&lt;/td&gt;
        &lt;td&gt;prefix 設為 64&lt;br/&gt;gateway 設為 2001:288:6004:17::254&lt;br/&gt;dns 伺服器設為:&lt;br/&gt; 2001:288:6004:1:2 (虎科大) 與&lt;br/&gt;2001:b000:168::1 (中華電信)&lt;/td&gt;
    &lt;/tr&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;MDE 各教師&lt;/td&gt;
    &lt;td&gt;(以教師員工編號尾碼為 3001 為例)&lt;br /&gt;2001:288:6004:17:3001:0000:0000:0000 ~&lt;br /&gt;2001:288:6004:17:3001:FFFF:FFFF:FFFF&lt;/td&gt;
    &lt;td&gt;所有與教師相關的裝置均採此網段設定,&lt;br /&gt;
取各教師員工編號最後四碼作為設定代號&lt;/td&gt;
        &lt;td&gt;prefix 設為 64&lt;br/&gt;gateway 設為 2001:288:6004:17::254&lt;br/&gt;dns 伺服器設為:&lt;br/&gt; 2001:288:6004:1:2 (虎科大) 與&lt;br/&gt;2001:b000:168::1 (中華電信)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;MDE 工作站室&lt;/td&gt;
    &lt;td&gt;2001:288:6004:17:0000:0000:0000:0000 ~&lt;br /&gt;2001:288:6004:17:0000:0000:0000:FFFF&lt;/td&gt;
    &lt;td&gt;所有 8F 工作站室相關的裝置均採此網段設定&lt;/td&gt;
        &lt;td&gt;prefix 設為 64&lt;br/&gt;gateway 設為 2001:288:6004:17::254&lt;br/&gt;dns 伺服器設為:&lt;br/&gt; 2001:288:6004:1:2 (虎科大) 與&lt;br/&gt;2001:b000:168::1 (中華電信)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td rowspan="2"&gt;MDE 6F 教學實驗室&lt;/td&gt;
        &lt;td&gt;2001:288:6004:17:6F:0000:0000:0000 ~&lt;br /&gt;2001:288:6004:17:6F:FFFF:FFFF:FFFF&lt;/td&gt;
        &lt;td&gt;所有 6F 與教學相關的裝置均採此網段設定,&lt;br /&gt;
各教學實驗室再依教室編號最後四碼設定所屬的裝置網址&lt;/td&gt;
        &lt;td&gt;prefix 設為 64&lt;br/&gt;gateway 設為 2001:288:6004:17::254&lt;br/&gt;dns 伺服器設為:&lt;br/&gt; 2001:288:6004:1:2 (虎科大) 與&lt;br/&gt;2001:b000:168::1 (中華電信)&lt;/td&gt;
    &lt;tr&gt;
        &lt;td&gt;(以實驗室編號尾碼為 6768 為例)&lt;br /&gt;2001:288:6004:17:6F:6768:0000:0000 ~&lt;br /&gt;2001:288:6004:17:6F:6768:FFFF:FFFF&lt;/td&gt;
        &lt;td&gt;以 6F 實驗室編號最後四碼為 6768 為例, 取 6768 作為設定代號&lt;/td&gt;
        &lt;td&gt;prefix 設為 64&lt;br/&gt;gateway 設為 2001:288:6004:17::254&lt;br/&gt;dns 伺服器設為:&lt;br/&gt; 2001:288:6004:1:2 (虎科大) 與&lt;br/&gt;2001:b000:168::1 (中華電信)&lt;/td&gt;
    &lt;/tr&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td rowspan="2"&gt;MDE 7F 教學實驗室&lt;/td&gt; 
        &lt;td&gt;2001:288:6004:17:7F:0000:0000:0000 ~&lt;br /&gt;2001:288:6004:17:7F:FFFF:FFFF:FFFF&lt;/td&gt;
        &lt;td&gt;所有 7F 與教學相關的裝置均採此網段設定,&lt;br /&gt;
各教學實驗室再依教室編號最後四碼設定所屬的裝置網址&lt;/td&gt;
        &lt;td&gt;prefix 設為 64&lt;br/&gt;gateway 設為 2001:288:6004:17::254&lt;br/&gt;dns 伺服器設為:&lt;br/&gt; 2001:288:6004:1:2 (虎科大) 與&lt;br/&gt;2001:b000:168::1 (中華電信)&lt;/td&gt;
    &lt;tr&gt;
        &lt;td&gt;(以實驗室編號尾碼為 7768 為例)&lt;br /&gt;2001:288:6004:17:7F:7768:0000:0000 ~&lt;br /&gt;2001:288:6004:17:7F:7768:FFFF:FFFF&lt;/td&gt;
        &lt;td&gt;以 7F 實驗室編號最後四碼為 7768 為例, 取 7768 作為設定代號&lt;/td&gt;
        &lt;td&gt;prefix 設為 64&lt;br/&gt;gateway 設為 2001:288:6004:17::254&lt;br/&gt;dns 伺服器設為:&lt;br/&gt; 2001:288:6004:1:2 (虎科大) 與&lt;br/&gt;2001:b000:168::1 (中華電信)&lt;/td&gt;
    &lt;/tr&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td rowspan="2"&gt;MDE 8F 教學實驗室&lt;/td&gt;
        &lt;td&gt;2001:288:6004:17:8F:0000:0000:0000 ~&lt;br /&gt;2001:288:6004:17:8F:FFFF:FFFF:FFFF&lt;/td&gt;
        &lt;td&gt;所有 8F 與教學相關的裝置均採此網段設定,&lt;br /&gt;
各教學實驗室再依教室編號最後四碼設定所屬的裝置網址&lt;/td&gt;
        &lt;td&gt;prefix 設為 64&lt;br/&gt;gateway 設為 2001:288:6004:17::254&lt;br/&gt;dns 伺服器設為:&lt;br/&gt; 2001:288:6004:1:2 (虎科大) 與&lt;br/&gt;2001:b000:168::1 (中華電信)&lt;/td&gt;
    &lt;tr&gt;
        &lt;td&gt;(以實驗室編號尾碼為 8768 為例)&lt;br /&gt;2001:288:6004:17:8F:8768:0000:0000 ~&lt;br /&gt;2001:288:6004:17:8F:8768:FFFF:FFFF&lt;/td&gt;
        &lt;td&gt;以 8F 實驗室編號最後四碼為 8768 為例, 取 8768 作為設定代號&lt;/td&gt;
        &lt;td&gt;prefix 設為 64&lt;br/&gt;gateway 設為 2001:288:6004:17::254&lt;br/&gt;dns 伺服器設為:&lt;br/&gt; 2001:288:6004:1:2 (虎科大) 與&lt;br/&gt;2001:b000:168::1 (中華電信)&lt;/td&gt;
    &lt;/tr&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td rowspan="2"&gt;MDE 9F 教學實驗室&lt;/td&gt;
        &lt;td&gt;2001:288:6004:17:9F:0000:0000:0000 ~&lt;br /&gt;2001:288:6004:17:9F:FFFF:FFFF:FFFF&lt;/td&gt;
        &lt;td&gt;所有 9F 與教學相關的裝置均採此網段設定,&lt;br /&gt;
各教學實驗室再依教室編號最後四碼設定所屬的裝置網址&lt;/td&gt;
        &lt;td&gt;prefix 設為 64&lt;br/&gt;gateway 設為 2001:288:6004:17::254&lt;br/&gt;dns 伺服器設為:&lt;br/&gt; 2001:288:6004:1:2 (虎科大) 與&lt;br/&gt;2001:b000:168::1 (中華電信)&lt;/td&gt;
    &lt;tr&gt;
        &lt;td&gt;(以實驗室編號尾碼為 9768 為例)&lt;br /&gt;2001:288:6004:17:9F:9768:0000:0000 ~&lt;br /&gt;2001:288:6004:17:9F:9768:FFFF:FFFF&lt;/td&gt;
        &lt;td&gt;以 9F 實驗室編號最後四碼為 9768 為例, 取 9768 作為設定代號&lt;/td&gt;
        &lt;td&gt;prefix 設為 64&lt;br/&gt;gateway 設為 2001:288:6004:17::254&lt;br/&gt;dns 伺服器設為:&lt;br/&gt; 2001:288:6004:1:2 (虎科大) 與&lt;br/&gt;2001:b000:168::1 (中華電信)&lt;/td&gt;
    &lt;/tr&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;MDE 其他應用&lt;/td&gt;
    &lt;td&gt;2001:288:6004:17:a:0000:0000:0000 ~&lt;br /&gt;2001:288:6004:17:a:FFFF:FFFF:FFFF&lt;/td&gt;
    &lt;td&gt;所有未納入上列相關的裝置均採此網段設定&lt;/td&gt;
        &lt;td&gt;prefix 設為 64&lt;br/&gt;gateway 設為 2001:288:6004:17::254&lt;br/&gt;dns 伺服器設為:&lt;br/&gt; 2001:288:6004:1:2 (虎科大) 與&lt;br/&gt;2001:b000:168::1 (中華電信)&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;br /&gt;
&lt;br /&gt;
各 MDE 用戶若在校外採用中華電信光世代上網, 需啟用 IPV6 協定, 請參考 &lt;a href="http://www.ipv6.hinet.net/"&gt;http://www.ipv6.hinet.net/&lt;/a&gt; 相關說明, 一旦啟用 IPV6 網路協定後, 可以利用 &lt;a href="http://[2001:288:6004:17::101]/"&gt;http://[2001:288:6004:17::101]/&lt;/a&gt; 與 &lt;a href="http://test-ipv6.com/"&gt;http://test-ipv6.com/&lt;/a&gt; 進行 IPV6 網路連線測試.

從下圖可以發現目前中華電信光世代所提供的 IPV6 網路連線採用 IPV4 Tunnel 技術, 可以同時支援 IPV4/IPV6 雙協定連線:

&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/hinet_IPV6_connection_test.png" width="800" /&gt;

</t>
<t tx="ibm.20160115121941.1">@language md
Title: 電腦輔助設計室網誌開通
Category: 規劃
Tags: CAD, 綜一館8F
Author: kmol
@others
機械設計工程系電腦輔助設計室 2016 Fall 電腦系統規劃.

&lt;!-- PELICAN_END_SUMMARY --&gt;

CADLab 是國立虎尾科技大學機械設計工程系, 綜一館八樓, 共配置 64 台 (9x7 加上老師一台) 個人電腦的教學實驗室.

## 網誌文章分類

本網站的文章分類暫定為:

1. 規劃 (Planning) - 規劃中的專案, 但是尚未完成之前的相關配置與架構設計紀錄
2. 導引 (Tutorial) - 已經完成的流程紀錄與心得感想
3. 資源 (Resources) - 配合上課需求所提供的各項內容服務
4. 參考 (References) - 紀錄其他相關類似教學實驗室的管理方法與現況了解
5. 其他 (Misc) - 未能納入上述其他分類的文章

## 磁區規劃

1. 第1開機磁區為 &lt;a href="http://wincom.blob.core.windows.net/documents/Win10CompareTable.pdf"&gt;Windows 10 Pro 或 Education 64 位元版&lt;/a&gt;, 存放必須安裝才能啟動的應用程式
2. 第2開機磁區為 &lt;a href="http://wincom.blob.core.windows.net/documents/Win10CompareTable.pdf"&gt;Windows 10 Pro 或 Education 64 位元版&lt;/a&gt;, 存放無需安裝的綠色應用程式
3. 第3開機磁區為 &lt;a href="http://releases.ubuntu.com/16.04/"&gt;Ubuntu 16.04 LTS Server 版&lt;/a&gt;加裝 ubuntu-desktop

## 第1開機磁區

1. 網路連線以 IPV4 設定為主
2. 若有部份教學程式無法在 &lt;a href="http://wincom.blob.core.windows.net/documents/Win10CompareTable.pdf"&gt;Windows 10 Pro 或 Education 64 位元版&lt;/a&gt;操作系統中啟動, 將建議在 &lt;a href="https://www.virtualbox.org/"&gt;Virtualbox&lt;/a&gt; 中, 安裝 &lt;a href="http://windows.microsoft.com/zh-tw/windows/lifecycle"&gt;Windows 7 Professional&lt;/a&gt; 環境中使用
3. 由於仍需透過 NAT 轉址, 64 台電腦將共用一個對外 IP, 為提升連線速度, 將在系主幹建立四台代理主機, 由上課老師選擇使用

## 第2開機磁區

1. 網路連線以 IPV4 設定為主, 並以 IPV6 為輔
2. 當網路連線採 IPV6 上網後, 每一排特定電腦將以第3磁區開機 (共需要 9 個固定 IPV4  IP 位址), 並預先設定為 IPV4/IPV6 雙支援協定, 並啟動 &lt;a href="https://help.ubuntu.com/lts/serverguide/squid.html#squid-installation"&gt;Proxy Server&lt;/a&gt;, 其餘 55 台電腦將透過代理主機連線上網
3. 本磁區中的所有應用程式將以可攜方式配置, 無需安裝, 並同時提供支援 Ubuntu 或其他 Linux 操作系統中的對應版本

##第3開機磁區

1. 網路連線將以 IPV6 為主, 其中 9 台電腦將額外設置同時支援 IPV4/IPV6, 以便當作 &lt;a href="https://help.ubuntu.com/lts/serverguide/squid.html#squid-installation"&gt;Proxy Server&lt;/a&gt;, 讓其他純 IPV6 連線電腦可以連接純 IPV4 協定主機
2. 由於本磁區無法受還原卡保護, 因此開機後僅提供一般用戶權限, 使用預先安裝的應用套件
3. 本磁區所安裝的應用程式套件, 將與第2磁區對應, 專門提供跨平台應用程式教學使用

## CADLab 使用與維護

各班上課時, 每排推派一名輪值生, 負責事項:

1. 敦促同學不要在電腦桌上用餐
2. 上課前後, 負責到 CADLab 日誌, 登記或勾選學員電腦使用情形, 填寫維修單或建議表
3. 負責在課後, 確實檢查各電腦是否正常關機, 是否遺留個人物品
4. 負責在課後清潔各排座位地板與桌面, 與班上幹部配合全員離開 CADLab 前確實關閉所有照明與空調系統



</t>
<t tx="ibm.20160115125101.1">@language python
import os
# 從 .git 清除既有 post 目錄下的所有資料, 因為若更動相關文章 .md 設定, 將會在資料庫中殘留不必要的檔案資料
os.system("git rm -rf post")
g.es("git rm -rf post 執行完畢")</t>
<t tx="ibm.20160115125316.1"></t>
<t tx="leo.20151212173315.1"></t>
<t tx="leo.20151212173315.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="leo.20151212173315.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="leo.20151212173658.1">@language python
import os
os.system("pelican content -o post -s publishconf.py")
g.es("admin pelican 執行完畢")

</t>
<t tx="leo.20151213085727.1">@language python
import os
#os.system("pelican content -o output -s local_publishconf.py -t theme/pelican-bootstrap3")
os.system("pelican content -o post -s local_publishconf.py")
g.es("admin pelican 近端執行完畢")


</t>
<t tx="leo.20151213173811.1"></t>
<t tx="leo.20151213173830.1"></t>
<t tx="leo.20151213230723.1"></t>
<t tx="leo.20151213230729.1">利用

&lt;!-- PELICAN_END_SUMMARY --&gt;

來界定 Summary 摘要內容

前提, 必須設定 

PLUGIN_PATHS = ['plugin']

與

PLUGINS = ['liquid_tags.notebook', 'summary']

並且從 https://github.com/getpelican/pelican-plugins

取得 summary plugin</t>
<t tx="leo.20151213230957.1"># 設定網誌以 md 檔案建立的 file system date 為準, 無需自行設定

DEFAULT_DATE = 'fs'</t>
</tnodes>
</leo_file>
