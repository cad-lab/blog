<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>CADLab (虎尾科大MDE)</title><link href="http://cadlab.mde.tw/post/" rel="alternate"></link><link href="http://cadlab.mde.tw/post/feeds/misc.atom.xml" rel="self"></link><id>http://cadlab.mde.tw/post/</id><updated>2016-06-05T12:03:55+08:00</updated><entry><title>Virtualbox 的應用與網路設定</title><link href="http://cadlab.mde.tw/post/virtualbox-de-ying-yong-yu-wang-lu-she-ding.html" rel="alternate"></link><updated>2016-06-05T12:03:55+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-06-05:post/virtualbox-de-ying-yong-yu-wang-lu-she-ding.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.virtualbox.org/"&gt;Virtualbox&lt;/a&gt; 是一套能在 Windows, Linux, Mac 與 Solaris 操作系統上使用的虛擬器 (Virtualizer).&lt;/p&gt;


&lt;h2&gt;Virtualbox 功能&lt;/h2&gt;
&lt;p&gt;虛擬器的功能有下列幾點:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在任一操作系統開機後, 可以同時啟動多種虛擬的操作系統平台, 並且透過虛擬硬體的配置與設定, 執行各種老舊的操作系統應用程式 , 畢竟老應用程式不死, 只是慢慢凋零!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以檔案的架構保留各種電腦軟硬體的配置, 可提升軟體開發效能外, 並可在軟體推銷過程避開多次煩雜的設定 (當然 Docker based 的虛擬技術, 已經逐漸超越這種整套操作系統虛擬的應用).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程式開發者可以在虛擬機器中廣泛透過虛擬的硬體配置, 大膽進行各項操作與測試, 無需擔心損毀電腦週邊實體.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在開機的一台電腦實體中, 可同時模擬多台電腦的運作, 省下操作可能消耗的電力, 降低實體運作與硬體維護成本.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Virtualbox 的參考手冊: &lt;a href="https://www.virtualbox.org/manual/"&gt;https://www.virtualbox.org/manual/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下將針對 Virtualbox 的網路設定與應用加以說明:&lt;/p&gt;
&lt;p&gt;Virtualbox 的網路設定模式分為 NAT, Bridged, Internal, Host-only, UDP tunnel 與 VDE 等.&lt;/p&gt;
&lt;p&gt;NAT 使用情境為啟動虛擬機器後, 當作一般客戶端電腦使用, 虛擬機的連網是透過 NAT 轉址, 以 Host 電腦的網路 IP 對外抓取資料.&lt;/p&gt;
&lt;p&gt;Bridged 使用情境為啟動虛擬機器後, 當作一般伺服器電腦使用, 在 Host 操作系統中模擬出的虛擬網卡, 可以與 Host 電腦的實體網路卡進行橋接與設定外部 IP 後, 視為網路幹線上的一台伺服器.&lt;/p&gt;
&lt;p&gt;Interal 使用情境主要關注在虛擬機器之間的網路彼此相連, 但卻自外於與 Host 連接的區域或廣域網路, Internal networking 的特性通常用來當作資料庫伺服器, 可以透過 internal 網路, 提供對外連線的全球資訊網伺服器資料, 但是外部電腦無法跨越 internal 網路架構直接連線.&lt;/p&gt;
&lt;p&gt;Host-only 使用情境則將網路服務的範圍界定在 Host 主機範圍內, 在虛擬機器所啟動的各種服務, 可以讓 Host 連線, 但是因為沒有像 Bridged 網路設置, 與 Host 的實體網路卡進行橋接, 因此 Host-only 的網路環境通常讓操作 Host 的程式設計師將 Host-only 的電腦當作跨網路的虛擬伺服器使用.&lt;/p&gt;
&lt;p&gt;UDP tunnel 網路用來串接位於不同 Hosts 的虛擬機器, 而 VDE 則是 Virtual Distributed Ethernet 則是一種虛擬網路基礎架構.&lt;/p&gt;
&lt;p&gt;以機械設計的電腦輔助設計應用而言, Virtualbox 網路中的 NAT 與 Host-only 模式最為常用, 而 NAT 網路的設定非常直覺, 只要在所新增的虛擬機器中的網路設定, 選擇 NAT, 然後開機之後, 就可以直接在虛擬機器中使用轉址的網路服務.&lt;/p&gt;
&lt;h2&gt;Host-only 虛擬網路設定&lt;/h2&gt;
&lt;p&gt;Host-only 的網路設置則稍微複雜, 其中牽涉到 Virtualbox 應用程式的網路偏好設定, 以及虛擬機器本身的網路設定搭配, 才能讓 Host 中的應用程式透過 Host 操作系統中的 Host-only 虛擬網路卡, 與位於同一網段的虛擬機器設置連線.&lt;/p&gt;
&lt;h3&gt;Virtualbox 網路偏好設定&lt;/h3&gt;
&lt;p&gt;Virtualbox 的網路相關設定分為兩個層次, 有關整個 Virtualbox 的設定位於 File-&amp;gt;Preferences-&amp;gt;Network, 而第二個層次為各虛擬機器的個別設定. 若以 File-&amp;gt;Preferences-&amp;gt;Network 中, 有關 Host-only 網路設定的目的, 在讓 Virtualbox 的 Host 本體, 可以透過虛擬的網路卡與 Virtualbox 中的虛擬機器網路卡處於同一個區域網路中.&lt;/p&gt;
&lt;p&gt;換言之, 如 Host-only 這個名稱本身的所謂 Host only, 就是虛擬機器的網路能見度, 僅止於 Host only, 外部電腦無法與這些虛擬機器連線, 甚至若虛擬機器沒有透過 Host 電腦中的代理主機, 虛擬機器中的瀏覽器也無法連線上網.&lt;/p&gt;
&lt;p&gt;至於 File-&amp;gt;Preferences-&amp;gt;Network 中的 Host-only 設定, 總共決定兩件虛擬功能, 其一為位於 Host 中的虛擬網路卡, 要採用的網路協定與網址, 所謂的網路協定就是可以使用 IPV4 或 IPV6 網路協定, 至於虛擬網卡的網址, 就會決定這個所謂的 Host-only 網路, 位於那一個內部網段, 例如, 可以使用 IPV4 協定, 並將虛擬網路卡的網址設為 192.168.56.1, 也就是將 Host-only 的網段設為 192.168.56.0.&lt;/p&gt;
&lt;p&gt;File-&amp;gt;Preferences-&amp;gt;Network 中的 Host-only 第 2 個設定, 就是在這個上述設定的虛擬網段中, 是否要再虛擬出一台 DHCP 伺服器, 例如, 選擇要在這個虛擬 Host-only 網段中啟用虛擬的 DHCP 伺服器, 就可以決定這個虛擬的 DHCP 伺服器的 IP (當然要與第 1 項設定的網段相同, 也就是必須位於 192.168.56.0 網段中), 例如, 將虛擬的 DHCP server IP 設為 192.168.56.100, 並且將 DHCP IP 範圍設為 192.168.56.101-200.&lt;/p&gt;
&lt;p&gt;儘管 Virtualbox 中的 File-&amp;gt;Preferences-&amp;gt;Network 中的 Host-only 第 2 個設定, 可以啟用 DHCP, 但是通常使用 Host-only 虛擬網路模式的目的, 大多要在 Host 中連接虛擬機器中的伺服器, 使用特定的服務內容, 因此一般都停用 Host-only 網路設定中的虛擬 DHCP server 服務, 而採手動設定虛擬機器中的 IP 與 Gateway.&lt;/p&gt;
&lt;h3&gt;虛擬機器的網路設定&lt;/h3&gt;
&lt;p&gt;例如, 可以將其中第一台使用 Host-only 網路模式的虛擬機器網路 IP 設為 192.168.56.101, 並將 Gateway 設為 192.168.56.1 (也就是 Host 中對應虛擬網卡的 IP 位址), 第 2 台則設可為 192.168.56.102, 依此類推採用固定的 IP 位址來界定虛擬機器所提供的不同服務.&lt;/p&gt;
&lt;p&gt;Host-only 虛擬網路相關設定的參考畫面如下:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/virtualbox_host_only_1.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/virtualbox_host_only_2.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/virtualbox_host_only_3.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/virtualbox_host_only_4.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/virtualbox_host_only_5.png" width="800" /&gt;&lt;/p&gt;</summary><category term="CADLab"></category><category term="虛擬機器"></category></entry><entry><title>CADLab 新電腦系統</title><link href="http://cadlab.mde.tw/post/cadlab-xin-dian-nao-xi-tong.html" rel="alternate"></link><updated>2016-06-05T11:18:54+08:00</updated><author><name>Cad Lab</name></author><id>tag:cadlab.mde.tw,2016-06-05:post/cadlab-xin-dian-nao-xi-tong.html</id><summary type="html">&lt;p&gt;CPU 選擇: &lt;span style="background-color: #ffff00;"&gt;Intel i7-6700&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Ram  選擇: &lt;span style="background-color: #ffff00;"&gt;16GB (8GBx2) DDR4-3000 (至少還可再升級 8GBx2)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;HD: &lt;span style="background-color: #ffff00;"&gt;2TB (64MB) SATA III&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Video Card: &lt;span style="background-color: #ffff00;"&gt;NVIDIA GEFORCE GTX950 2GB GDDR5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;NIC: &lt;span style="background-color: #ffff00;"&gt;1Gbits/s*5 (除了主機板上的兩片網路卡之外 ,再加上 3 片外接式網路卡, 以便與各開機磁區中的虛擬機橋接出虛擬的多台連外伺服器)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;參考:&lt;/p&gt;
&lt;p&gt;i7: &lt;a href="https://en.wikipedia.org/wiki/List_of_Intel_Core_i7_microprocessors"&gt;https://en.wikipedia.org/wiki/List_of_Intel_Core_i7_microprocessors&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;i7-6700: &lt;a href="http://ark.intel.com/products/88196"&gt;http://ark.intel.com/products/88196&lt;/a&gt;&lt;/p&gt;</summary></entry><entry><title>電腦輔助設計室電腦磁區規劃</title><link href="http://cadlab.mde.tw/post/dian-nao-fu-zhu-she-ji-shi-dian-nao-ci-qu-gui-hua.html" rel="alternate"></link><updated>2016-06-05T11:11:07+08:00</updated><author><name>Cad Lab</name></author><id>tag:cadlab.mde.tw,2016-06-05:post/dian-nao-fu-zhu-she-ji-shi-dian-nao-ci-qu-gui-hua.html</id><summary type="html">&lt;div&gt;希望能根據不同性質課程, 將軟體分為 3 個開機磁區:&lt;/div&gt;

&lt;p&gt;&lt;ol&gt;
    &lt;li&gt;安裝所有老師提出的上課套件, 集中在第 1 磁區, 其中包括 CAD, CAE, CAM, 數值分析與自動控制相關所有套件.&lt;/li&gt;
    &lt;li&gt;只安裝 Solidworks, PTC Creo, AutoDesk Inventor, AutoCAD, A360, Ansys, Comsol, Matlab 與 Mathematica, 等 CAD, CAE 與數值分析相關套件.&lt;/li&gt;
    &lt;li&gt;只安裝操作系統, 加上無需安裝的綠色套件 (PTC, Creo, Comsol, Matlab 等).&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;&lt;/p&gt;


&lt;p&gt;&lt;/div&gt;
&lt;div&gt;至於以上 3 個開機磁區則傾向將新購買的 Windows 10 Pro 操作系統降為 Windows 7 Pro, 以提升使用效能. 但是仍然在第 2 磁區利用 Virtualbox 建立安裝 Windows 10 Pro 的兩台虛擬機器, 其中一台虛擬機配合安裝 Solidworks, PTC Creo, AutoDesk Inventor 與 Matlab , 而另一台虛擬機也採用 Windows 10 Pro 開機, 但只配置各軟體的原始 DVD, 可以讓老師教導學生執行各套件安裝與設定的教學.&lt;/div&gt;
 
&lt;div&gt;至於第 3 磁區則將利用 Virtualbox 建立一台配置&lt;a href="http://www.squid-cache.org/"&gt;網路代理功能&lt;/a&gt; (IPV4/IPV6 雙支援) 的 Ubuntu Server 虛擬伺服器, 以及一台空白的 Windows 10 Pro 虛擬機, 以便在純 IPV6 環境下進行課程教學.&lt;/div&gt;
 
&lt;div&gt;註解:&lt;/div&gt;
根據 &lt;a href="https://en.wikipedia.org/wiki/X86_virtualization#Intel-VT-x"&gt;https://en.wikipedia.org/wiki/X86_virtualization#Intel-VT-x&lt;/a&gt; 與 &lt;a href="https://en.wikipedia.org/wiki/List_of_Intel_Core_i7_microprocessors"&gt;https://en.wikipedia.org/wiki/List_of_Intel_Core_i7_microprocessors&lt;/a&gt; 的說明, 幾乎所有的 Intel CPU 都已經支援 VT-x 虛擬技術, 只要電腦的其他軟硬體配合啟動 VT-x, 就可以在 64 位元的操作系統主體, 模擬 64 位元的虛擬機, 假如再配合 Oracle 的新聞稿: &lt;a href="http://www.oracle.com/us/corporate/press/1842885"&gt;http://www.oracle.com/us/corporate/press/1842885&lt;/a&gt; 說明, Virtualbox 中的一台虛擬機 (Virtual Machine) 最多可以啟用 36 片虛擬網路卡, 因此只要電腦主體的硬體支援許可, 利用虛擬機就能有效模擬出相當複雜的網路伺服器架構.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/virtualbox5_upto_36_NIC.png" width="800" /&gt;&lt;/p&gt;</summary></entry><entry><title>Onshape FeatureScript 程式語言</title><link href="http://cadlab.mde.tw/post/onshape-featurescript-cheng-shi-yu-yan.html" rel="alternate"></link><updated>2016-05-31T10:17:16+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-31:post/onshape-featurescript-cheng-shi-yu-yan.html</id><summary type="html">&lt;p&gt;在 &lt;a href="https://embedwistia-a.akamaihd.net/deliveries/02d2dfd77d4c465c42fa30e66e3bb53f26467cbc/file.mp4"&gt;FeatureScript 簡介&lt;/a&gt;的影片中, 可以看到 Onshape 打造了一個客製化特徵功能的程式語言與社群分享機制, 任何人利用 FeatureScript 建立的延伸功能, 都能夠透過 Add custom features 指令與其他使用者分享.&lt;/p&gt;


&lt;p&gt;FeatureScript 是 Onshape 發明, 一種可用來定義客製化參數特徵用的程式語言, 具有下列特點:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;各 Document 中用戶所建立的 FeatureScript 程式碼, 位於 Feature Studio (特徵工房) 分頁中.&lt;/li&gt;
&lt;li&gt;FeatureScript 的整合開發環境 (Integrated Development Environment) 內建於 Onshape 中.&lt;/li&gt;
&lt;li&gt;Onshape 原本系統中使用的特徵功能, 其對應的 FeatureScript 程式碼, 已經採&lt;a href="https://cad.onshape.com/documents/5749364ce4b0f60f1b7940fe/w/925a5467b6e725168eb9c993/e/ff3b765aacc32576f893ed23"&gt;開放源&lt;/a&gt; (Open Source) 模式釋出.&lt;/li&gt;
&lt;li&gt;Onshape 同時提供 &lt;a href="https://cad.onshape.com/FsDoc/"&gt;FeatureScript 參考手冊&lt;/a&gt; 與 &lt;a href="https://forum.onshape.com/categories/featurescript"&gt;FeatureScript 論壇&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;登入 Onshape, 建立一個 Document 之後, 就可以透過左下角的 + 號中的 Create Feature Studio, 進入 FeatureScript 的整合開發環境, 開始編寫客製化的特徵程式碼, IDE 則提供下列相關功能:&lt;/p&gt;
&lt;p&gt;Parameter (參數)&lt;/p&gt;
&lt;p&gt;Length, Angle, Count, Query, Enum, Boolean and String&lt;/p&gt;
&lt;p&gt;Query (查詢)&lt;/p&gt;
&lt;p&gt;Everything, Nth element, Entity filter, Created by, Intersection, Subtraction, Symetric difference, Own by body, Own by body filter, Owner body, Entities adjacent to edge, Geometry type filter, Contains point, Intersects plane and Query evaluation&lt;/p&gt;
&lt;p&gt;Evaluation (評量)&lt;/p&gt;
&lt;p&gt;Tangent plane, Tangent line, Vertex point, Length measurement, Area measurement, Volume measurement, Query evaluation&lt;/p&gt;
&lt;p&gt;Sketch, Line segment, Circle, Arc, Ellipse, Rectangle, Line segment chain&lt;/p&gt;
&lt;p&gt;Cuboid, Cylinder, Extrude, Revolute, Fillet, Boolean, Transform, Import&lt;/p&gt;
&lt;p&gt;Import (導入)&lt;/p&gt;
&lt;p&gt;Format feature studio (整理特徵工房編輯格式)&lt;/p&gt;
&lt;p&gt;Commit (提交)&lt;/p&gt;
&lt;p&gt;FeatureScript 程式基本架構如下:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 355;
import(path : "onshape/std/geometry.fs", version : "355.0");
annotation { "Feature Type Name" : "My Feature" }
export const myFeature = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        // Define the parameters of the feature type
    }
    {
        // Define the function's action
    });
&lt;/pre&gt;

&lt;p&gt;上層宣告, 列舉值與指令敘述都可以加上 annotations (註解). FeatureScript 的註解使用格式類似 Python 的 Dictionary, 但是 annotation 的索引值型別必須為字串, 而且索引值為 "Feature Type Name" 的 annotation 為每一個特徵指令的必要註解.&lt;/p&gt;
&lt;p&gt;export 則可視為上述的程式碼中, 使用者所宣告的 myFeature 對應特徵物件會被優先置入 FeatureScript Template 中.&lt;/p&gt;
&lt;p&gt;此外 Onshape 任一頁面送出時, 都帶有以下標頭設置, 除了利用 X-Frame-Options:SAMEORIGIN, 不允許使用者將頁面納入 iframe 或 object 標註中外, 也避免遭受可能的網路攻擊:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
Cache-Control:must-revalidate,no-cache,no-store
Strict-Transport-Security:max-age=31536000; includeSubDomains
X-Content-Type-Options:nosniff
X-Frame-Options:SAMEORIGIN
X-XSS-Protection:1; mode=block
&lt;/pre&gt;

&lt;p&gt;以下則為目前 Onshape 官方釋出的參考應用範例:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494220e4b04aa3f56f82c2/w/888534aeb52c4daa68bbfd05/e/4a55fd2861eaa83fae0221d9"&gt;Point Pattern FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494152e4b05f50e871a72c/w/a4a3f09939bf1f43a8e4f133/e/2b865798923d6f648f7196f9"&gt;Spur Gear FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494187e4b0f60f1b7941c8/w/b98b4de33c1d47713be20e7f/e/c1f8d65fc6196f728620b857"&gt;Wave Spring FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Port feature 程式碼 (建立 SAE J1926 螺孔):&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

export enum PortSize
{
    annotation { "Name" : "5/16-24" }
    fiveSixteen,
    annotation { "Name" : "3/8-24" }
    threeEights,
    annotation { "Name" : "7/16-20" }
    sevenSixteen,
    annotation { "Name" : "1/2-20" }
    half,
    annotation { "Name" : "9/16-18" }
    nineSixteen,
    annotation { "Name" : "3/4-16" }
    threeFour,
    annotation { "Name" : "7/8-14" }
    sevenEights,
    annotation { "Name" : "1 1/16-12" }
    oneSixteen
}

annotation { "Feature Type Name" : "Port Feature" }
export const portFeature = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Port Size" }
        definition.portSize is PortSize;

        annotation { "Name" : "Points", "Filter" : EntityType.VERTEX }
        definition.points is Query;

        annotation { "Name" : "Depth" }
        isLength(definition.depth, DEPTH_BOUNDS);
    }
    {
        var ports;
        var depth = definition.depth;
        //here the vector points for each port are added to an array depending on size chosen
        if (definition.portSize == PortSize.fiveSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .019 * inch, -.031 * inch),
                    vector(-.631, -.031) * inch,
                    vector(-.53, -.132) * inch,
                    vector(-.167, -.132) * inch,
                    vector(-.136, -.163) * inch,
                    vector(-.062, -.179) * inch,
                    vector(-.062, -.336) * inch,
                    vector(0, -.336) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.threeEights)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .038 * inch, -.063 * inch),
                    vector(-.629, -.063) * inch,
                    vector(-.53, -.162) * inch,
                    vector(-.169, -.162) * inch,
                    vector(-.136, -.195) * inch,
                    vector(-.062, -.211) * inch,
                    vector(-.062, -.375) * inch,
                    vector(0, -.375) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.sevenSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .052 * inch, -.086 * inch),
                    vector(-.663, -.086) * inch,
                    vector(-.547, -.202) * inch,
                    vector(-.176, -.202) * inch,
                    vector(-.155, -.224) * inch,
                    vector(-.062, -.243) * inch,
                    vector(-.062, -.414) * inch,
                    vector(0, -.414) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.half)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .07 * inch, -.117 * inch),
                    vector(-.71, -.117) * inch,
                    vector(-.607, -.22) * inch,
                    vector(-.188, -.22) * inch,
                    vector(-.153, -.255) * inch,
                    vector(-.062, -.275) * inch,
                    vector(-.062, -.453) * inch,
                    vector(0, -.453) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.nineSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .089 * inch, -.149 * inch),
                    vector(-.773, -.149) * inch,
                    vector(-.671, -.251) * inch,
                    vector(-.195, -.251) * inch,
                    vector(-.159, -.287) * inch,
                    vector(-.062, -.308) * inch,
                    vector(-.062, -.485) * inch,
                    vector(0, -.485) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.threeFour)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .117 * inch, -.196 * inch),
                    vector(-.928, -.196) * inch,
                    vector(-.782, -.341) * inch,
                    vector(-.237, -.341) * inch,
                    vector(-.194, -.384) * inch,
                    vector(-.094, -.406) * inch,
                    vector(-.094, -.594) * inch,
                    vector(0, -.594) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.sevenEights)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .145 * inch, -.242 * inch),
                    vector(-1.032, -.242) * inch,
                    vector(-.875, -.399) * inch,
                    vector(-.245, -.399) * inch,
                    vector(-.194, -.45) * inch,
                    vector(-.094, -.471) * inch,
                    vector(-.094, -.672) * inch,
                    vector(0, -.672) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.oneSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .183 * inch, -.304 * inch),
                    vector(-1.22, -.304) * inch,
                    vector(-1, -.525) * inch,
                    vector(-.246, -.525) * inch,
                    vector(-.224, -.546) * inch,
                    vector(-.094, -.574) * inch,
                    vector(-.094, -.813) * inch,
                    vector(0, -.813) * inch,
                    vector(0, 0) * inch];
        }
        const checkLength = (ports[3] - ports[2]); 
        if (checkLength[0] &lt; 0) // check the depth entered and throw error if depth causes feature to invert
        {
            throw regenError(ErrorStringEnum.SKETCH_DIMENSION_FAILED, ["depth"]);
        }
        var points = evaluateQuery(context, definition.points);
        var numberOfPoints = size(points);
        var sketchId = id + "sketch";
        var portId = "port1";
        for (var i = 0; i &lt; numberOfPoints; i += 1) //for each point selected create a sketch using port vertices and revolve cut
        {
            sketchId = sketchId + i;
            var point = points[i];
            var sketchPlane = evOwnerSketchPlane(context, { "entity" : point });
            var cSys = planeToCSys(sketchPlane);
            var pointVertex = evVertexPoint(context, { "vertex" : point });
            var sketchPlane2 = plane(pointVertex, cSys.xAxis, cSys.zAxis);
            var sketch = newSketchOnPlane(context, sketchId, { "sketchPlane" : sketchPlane2 });
            skPolyline(sketch, portId, { "points" : ports, "constrained" : false });
            skSolve(sketch);
            var axisQuery = sketchEntityQuery(sketchId, EntityType.EDGE, portId ~ ".line0");
            revolveCut(context, id, sketch, sketchId, axisQuery);
        }
        opDeleteBodies(context, id + "delete_sketch", { "entities" : qCreatedBy(id + "sketch", EntityType.BODY) });
        // delete the sketch
    }, { /* default parameters */ });

function revolveCut(context is Context, id is Id, sketch is Sketch, sketchId is Id, axisQuery is Query)
{
    var sketchQuery = qSketchRegion(sketchId, false);
    //revolve cut
    revolve(context, sketchId + "revolve", {
                "operationType" : NewBodyOperationType.REMOVE,
                "entities" : qUnion([sketchQuery]),
                "axis" : qUnion([axisQuery]),
                "revolveType" : RevolveType.FULL,
                "defaultScope" : true });
}

const DEPTH_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.0381, 500],
            (centimeter) : 3.81,
            (millimeter) : 38.1,
            (inch) : 1.5 // set the default depth to 1.5 inch
        } as LengthBoundSpec;
&lt;/pre&gt;

&lt;p&gt;Screw Boss FeatureScript 原始碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
/*    
    Screw Boss

    This custom feature creates a common fastening feature in plastic part design.

    The Screw Boss is just one version of this type of fastening feature 
    and could be easily extended to include many other types. This was built
    to show that you can create complex, compound features easily.

    Version 1 - April 26, 2016 - Neil Cooke, Onshape Inc.
*/ 

FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

annotation { "Feature Type Name" : "Screw Boss" }
export const ScrewBoss = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Sketch points to place bosses", "Filter" : EntityType.VERTEX &amp;&amp; SketchObject.YES &amp;&amp; ConstructionObject.NO }
        definition.locations is Query;

        annotation { "Name" : "Boss style" }
        definition.style is BossStyle;

        if (definition.style == BossStyle.BLIND)
        {
            annotation { "Name" : "Boss height", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.height, BOSS_HEIGHT);
        }
        else
        {
            annotation { "Name" : "Parallel face or plane", "Filter" : EntityType.FACE, "MaxNumberOfPicks" : 1 }
            definition.parallelFace is Query;
        }

        annotation { "Name" : "Boss diameter", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.diameter, BOSS_DIA);

        annotation { "Name" : "Ribs", "Default" : true, "UIHint" : "DISPLAY_SHORT" }
        definition.hasRibs is boolean;

        if (definition.hasRibs == true)
        {
            annotation { "Name" : "Number of ribs (max 6)", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
            isInteger(definition.ribCount, RIB_COUNT_BOUNDS);

            annotation { "Name" : "Flip rib direction", "UIHint" : "OPPOSITE_DIRECTION" }
            definition.ribFlipDirection is boolean;

            annotation { "Name" : "Edge to define rib direction", "Filter" : EntityType.EDGE, "MaxNumberOfPicks" : 1 }
            definition.ribDirection is Query;

            annotation { "Name" : "Rib diameter at top", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.ribDiameter, RIB_DIA);

            annotation { "Name" : "Rib distance from top", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.ribHeight, RIB_HEIGHT);

            annotation { "Name" : "Rib thickness", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.ribThickness, RIB_THK);

            annotation { "Name" : "Chamfer", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"], "Default" : true }
            definition.hasChamfer is boolean;

            if (definition.hasChamfer == true)
            {
                annotation { "Name" : "Chamfer size", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
                isLength(definition.chamferSize, CHAMFER_SIZE);
            }
        }

        annotation { "Name" : "Hole diameter", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.holeDiam, HOLE_DIA);

        annotation { "Name" : "Wall thickness", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.wallThickness, WALL_THK);

        annotation { "Name" : "Draft", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"], "Default" : true }
        definition.hasDraft is boolean;

        if (definition.hasDraft == true)
        {
            annotation { "Name" : "Draft angle", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
            isAngle(definition.draftAngle, DRAFT_ANGLE);
        }

        annotation { "Name" : "Merge scope", "Filter" : EntityType.BODY &amp;&amp; BodyType.SOLID }
        definition.booleanScope is Query;
    }

    {
        // get all the user selected locations
        const locations = evaluateQuery(context, definition.locations);

        // if a solid body intersects the first point in the list, automatically use that in the merge scope
        const targetBody = evaluateQuery(context, qContainsPoint(qBodyType(qEverything(EntityType.BODY), BodyType.SOLID), evVertexPoint(context, { "vertex" : locations[0] })));

        if (size(targetBody) == 0 &amp;&amp; definition.booleanScope != undefined)
            definition.targetBody = definition.booleanScope; // if not, get user to select merge scope
        else
            definition.targetBody = targetBody[0];

        var sketchPlane is Plane = evOwnerSketchPlane(context, { "entity" : locations[0] });
        var topPlane;
        var ribPlane;

        // define the plane for the top of the boss
        if (definition.style == BossStyle.PLANE &amp;&amp; definition.parallelFace != undefined)
            topPlane = evPlane(context, { "face" : definition.parallelFace });
        else
            topPlane = plane(sketchPlane.origin + definition.height * sketchPlane.normal, sketchPlane.normal);

        var nameId = 1;

        definition.sketch = newSketchOnPlane(context, id + "sketch1", { "sketchPlane" : topPlane });

        // Build first feature - extruded circle
        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skCircle(definition.sketch, "circle" ~ nameId, {
                        "center" : vector(point[0], point[1]),
                        "radius" : definition.diameter / 2
                    });
            nameId += 1;
        }
        skSolve(definition.sketch);

        extrude(context, id + ("extrude1"), {
                    "entities" : qSketchRegion(id + "sketch1"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.ADD,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        // Build second feature - extruded ribs
        if (definition.hasRibs)
        {
            // define top of ribs
            ribPlane = plane(topPlane.origin - definition.ribHeight * topPlane.normal, topPlane.normal);

            var ribVector = vector(0, 1); // by default pointing up in Y

            // if user has defined rib direction, work out the vector
            if (definition.ribDirection != undefined)
            {
                const directionResult = try(evAxis(context, { "axis" : definition.ribDirection }));

                if (directionResult != undefined)
                    ribVector = normalize(vector(directionResult.direction[0], directionResult.direction[1]));
            }

            if (definition.ribFlipDirection)
                ribVector = ribVector * -1;

            definition.sketch = newSketchOnPlane(context, id + "sketch2", { "sketchPlane" : ribPlane });

            const ribPlaneCSys = planeToCSys(ribPlane);
            var chamferPoints = [];

            nameId = 1;

            for (var location in locations)
            {
                var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

                const center = vector(point[0], point[1]);

                // Build a closed "star" shaped sketch to represent the ribs
                for (var j = 0; j &lt; definition.ribCount; j += 1)
                {
                    var angle = (360 / definition.ribCount) * j * degree;

                    // The angle for each rib
                    var angledRibVector = vector(ribVector[0] * cos(angle) - ribVector[1] * sin(angle),
                        ribVector[0] * sin(angle) + ribVector[1] * cos(angle));

                    var perpRibVector = vector(angledRibVector[1] * -1, angledRibVector[0]);

                    var ribOffset = definition.ribThickness / 2 / tan(180 / definition.ribCount * degree);

                    if (definition.ribCount == 1)
                        ribOffset = 0 * meter;

                    var points = [
                        center - (definition.ribThickness / 2) * perpRibVector + (ribOffset) * angledRibVector,
                        center - (definition.ribThickness / 2) * perpRibVector + (definition.ribDiameter / 2) * angledRibVector,
                        center + (definition.ribThickness / 2) * perpRibVector + (definition.ribDiameter / 2) * angledRibVector,
                        center + (definition.ribThickness / 2) * perpRibVector + (ribOffset) * angledRibVector];

                    for (var i = 0; i &lt; size(points); i += 1)
                    {
                        skLineSegment(definition.sketch, "line" ~ nameId,
                                { "start" : points[i],
                                    "end" : points[(i + 1) % size(points)]
                                });
                        nameId += 1;
                    }

                    // Keep a list of the centerpoints of the edges where the chamfers may go
                    var chamferPoint2d = center + (definition.ribDiameter / 2) * angledRibVector;
                    chamferPoints = append(chamferPoints, toWorld(ribPlaneCSys, vector(chamferPoint2d[0], chamferPoint2d[1], 0 * meter)));
                }
                nameId += 1;
            }
            skSolve(definition.sketch);

            extrude(context, id + ("extrude2"), {
                        "entities" : qSketchRegion(id + "sketch2"),
                        "endBound" : BoundingType.UP_TO_BODY,
                        "endBoundEntityBody" : definition.targetBody,
                        "oppositeDirection" : true,
                        "hasDraft" : definition.hasDraft,
                        "draftAngle" : definition.draftAngle,
                        "draftPullDirection" : false,
                        "operationType" : NewBodyOperationType.ADD,
                        "defaultScope" : false,
                        "booleanScope" : definition.targetBody
                    });

            // Build third feature - chamfers
            if (definition.hasChamfer)
            {
                var chamferEdges = [];

                for (var i = 0; i &lt; size(chamferPoints); i += 1)
                {
                    // Find the edges that intersect the points previously collected
                    chamferEdges = append(chamferEdges, qContainsPoint(qCreatedBy(id + "extrude2", EntityType.EDGE), chamferPoints[i]));
                }

                try(opChamfer(context, id + "chamfer1", {
                                "entities" : qUnion(chamferEdges),
                                "chamferType" : ChamferType.EQUAL_OFFSETS,
                                "width" : definition.chamferSize
                            }));
            }
        }

        nameId = 1;

        // Build fourth feature - through hole to outside of part
        var holePlane = plane(topPlane.origin - definition.wallThickness * topPlane.normal, topPlane.normal);

        definition.sketch = newSketchOnPlane(context, id + "sketch3", { "sketchPlane" : holePlane });

        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skCircle(definition.sketch, "circle" ~ nameId, {
                        "center" : vector(point[0], point[1]),
                        "radius" : definition.diameter / 2 - definition.wallThickness
                    });
            nameId += 1;
        }
        skSolve(definition.sketch);

        extrude(context, id + ("extrude3"), {
                    "entities" : qSketchRegion(id + "sketch3"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.REMOVE,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        nameId = 1;

        // Build fifth feature - screw hole
        definition.sketch = newSketchOnPlane(context, id + "sketch4", { "sketchPlane" : topPlane });

        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skCircle(definition.sketch, "circle" ~ nameId, {
                        "center" : vector(point[0], point[1]),
                        "radius" : definition.holeDiam / 2
                    });
            nameId += 1;
        }
        skSolve(definition.sketch);

        extrude(context, id + ("extrude4"), {
                    "entities" : qSketchRegion(id + "sketch4"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.REMOVE,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        // Remove sketch entities - no longer required
        var sketches = [qCreatedBy(id + "sketch1"), qCreatedBy(id + "sketch2"), qCreatedBy(id + "sketch3"), qCreatedBy(id + "sketch4")];
        opDeleteBodies(context, id + "delete", { "entities" : qUnion(sketches) });

    }, {});

const BOSS_HEIGHT =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.02, 500],
            (centimeter) : 2.0,
            (millimeter) : 20.0,
            (inch) : 0.8
        } as LengthBoundSpec;

const BOSS_DIA =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.008, 500],
            (centimeter) : 0.8,
            (millimeter) : 8.0,
            (inch) : 0.3125
        } as LengthBoundSpec;

const RIB_COUNT_BOUNDS =
{
            "min" : 1,
            "max" : 6,
            (unitless) : [1, 4, 6]
        } as IntegerBoundSpec;

const RIB_DIA =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.015, 500],
            (centimeter) : 1.5,
            (millimeter) : 15.0,
            (inch) : 0.6
        } as LengthBoundSpec;

const RIB_HEIGHT =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [0, 0.005, 500],
            (centimeter) : 0.5,
            (millimeter) : 5.0,
            (inch) : 0.2
        } as LengthBoundSpec;

const RIB_THK =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.001, 500],
            (centimeter) : 0.1,
            (millimeter) : 1.0,
            (inch) : 0.04
        } as LengthBoundSpec;

const CHAMFER_SIZE =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.002, 500],
            (centimeter) : 0.2,
            (millimeter) : 2.0,
            (inch) : 0.08
        } as LengthBoundSpec;

const HOLE_DIA =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.003, 500],
            (centimeter) : 0.3,
            (millimeter) : 3.0,
            (inch) : 0.12
        } as LengthBoundSpec;

const WALL_THK =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.0015, 500],
            (centimeter) : 0.15,
            (millimeter) : 1.5,
            (inch) : 0.06
        } as LengthBoundSpec;

const DRAFT_ANGLE =
{
            "min" : -TOLERANCE.zeroAngle * radian,
            "max" : (2 * PI + TOLERANCE.zeroAngle) * radian,
            (degree) : [0, 2, 360],
            (radian) : 0.035
        } as AngleBoundSpec;

export enum BossStyle
{
    annotation { "Name" : "Blind" }
    BLIND,
    annotation { "Name" : "Up to face" }
    PLANE
}
&lt;/pre&gt;</summary><category term="CADLab"></category><category term="MCAD"></category></entry><entry><title>Onshape FeatureScript 程式語言 (一)</title><link href="http://cadlab.mde.tw/post/onshape-featurescript-cheng-shi-yu-yan-yi.html" rel="alternate"></link><updated>2016-05-31T10:17:16+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-31:post/onshape-featurescript-cheng-shi-yu-yan-yi.html</id><summary type="html">&lt;p&gt;接續上一篇文章, 整理目前 Onshape 已經釋出的 FeatureScript 相關應用範例.&lt;/p&gt;


&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/574941a2e4b05f50e871a75a/w/1c096ba7cb6b4bb6d74f8ffa/e/8c83ef9b92095a980e185cf8"&gt;Curve Pattern FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494139e4b04aa3f56f8243/w/cad51c78bef702f93d689668/e/0cfa9d7c4606e1f2ae32be16"&gt;Helix in Fill FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494120e4b04aa3f56f8206/w/d17e3ff3f757fabdb9084368/e/ab4048d5790d64d16e68e02d"&gt;3D Spline Fill FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494101e4b04aa3f56f81ed/w/b2ffdc215aff14ea3817b535/e/1626934c31793c1d4d18eb6f"&gt;Brick FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494096e4b05f50e871a70e/w/165ebc7b4103e5b6c91e3f5b/e/bfd58761a0e39c157f11bd42"&gt;Measure Distance FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/5749420ae4b04aa3f56f8288/w/ed9f79b9809ffe7610f9c537/e/aa01cfec5e04037e7ca611b7"&gt;Lighten FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Snap Hook FeatureScript 程式原始碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
/*    
    Snap Hook

    This custom feature creates a common fastening feature in plastic part design.

    The Snap Hook is just one version of this type of fastening feature 
    and could be easily extended to include many other types. This was built
    to show that you can create complex, compound features easily.

    Version 1 - April 26, 2016 - Neil Cooke, Onshape Inc.
*/ 

FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

annotation { "Feature Type Name" : "Snap Hook" }
export const SnapHook = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Sketch point locations", "Filter" : EntityType.VERTEX &amp;&amp; SketchObject.YES &amp;&amp; ConstructionObject.NO }
        definition.locations is Query;

        annotation { "Name" : "Height type" }
        definition.style is HookStyle;

        if (definition.style == HookStyle.BLIND)
        {
            annotation { "Name" : "Height", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.height, HOOK_HEIGHT);
        }
        else
        {
            annotation { "Name" : "Parallel face or plane", "Filter" : EntityType.FACE, "MaxNumberOfPicks" : 1 }
            definition.parallelFace is Query;
        }

        annotation { "Name" : "Width", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.hookWidth, HOOK_WIDTH);

        annotation { "Name" : "Flip direction", "UIHint" : "OPPOSITE_DIRECTION" }
        definition.hookFlipDirection is boolean;

        annotation { "Name" : "Edge to define direction", "Filter" : EntityType.EDGE, "MaxNumberOfPicks" : 1 }
        definition.hookDirection is Query;

        annotation { "Name" : "Thickness", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.hookThickness, HOOK_THK);

        annotation { "Name" : "Undercut depth", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.hookDepth, HOOK_THK);

        annotation { "Name" : "Lip height", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.flatHeight, HOOK_LIP);

        annotation { "Name" : "Insertion angle", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isAngle(definition.deflectionAngle, HOOK_ANGLE);

        annotation { "Name" : "Draft", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"], "Default" : true }
        definition.hasDraft is boolean;

        if (definition.hasDraft == true)
        {
            annotation { "Name" : "Draft angle", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
            isAngle(definition.draftAngle, ANGLE_STRICT_90_BOUNDS);

            annotation { "Name" : "Back face draft angle", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isAngle(definition.backDraftAngle, ANGLE_STRICT_90_BOUNDS);
        }
        annotation { "Name" : "Cutout", "Default" : true }
        definition.hasCutout is boolean;

        annotation { "Name" : "Merge scope", "Filter" : EntityType.BODY &amp;&amp; BodyType.SOLID }
        definition.booleanScope is Query;
    }

    {
        // get all the user selected locations
        const locations = evaluateQuery(context, definition.locations);

        // if a solid body intersects the first point in the list, automatically use that in the merge scope
        const targetBody = evaluateQuery(context, qContainsPoint(qBodyType(qEverything(EntityType.BODY), BodyType.SOLID), evVertexPoint(context, { "vertex" : locations[0] })));

        if (size(targetBody) == 0 &amp;&amp; definition.booleanScope != undefined)
            definition.targetBody = definition.booleanScope; // if not, get user to select merge scope
        else
            definition.targetBody = targetBody[0];

        var sketchPlane is Plane = evOwnerSketchPlane(context, { "entity" : locations[0] });
        var topPlane;

        var hookVector = vector(1, 0); // by default pointing across in x

        // if user has defined hook direction, work out the vector
        if (definition.hookDirection != undefined)
        {
            const directionResult = try(evAxis(context, { "axis" : definition.hookDirection }));

            if (directionResult != undefined)
                hookVector = normalize(vector(directionResult.direction[0], directionResult.direction[1]));
        }

        if (definition.hookFlipDirection)
            hookVector = hookVector * -1;

        // get vector perpendicular to hook direction
        var perpHookVector = vector(hookVector[1] * -1, hookVector[0]);

        // define the plane for the top of the boss
        if (definition.style == HookStyle.PLANE &amp;&amp; definition.parallelFace != undefined)
            topPlane = evPlane(context, { "face" : definition.parallelFace });
        else
            topPlane = plane(sketchPlane.origin + definition.height * sketchPlane.normal, sketchPlane.normal);

        var nameId = 1;
        var chamferPoints = [];
        var frontFacePoints = [];
        var backFacePoints = [];

        const sketch1 = newSketchOnPlane(context, id + "sketch1", { "sketchPlane" : topPlane });
        const sketch2 = newSketchOnPlane(context, id + "sketch2", { "sketchPlane" : topPlane });
        const sketch3 = newSketchOnPlane(context, id + "sketch3", { "sketchPlane" : topPlane });

        definition.depth = definition.hookDepth / tan(definition.deflectionAngle) + definition.flatHeight;

        // Build 3 sketches each with a rectangle
        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skRectangle(sketch1, "rectangleHook" ~ nameId, {
                        "firstCorner" : vector(point[0], point[1]) + (definition.hookWidth / 2) * hookVector,
                        "secondCorner" : vector(point[0], point[1]) - (definition.hookWidth / 2) * hookVector - definition.hookDepth * perpHookVector
                    });

            skRectangle(sketch2, "rectangleThickness" ~ nameId, {
                        "firstCorner" : vector(point[0], point[1]) - (definition.hookWidth / 2) * hookVector,
                        "secondCorner" : vector(point[0], point[1]) + (definition.hookWidth / 2) * hookVector + definition.hookThickness * perpHookVector
                    });

            skRectangle(sketch3, "completeRectangle" ~ nameId, {
                        "firstCorner" : vector(point[0], point[1]) - (definition.hookWidth / 2) * hookVector - definition.hookDepth * perpHookVector,
                        "secondCorner" : vector(point[0], point[1]) + (definition.hookWidth / 2) * hookVector + definition.hookThickness * perpHookVector
                    });

            // Keep a list of the centerpoints of the edges where the chamfers may go
            var chamferPoint2d = vector(point[0], point[1]) - definition.hookDepth * perpHookVector;
            if (definition.hasDraft)
            {
                chamferPoint2d = vector(point[0], point[1]) - (definition.hookDepth - definition.depth * tan(definition.draftAngle)) * perpHookVector;
            }
            chamferPoints = append(chamferPoints, toWorld(planeToCSys(topPlane), vector(chamferPoint2d[0], chamferPoint2d[1], definition.depth)));

            var backFacePoint2d = vector(point[0], point[1]) + definition.hookThickness * perpHookVector;
            backFacePoints = append(backFacePoints, toWorld(planeToCSys(topPlane), vector(backFacePoint2d[0], backFacePoint2d[1], 0 * meter)));
            frontFacePoints = append(frontFacePoints, toWorld(planeToCSys(topPlane), vector(point[0], point[1], 0 * meter)));

            nameId += 1;
        }
        skSolve(sketch1);
        skSolve(sketch2);
        skSolve(sketch3);

        extrude(context, id + ("extrude1"), {
                    "entities" : qSketchRegion(id + "sketch2"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "depth" : definition.depth,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.ADD,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        extrude(context, id + ("extrude2"), {
                    "entities" : qSketchRegion(id + "sketch3"),
                    "endBound" : BoundingType.BLIND,
                    "depth" : definition.depth,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : false,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : true,
                    "operationType" : NewBodyOperationType.ADD,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        var chamferEdges = [];

        for (var i = 0; i &lt; size(chamferPoints); i += 1)
        {
            // Find the edges that intersect the points previously collected
            chamferEdges = append(chamferEdges, qContainsPoint(qCreatedBy(id + "extrude2", EntityType.EDGE), chamferPoints[i]));
        }

        try(opChamfer(context, id + "chamfer1", {
                        "entities" : qUnion(chamferEdges),
                        "chamferType" : ChamferType.OFFSET_ANGLE,
                        "width" : definition.depth - definition.flatHeight,
                        "angle" : definition.deflectionAngle,
                        "oppositeDirection" : true
                    }));

        if (definition.hasDraft)
        {
            var backFaces = [];
            var frontFaces = [];

            for (var i = 0; i &lt; size(backFacePoints); i += 1)
            {
                // Find the edges that intersect the points previously collected
                backFaces = append(backFaces, qContainsPoint(qCreatedBy(id + "extrude1", EntityType.FACE), backFacePoints[i]));
                frontFaces = append(frontFaces, qContainsPoint(qCreatedBy(id + "extrude1", EntityType.FACE), frontFacePoints[i]));
            }

            opPlane(context, id + "plane1", {
                        "plane" : topPlane,
                        "size" : 0.1 * meter
                    });

            opDraft(context, id + "draft1", {
                        "neutralPlane" : qCreatedBy(id + "plane1", EntityType.FACE),
                        "pullVec" : topPlane.normal,
                        "draftFaces" : qUnion(frontFaces),
                        "angle" : 0 * degree
                    });

            opDraft(context, id + "draft2", {
                        "neutralPlane" : qCreatedBy(id + "plane1", EntityType.FACE),
                        "pullVec" : topPlane.normal,
                        "draftFaces" : qUnion(backFaces),
                        "angle" : definition.backDraftAngle + definition.draftAngle
                    });
        }

        if (definition.hasCutout)
        {
            extrude(context, id + ("extrude3"), {
                        "entities" : qSketchRegion(id + "sketch1"),
                        "endBound" : BoundingType.THROUGH_ALL,
                        "depth" : definition.depth,
                        "endBoundEntityBody" : definition.targetBody,
                        "oppositeDirection" : true,
                        "hasDraft" : definition.hasDraft,
                        "draftAngle" : definition.draftAngle,
                        "draftPullDirection" : false,
                        "operationType" : NewBodyOperationType.REMOVE,
                        "defaultScope" : false,
                        "booleanScope" : definition.targetBody
                    });
        }

        // Remove sketch entities and plane - no longer required
        var sketches = [qCreatedBy(id + "sketch1"), qCreatedBy(id + "sketch2"), qCreatedBy(id + "sketch3"), qCreatedBy(id + "plane1")];
        opDeleteBodies(context, id + "delete", { "entities" : qUnion(sketches) });

    }, {});

const HOOK_ANGLE =
{
            "min" : -TOLERANCE.zeroAngle * radian,
            "max" : (2 * PI + TOLERANCE.zeroAngle) * radian,
            (degree) : [15, 30, 60]
        } as AngleBoundSpec;

const HOOK_HEIGHT =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.015, 500],
            (centimeter) : 1.5,
            (millimeter) : 15.0,
            (inch) : 0.6
        } as LengthBoundSpec;

const HOOK_WIDTH =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.005, 500],
            (centimeter) : 0.5,
            (millimeter) : 5.0,
            (inch) : 0.2
        } as LengthBoundSpec;

const HOOK_THK =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.002, 500],
            (centimeter) : 0.2,
            (millimeter) : 2.0,
            (inch) : 0.08
        } as LengthBoundSpec;

const HOOK_LIP =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.001, 500],
            (centimeter) : 0.1,
            (millimeter) : 1.0,
            (inch) : 0.04
        } as LengthBoundSpec;

export enum HookStyle
{
    annotation { "Name" : "Blind" }
    BLIND,
    annotation { "Name" : "Up to face" }
    PLANE
}
&lt;/pre&gt;

&lt;p&gt;Fill Pattern FeatureScript 程式碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");
import(path : "onshape/std/transform.fs", version : "336.0");

/**
 * Performs a pattern of faces within a face. The instances are placed in a hexagonal pattern and no instances will be 
 * created that cross the boundary of the face. If a border is set then no instances are created within a border of that size
 * @param definition {{
 *      @field entities A collection of faces that will be patterned
 *      @field target A planar face that contains the 'entities' faces and that will contain the pattern
 *      @field direction Specifies the alignment of the pattern in the face
 *      @field distance The distance between the center of the instances
 *      @field border The width of the "exclusion zone" at the edge of the target face     
 * }}
 */
annotation { "Feature Type Name" : "Fill pattern", "Filter Selector" : "allparts" }
export const fillPattern = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Faces to pattern",
                     "Filter" : EntityType.FACE &amp;&amp; ConstructionObject.NO &amp;&amp; SketchObject.NO }
        definition.entities is Query;
        annotation { "Name" : "Target face", "Filter" : GeometryType.PLANE, "MaxNumberOfPicks" : 1 }
        definition.target is Query;
        annotation { "Name" : "Direction", "Filter" : QueryFilterCompound.ALLOWS_AXIS, "MaxNumberOfPicks" : 1 }
        definition.direction is Query;        
        annotation { "Name" : "Distance" }
        isLength(definition.distance, LENGTH_BOUNDS);
        annotation { "Name" : "Border" }
        isLength(definition.border, NONNEGATIVE_ZERO_DEFAULT_LENGTH_BOUNDS);
    }
    {
        var transforms = [];
        var instanceNames = [];

        var direction = try(evAxis(context, { "axis" : definition.direction })).direction;
        println(direction);
        var normal = try(evPlane(context, {
            "face" : definition.target
        })).normal;

        // For a hexagonal pattern we have two directions, with one being at an angle of 60 degrees from the other.
        // If we pattern in both those directions then we get a hexagonal pattern with equal spacing
        var vertical = cross(normal, direction);
        var angled = (direction * cos(60 * degree)) + (vertical * sin(60 * degree));

        // We want to get the edges of the target face so that we can get the distance from the face boundary
        // However, because the tool faces ought to be "in" the target face we don't want to count those
        // We can use booleans on the queries, which is pretty nice. We can also take the opportunity to ensure
        // that at least some edges are shared
        var allTargetEdges = qEdgeAdjacent(definition.target, EntityType.EDGE);
        var toolEdges = qEdgeAdjacent(definition.entities, EntityType.EDGE);
        var targetEdges = qSubtraction(allTargetEdges, toolEdges);
        var edgesInFace = qIntersection([allTargetEdges, toolEdges]);
        if (size(evaluateQuery(context, edgesInFace)) == 0) {
            throw regenError("The entities must share edges with the target face");
        }

        // To prevent excessive calculation we do a quick exclusion of faces based on bounding boxes
        // It doesn't need to be perfect. Get the box of the target face and of the shared edges
        var faceBox = try(evBox3d(context, {
            "topology" : definition.target
        }));
        var toolBox = try(evBox3d(context, {
            "topology" : edgesInFace
        }));

        // Again, to prevent excessive computation we will estimate the maximum number of instances and
        // fail early if we exceed some limit.
        var diagonal = faceBox.maxCorner - faceBox.minCorner;    
        var maximumIndex = round((norm(diagonal) - (definition.border * 2)) / definition.distance);
        var toolSize = norm(toolBox.maxCorner - toolBox.minCorner);
        var estimatedIndexCount = maximumIndex * maximumIndex;
        if (estimatedIndexCount &gt; 2500)
        {
            throw regenError("Too many instances in the pattern (estimate: " ~ 
                estimatedIndexCount ~ " ). Try a larger spacing.");
        }

        // Now we loop and look to see if the instance should be included
        for (var i = -maximumIndex; i &lt;= maximumIndex; i += 1)
        {
            for (var j = -maximumIndex; j &lt;= maximumIndex; j += 1)
            {
                if (abs(i) &lt; 0.5 &amp;&amp; abs(j) &lt; 0.5)
                {
                    // Zero transform = initial position =&gt; Skip
                    continue;
                }
                var translation = ((direction * i) + (angled * j)) * definition.distance;
                var instanceTransform = transform(translation);
                // Now that we have the transform we transform the tool box and see if it is within the face
                // but not too close to the edges of the face
                // Note: this isn't exact, it uses the center of the face and the size of the face box 
                // rather than transforming the geometry every time.
                var xformed = box3d(toolBox.minCorner + translation, toolBox.maxCorner + translation);
                if (clash(xformed, faceBox))
                {
                    var minDistance = evDistance(context, {
                            "side0" : targetEdges,
                            "side1" : (xformed.minCorner + xformed.maxCorner) * 0.5
                    });
                    // Note: if border is zero this still results in a border that is half the size of the tool,
                    // the border is additional on top of that
                    if (minDistance.distance &gt; (toolSize + definition.border))
                    {
                        transforms = append(transforms, instanceTransform);
                        instanceNames = append(instanceNames, "" ~ i ~ "." ~ j);
                    }
                }                
            }
        }

        // Now we set the data as needed by the applyPattern function before calling it.
        definition.patternType = PatternType.FACE;
        definition.transforms = transforms;
        definition.instanceNames = instanceNames;
        definition.seed = definition.entities;

        var remainingTransform = getRemainderPatternTransform(context, { "references" : definition.entities });
        applyPattern(context, id, definition, remainingTransform);
    }, { });

/**
 * Utility function to do a quick clash of boxes
 */
function clash(box1 is Box3d, box2 is Box3d) returns boolean
{
    for (var index = 0; index &lt; 3; index += 1)
    {
        var min1 = box1.minCorner[index];
        var max1 = box1.maxCorner[index];
        var min2 = box2.minCorner[index];
        var max2 = box2.maxCorner[index];
        // Comparisons to zero are never a good idea because values that are calculated separately are
        // rarely the same to machine precision. FeatureScript provides tolerant equality methods
        // but not tolerant inequalities. No matter, we can fashion one ourselves by checking the
        // inequality and excluding approximate equality
        if ((max1 &lt; min2 &amp;&amp; !tolerantEquals(max1, min2)) || (max2 &lt; min1 &amp;&amp; !tolerantEquals(max2, min1)))
        {
            return false;
        }
    }
    return true;
}
&lt;/pre&gt;

&lt;p&gt;Rib FeatureScript 程式碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

const RIB_THICKEN_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [0.0, 0.005, 500],
            (centimeter) : 0.5,
            (millimeter) : 5.0,
            (inch) : 0.25,
            (foot) : 0.025,
            (yard) : 0.01
        } as LengthBoundSpec;

/**
 * Specifies the direction of the rib extrusion starting from the profile
 * going up to the part.
 *
 * @value NORMAL_TO_SKETCH_PLANE : The direction of the rib extrusion goes normal to the profile sketch plane.
 * @value PARALLEL_TO_SKETCH_PLANE : The direction of the rib extrusion goes parallel to the profile sketch plane.
 */
export enum RibExtrusionDirection
{
    annotation { "Name" : "Normal to sketch plane" }
    NORMAL_TO_SKETCH_PLANE,
    annotation { "Name" : "Parallel to sketch plane" }
    PARALLEL_TO_SKETCH_PLANE
}

function isClosed(context is Context, edge is Query) returns boolean
{
    return size(evaluateQuery(context, qVertexAdjacent(edge, EntityType.VERTEX))) &lt; 2;
}

annotation { "Feature Type Name" : "Rib" }
export const rib = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Sketch profiles", "Filter" : EntityType.EDGE &amp;&amp; SketchObject.YES &amp;&amp; ConstructionObject.NO }
        definition.profiles is Query;

        annotation { "Name" : "Parts", "Filter" : EntityType.BODY }
        definition.parts is Query;

        annotation { "Name" : "Thickness" }
        isLength(definition.thickness, RIB_THICKEN_BOUNDS);

        annotation { "Name" : "Rib extrusion direction" }
        definition.ribExtrusionDirection is RibExtrusionDirection;

        annotation { "Name" : "Opposite direction", "UIHint" : "OPPOSITE_DIRECTION", "Default" : true }
        definition.oppositeDirection is boolean;

        annotation { "Name" : "Extend profiles up to part" }
        definition.extendProfilesUpToPart is boolean;

        annotation { "Name" : "Merge ribs", "Default" : true }
        definition.mergeRibs is boolean;
    }
    {
        const profiles = evaluateQuery(context, definition.profiles);
        const numberOfRibs = size(profiles);
        if (profiles == [])
        {
            throw regenError("Select sketch profiles for the rib contours");
        }

        if (evaluateQuery(context, definition.parts) == [])
        {
            throw regenError("Select parts where the rib will be fitted into");
        }

        // Create a transform for making the feature patternable via feature pattern.
        var remainingTransform = getRemainderPatternTransform(context,
                {"references" : qUnion([definition.profiles, definition.parts])});

        // Before evaluating the profiles to create the ribs, we find out how big the parts are
        // so if any extending is necessary for any rib end, we know how far we need to extend.
        // To ensure the extended profile will always go past the part(s), we use the
        // diagonal of the bounding box of the part(s) and profile(s) as the extend length.
        const partBoundingBox = evBox3d(context, {
                    "topology" : qUnion([definition.parts, definition.profiles])
                });
        const extendLength = norm(partBoundingBox.maxCorner - partBoundingBox.minCorner);

        // Create each rib (one rib per profile) as its own body.

        for (var i = 0; i &lt; numberOfRibs; i += 1)
        {
            const profile = profiles[i];
            const thickenId = id + (i ~ "thickenRib");

            try
            {
                // Keep track of the entities we will extrude as a surface which will later
                // be thickened to create the rib.  The profile and any
                // profile extensions will need to be included in the extrude operation.
                var entitiesToExtrude = [profile];

                // Get the endpoints of the profile and the normal direction at those endpoints
                // so we can determine what needs to be extended and what direction to extend.
                const profileEndTangentLines = evEdgeTangentLines(context, {
                            "edge" : profile,
                            "parameters" : [0, 1],
                            "arcLengthParameterization" : false
                        });

                // There  are 2 reasons we might need to extend the given profiles:
                // 1.  If the profile touches the part(s), make an extension of the profile past the part to ensure
                //     that there are no gaps when we thicken the profile (this can happen if the profile is not normal
                //     to the part where they intersect).
                // 2.  The extend profiles up to part checkbox has been selected.
                const partsContainPoint = function(point is Vector) returns boolean
                    {
                        return evaluateQuery(context, qContainsPoint(definition.parts, remainingTransform * point)) != [];
                    };

                var extendProfiles = makeArray(2);
                var extendedEndPoints = makeArray(2);
                const extendDirections = [-profileEndTangentLines[0].direction, profileEndTangentLines[1].direction];

                // If the profile is closed, then there is nothing to extend.
                const isProfileClosed = isClosed(context, profile);

                for (var end in [0, 1]) // Potentially extend both endpoints of the profile curve
                {
                    extendProfiles[end] = !isProfileClosed &amp;&amp; definition.extendProfilesUpToPart || partsContainPoint(profileEndTangentLines[end].origin);
                    if (extendProfiles[end])
                    {
                        extendedEndPoints[end] = profileEndTangentLines[end].origin + (extendDirections[end] * extendLength);
                        // This is actually a quick way to create a line in 3D
                        opFitSpline(context, id + (i ~ "extendProfile" ~ end), {
                                    "points" : [
                                            profileEndTangentLines[end].origin,
                                            extendedEndPoints[end]
                                        ]
                                });
                        entitiesToExtrude = append(entitiesToExtrude, qCreatedBy(id + (i ~ "extendProfile" ~ end), EntityType.EDGE));
                    }
                }

                // Find the direction to extrude a surface that will later be thickened to produce the rib.
                // First determine the normal or parallel direction, then, if specified,
                // choose the opposite of the normal or parallel direction.
                const profilePlane = evOwnerSketchPlane(context, { "entity" : profile });
                var ribDirection;
                if (definition.ribExtrusionDirection == RibExtrusionDirection.PARALLEL_TO_SKETCH_PLANE)
                {
                    // To get the parallel direction with the sketch plane, find the direction perpendicular
                    // to the sketch plane normal and the line that connects the start and end point of the profile.
                    const profileDirection = normalize(profileEndTangentLines[1].origin - profileEndTangentLines[0].origin);
                    ribDirection = cross(profilePlane.normal, profileDirection);
                }
                else
                {
                    ribDirection = profilePlane.normal;
                }

                if (definition.oppositeDirection)
                {
                    ribDirection = ribDirection * -1;
                }

                // Extrude a surface from the extended profile into the part(s), using the extend length
                // as the extrude depth to make sure the surface goes through the part(s).
                opExtrude(context, id + (i ~ "surfaceExtrude"), {
                            "entities" : qUnion(entitiesToExtrude),
                            "direction" : ribDirection,
                            "endDepth" : extendLength,
                            "endBound" : BoundingType.BLIND
                        });

                // Transform the extruded surface if needed to support feature pattern.
                transformResultIfNecessary(context, id + (i ~ "surfaceExtrude"), remainingTransform);

                // Thicken the surface to make the rib plus some excess material around the part(s).
                const halfThickness = definition.thickness / 2;
                opThicken(context, thickenId, {
                            "entities" : qCreatedBy(id + (i ~ "surfaceExtrude"), EntityType.FACE),
                            "thickness1" : halfThickness,
                            "thickness2" : halfThickness
                        });

                // Split the rib with the part(s) to separate the rib body from the thicken excess.
                var ribPartsQuery = qCreatedBy(thickenId, EntityType.BODY);
                opBoolean(context, id + (i ~ "splitOffRibExcess"), {
                            "tools" : definition.parts,
                            "targets" : ribPartsQuery,
                            "operationType" : BooleanOperationType.SUBTRACTION,
                            "keepTools" : true
                        });

                // Apply the remaining transform to the profile before doing collision testing.
                patternTransform(context, id + (i ~ "tr1"), profile, remainingTransform);
                // Do collision testing to help determine which parts of the thicken are excess.
                var clashes = evCollision(context, {
                        "tools" : ribPartsQuery,
                        "targets" : profile
                    });

                // Since we don't want the profile to actually move
                // move it back to it's original location after checking for collisions.
                patternTransform(context, id + (i ~ "tr2"), profile, inverse(remainingTransform));
                var clashBodies = mapArray(clashes, function(clash)
                {
                    return clash.toolBody;
                });

                // Specify a point at the end of the surface extrude.
                // Any thicken body that intersects with this point is excess.
                const surfaceExtrudeEndPoint = profileEndTangentLines[0].origin + (extendLength * ribDirection);

                // Collect up all the thicken excess and any other entities we've created leading
                // up to the thicken operation, because all of these need to be deleted.
                var entitiesToDelete = [
                    // Remove rib thicken excess sections that don't intersect the original profile.
                    qSubtraction(ribPartsQuery, qUnion(clashBodies)),

                    // Remove rib thicken excess sections that extend all the way to the end of
                    // the surface extrude (which we deliberately had extend well past the part,
                    // i.e. well past where a rib should be created).
                    qContainsPoint(ribPartsQuery, remainingTransform * surfaceExtrudeEndPoint),

                    // Remove the surface extrude, now that the thicken is completed and we don't need it anymore.
                    qCreatedBy(id + (i ~ "surfaceExtrude"), EntityType.BODY)
                ];

                // Delete any profile extensions created now that we don't need them anymore.
                // Also, any thicken section that intersects with the far end of an extension
                // (i.e. not the end that intersects with the profile) is thicken excess and should be deleted.
                for (var end in [0, 1])
                {
                    if (extendProfiles[end])
                    {
                        entitiesToDelete = append(entitiesToDelete, qCreatedBy(id + (i ~ "extendProfile" ~ end), EntityType.BODY));
                        entitiesToDelete = append(entitiesToDelete, qContainsPoint(ribPartsQuery, extendedEndPoints[end]));
                    }
                }

                opDeleteBodies(context, id + (i ~ "deleteRibExcess"), {
                            "entities" : qUnion(entitiesToDelete)
                        });
            }
            catch
            {
                throw regenError('Failed to create a rib from a selected profile.',
                        profile);
            }

            // Fail early if the rib body can't be created.
            if (evaluateQuery(context, qCreatedBy(thickenId, EntityType.BODY)) == [])
            {
                throw regenError('Selected profile did not produce a rib body.  Make sure the rib direction and alignment are correct.',
                        profile);
            }
        }

        // Optionally, merge the new ribs with the original parts.
        if (definition.mergeRibs)
        {
            // The original parts are first in the tools query so that they
            // will maintain their names.
            var toMerge = [definition.parts];
            for (var i = 0; i &lt; numberOfRibs; i += 1)
            {
                toMerge = append(toMerge, qCreatedBy(id, EntityType.BODY));
            }

            try
            {
                opBoolean(context, id + "mergeRibsWithParts", {
                            "tools" : qUnion(toMerge),
                            "operationType" : BooleanOperationType.UNION
                        });
            }
            catch
            {
                throw regenError('Failed to merge ribs into parts.');
            }
        }
    },
        {
            oppositeDirection : true,
            ribExtrusionDirection : RibExtrusionDirection.NORMAL_TO_SKETCH_PLANE,
            extendProfilesUpToPart : false,
            mergeRibs : true
        });

function patternTransform(context, id, query, transform)
{
    if (transform == identityTransform())
        return;
    opTransform(context, id, {
            "bodies" : qOwnerBody(query),
            "transform" : transform
    });
}
&lt;/pre&gt;</summary><category term="CADLab"></category><category term="MCAD"></category></entry><entry><title>雲端平台上的電腦輔助機械設計</title><link href="http://cadlab.mde.tw/post/yun-duan-ping-tai-shang-de-dian-nao-fu-zhu-ji-jie-she-ji.html" rel="alternate"></link><updated>2016-05-28T07:05:43+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-28:post/yun-duan-ping-tai-shang-de-dian-nao-fu-zhu-ji-jie-she-ji.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.onshape.com/"&gt;Onshape&lt;/a&gt; 在 &lt;a href="http://wordpress-2015course.rhcloud.com/?p=4514"&gt;2015年12月&lt;/a&gt;正式全面對外公開之後, 已經啟動電腦輔助機械設計的雲端世代, 為了追求高效能的全球協同產品設計流程, 利用跨硬體裝置, 免安裝, 具備設計特徵版次管理, 而且提供類似 &lt;a href="https://cad.onshape.com/FsDoc/"&gt;Featurescript&lt;/a&gt; 客製化功能建構環境 (i.e. Feature Studio) 的全雲端電腦輔助機械設計工具, 將會日漸完備.&lt;/p&gt;


&lt;p&gt;面對 Onshape 的破壞性創新產品挑戰, SolidWorks 也以採用 &lt;a href="http://www.3ds.com/about-3ds/3dexperience-platform/"&gt;3dexperience platform&lt;/a&gt; 核心技術為主體, 推出全新的全雲端產品: &lt;a href="http://xdesign.solidworks.com/"&gt;Xdesign&lt;/a&gt; 回應.&lt;/p&gt;
&lt;p&gt;目前, SolidWorks 單機版約佔全球市場&lt;a href="http://blog.cnccookbook.com/2015/01/20/results-2015-cad-survey/"&gt;超過五分之一&lt;/a&gt;, 未來將與自家的 Xdesign 與 Onshape 免安裝全雲端產品, 競逐全球電腦輔助機械設計軟體市場. &lt;/p&gt;
&lt;p&gt;因此, 2016 年可以說是電腦輔助機械設計的雲端元年, 正好比 2006 年推出的 &lt;a href="https://en.wikipedia.org/wiki/Google_Docs,_Sheets,_and_Slides"&gt;Google Doc&lt;/a&gt;, 晚了十年.&lt;/p&gt;</summary><category term="CADLab"></category><category term="MCAD"></category></entry><entry><title>電腦輔助設計室的電腦開機磁區設置</title><link href="http://cadlab.mde.tw/post/dian-nao-fu-zhu-she-ji-shi-de-dian-nao-kai-ji-ci-qu-she-zhi.html" rel="alternate"></link><updated>2016-05-27T21:00:27+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-27:post/dian-nao-fu-zhu-she-ji-shi-de-dian-nao-kai-ji-ci-qu-she-zhi.html</id><summary type="html">&lt;p&gt;第1磁區: Windows 10 Pro + &lt;a href="https://msdn.microsoft.com/zh-tw/virtualization/hyperv_on_windows/quick_start/walkthrough_install"&gt;Hyper-V&lt;/a&gt; 安裝 Windows 7 Professional&lt;/p&gt;
&lt;p&gt;第2磁區: Windows 10 Pro + 可攜免安裝程式套件&lt;/p&gt;
&lt;p&gt;第3磁區: &lt;a href="http://releases.ubuntu.com/16.04/"&gt;Ubuntu 16.04&lt;/a&gt; Server + ubuntu-desktop&lt;/p&gt;


&lt;p&gt;第1磁區擬舀採 Windows 10 Pro 開機, 並安裝常用的 CAD/CAE/CAM 相關軟體套件的安裝為主, 針對無法在 Windows 10 Pro 執行的套件, 則建議安裝在 Hyper-V 模式下的 Windows 7 Professional 開機磁區中.&lt;/p&gt;
&lt;p&gt;第1磁區的網路設置以純 IPV4 為主, 並將最後一排的 9 台電腦, 以 IPV4/IPV6 雙支援的固定 IP 啟動 Ubuntu + &lt;a href="http://www.squid-cache.org/"&gt;Squid&lt;/a&gt; (選擇第3磁區開機), 讓上課師生自行選擇開機後透過 &lt;a href="https://en.wikipedia.org/wiki/Round-robin_DNS"&gt;Round Robin DNS&lt;/a&gt; 配置域名的代理主機增速上網.&lt;/p&gt;
&lt;p&gt;第2磁區擬採 Windows 10 Pro 開機, 並全數使用無需安裝的程式套件, 以提升套件使用效能, 網路配置則彈性配置純 IPV4 或純 IPV6 位址上網, 當採用純 IPV6 上網時, 必須啟動電腦輔助設計室中的 9 台 IPV4/IPV6 雙支援代理主機 (以 Ubuntu 磁區開機).&lt;/p&gt;</summary><category term="CADLab"></category><category term="Windows 10"></category></entry><entry><title>大學教育政策白皮書讀後心得報告</title><link href="http://cadlab.mde.tw/post/da-xue-jiao-yu-zheng-ce-bai-pi-shu-du-hou-xin-de-bao-gao.html" rel="alternate"></link><updated>2016-05-21T23:52:49+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-21:post/da-xue-jiao-yu-zheng-ce-bai-pi-shu-du-hou-xin-de-bao-gao.html</id><summary type="html">&lt;p&gt;15 年前寫的&lt;a href="http://cad-lab.github.io/cadlab_data/files/90.07_taiwan_univ_white_paperpdf"&gt;大學教育政策白皮書&lt;/a&gt;讀後心得報告&lt;/p&gt;


&lt;p&gt;科技大學的本質在教導學生獲得知識的能力，二十一世紀知識經濟最大的特色，在於必須將知識迅速化為商品，由於市場全球化的影響，未能即時將本身所擁有的知識，快速轉化為商品，並被市場接受的企業，終將難逃被時代淘汰的命運，企業如此，教育界也正面臨同樣的挑戰。&lt;/p&gt;
&lt;p&gt;教育部將大學的競爭力，視為國家競爭力的重要指標，全國各大學面對社會多元化的需求與全民終身學習的發展趨勢，如何在「大學教育政策白皮書」的基本方針下，強化各校的競爭力，建立各校的重點特色，便成為各大學今後所賴以生存的重要關鍵。&lt;/p&gt;
&lt;p&gt;事實上，「大學教育政策白皮書」中所提到的觀點，或許是台灣一般大學與科技大學所共同面臨的問題，但，就基本體制上，仍然要有所區分，方能貫徹彼此的教育目標，為社會的現在與未來，提供充足的人力資源。吾人以為，一般大學的最高目標在追求學術的卓越，而科技大學則必須掌握技術的領先，學術強調的是其具備未來的主導性，卓越的學術指的是高瞻遠矚，是未來有用的技術；而技術的領先是要培養能馬上為企業所用的科技尖兵，是能馬上將知識轉化為商品的創新發明家。也許，隨著科技進化的速度日益增快，學術與技術的區隔，也就變得越來越小，但一般大學與科技大學應有的角色與定位，仍不失為各大學爭取重點特色時，所應強調的重點。&lt;/p&gt;
&lt;p&gt;最後，談到本校在通過改名為科技大學後，如何在「大學教育政策白皮書」的指導方針下，爭取市場定位，並積極發展出屬於自己的特色，吾人以為，必須要先從小處做起，慢慢往大處做；必須要先由內做起，然後再漸漸往外落實。小處在哪裡，必須先用科學化與合理化來管理學校的每一個角落，然後才能談替企業診斷，為財團解憂。必須要先在校內建立起知識經濟的體系，然後才有可能與社會上全民學習的脈動相結合。未來，全球化經濟發展的趨勢或許很難臆測，但本校單類多科的包袱，如何逐步轉化為本校的重點特色，將是一項嚴酷的考驗，成敗的關鍵，就看現在。&lt;/p&gt;</summary><category term="大學教育"></category></entry><entry><title>Onshape 即將釋出 Featurescript 程式語言</title><link href="http://cadlab.mde.tw/post/onshape-ji-jiang-shi-chu-featurescript-cheng-shi-yu-yan.html" rel="alternate"></link><updated>2016-05-18T22:07:03+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-18:post/onshape-ji-jiang-shi-chu-featurescript-cheng-shi-yu-yan.html</id><summary type="html">&lt;p&gt;今天早上參加 Onshape 在台灣所舉行的首次實體論壇，除了持續感受到 Onshape 團隊滿滿的誠意外，最大的收穫就是得知 Featurescript 特徵程式語言，即將開放各界使用。&lt;/p&gt;


&lt;p&gt;所謂的 Featurescript， 根據了解，是一種可以透過 Feature Studio， 讓使用者修改或延伸 Onshape 特徵指令的新程式語言，據悉，目前 Onshape 所指供的特徵指令功能，也是透過 Featurescript 打造。&lt;/p&gt;
&lt;p&gt;並且，未來使用者所打造的各式客製化 Featurescript 程式，可以在 Onshape App store 中免費公開或販售。&lt;/p&gt;</summary><category term="Onshape"></category><category term="Featurescript"></category></entry></feed>