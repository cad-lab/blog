<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>CADLab (虎尾科大MDE)</title><link href="http://cadlab.mde.tw/post/" rel="alternate"></link><link href="http://cadlab.mde.tw/post/feeds/misc.atom.xml" rel="self"></link><id>http://cadlab.mde.tw/post/</id><updated>2016-07-01T23:03:06+08:00</updated><entry><title>Jupyterhub oauth2 登入設定</title><link href="http://cadlab.mde.tw/post/jupyterhub-oauth2-deng-ru-she-ding.html" rel="alternate"></link><updated>2016-07-01T23:03:06+08:00</updated><author><name>Cad Lab</name></author><id>tag:cadlab.mde.tw,2016-07-01:post/jupyterhub-oauth2-deng-ru-she-ding.html</id><summary type="html">&lt;p&gt;當機械設計工程師精熟了 Matlab 與 Mathematica 之後, 若想更進一步了解這些數值運算工具的整體架構, 可以試著在實體機或虛擬機器 (或 Docker 容器) 上架設自由開源的 Jupyterhub, 好按照各自研發團隊的需求, 打造永續的設計運算生態系統.&lt;/p&gt;


&lt;p&gt;&lt;a href="http://jupyter.org/"&gt;http://jupyter.org/&lt;/a&gt; 是一套支援&lt;a href="https://github.com/ipython/ipython/wiki/IPython-kernels-for-other-languages"&gt;超過 40 種&lt;/a&gt;程式語言的開源互動式資料運算平台, 而 &lt;a href="https://github.com/jupyterhub/jupyterhub"&gt;Jupyterhub&lt;/a&gt; 則是一套提供多人使用 Jupyter 的網際數值運算伺服器.&lt;/p&gt;
&lt;p&gt;這裡要介紹的是如何利用 Github 或 Google 帳號登入到團隊間所架設的 Jupyterhub 主機.&lt;/p&gt;
&lt;h3&gt;Jupyterhub 安裝&lt;/h3&gt;
&lt;p&gt;如 &lt;a href="http://cadlab.mde.tw/post/chun-ipv6-huan-jing-xia-an-zhuang-jupyterhub.html"&gt;http://cadlab.mde.tw/post/chun-ipv6-huan-jing-xia-an-zhuang-jupyterhub.html&lt;/a&gt; 中的說明, 可以利用下列指令安裝 Jupyter:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
sudo apt-get install npm nodejs-legacy
sudo apt-get install python3-pip
sudo pip3 install jupyterhub
sudo pip3 install notebook
sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout jupyterhub.key -out jupyterhub.crt
&lt;/pre&gt;

&lt;p&gt;完成後, 就可以利用 jupyterhub --port 9443 --ssl-key jupyterhub.key --ssl-cert jupyterhub.crt 啟動, 然後以瀏覽器連接後
, 用伺服器機器系統帳號登入, 此時啟動的 Jupyterhub 完全採用內建的設定啟用.&lt;/p&gt;
&lt;h3&gt;設定 Github 與 Google 帳號&lt;/h3&gt;
&lt;p&gt;接下來要按照 &lt;a href="https://github.com/jupyterhub/oauthenticator"&gt;https://github.com/jupyterhub/oauthenticator&lt;/a&gt; 中的說明, 利用 Github 與 Google 帳號, 分別註冊 &lt;a href="https://github.com/settings/applications/new"&gt;https://github.com/settings/applications/new&lt;/a&gt; 與 &lt;a href="https://console.developers.google.com"&gt;https://console.developers.google.com&lt;/a&gt; 的網際應用程式開發設定, 主要的操作, 在根據 &lt;a href="https://github.com/jupyterhub/oauthenticator"&gt;https://github.com/jupyterhub/oauthenticator&lt;/a&gt; 程式模組的設計, 從 Jupyterhub 登入時, 分別跳轉到 Github 或 Google 的登入流程, 待使用者完成登入並同意取用基本的帳號資料後, 即轉回 Jupyterhub 的回呼函式, 然後再按照 Jupyterhub 的啟動設定, 將使用者導向特定的 Jupyterhub 中的筆記本工作環境.&lt;/p&gt;
&lt;h3&gt;安裝 oauthenticator&lt;/h3&gt;
&lt;p&gt;第 1 步要先安裝 oauthenticator：&lt;/p&gt;
&lt;p&gt;sudo pip3 install oauthenticator&lt;/p&gt;
&lt;p&gt;接著處理 Github 的網際延伸程式開發設定, 必須先登入到 Github 帳號, 然後進入 &lt;a href="https://github.com/settings/applications/new"&gt;https://github.com/settings/applications/new&lt;/a&gt;, 註冊一個新的 OAuth 應用程式, 如下圖所示:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201607/jupyterhub_github_oauth_1.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;其中最重要的就是 https://your.server.domain:9443/hub/oauth_callback, 這是 &lt;a href="https://github.com/jupyterhub/oauthenticator"&gt;https://github.com/jupyterhub/oauthenticator&lt;/a&gt; 模組中所選定的回呼函式連結. 完成後 ,只需要在 Jupyterhub_config.py 設定中加上:&lt;/p&gt;
&lt;pre class="brush:python"&gt;
c.JupyterHub.authenticator_class = 'oauthenticator.LocalGitHubOAuthenticator'
c.GitHubOAuthenticator.oauth_callback_url = 'https://your.server.domain:9443/hub/oauth_callback' 
c.GitHubOAuthenticator.client_id = 'your_github_oauth_application_client_id'
c.GitHubOAuthenticator.client_secret = 'your_github_oauth_application_client_secret'
&lt;/pre&gt;

&lt;p&gt;重新啟動後的 Jupyterhub, 就會將登入導向 Github, 之後再透過回呼函式進入 Jupyterhub 環境. 這裡必須特別注意的是, Github 尚未全面支援 IPV6, 因此導向 Github Oauth2 登入, 目前只適用於 IPV4 主機.&lt;/p&gt;
&lt;h3&gt;Google OAuth 設定&lt;/h3&gt;
&lt;p&gt;轉用 Google OAuth 登入的作法也很類似, 首先登入 Google 帳號, 進入 &lt;a href="https://console.developers.google.com"&gt;https://console.developers.google.com&lt;/a&gt; 後, 在 API manager 處建立一個網際應用程式開發授權認証, 完成後, 在 Jupyterhub_config.py 設定中加上:&lt;/p&gt;
&lt;pre class="brush:python"&gt;
c.JupyterHub.authenticator_class = 'oauthenticator.LocalGoogleOAuthenticator'
c.GoogleOAuthenticator.oauth_callback_url = 'https://your.server.domain:9443/hub/oauth_callback' 
c.GoogleOAuthenticator.client_id = 'your_google_oauth_client_id'
c.GoogleOAuthenticator.client_secret = 'your_google_oauth_client_secret'
c.GoogleOAuthenticator.hosted_domain = 'your.hosted.domain'
c.GoogleOAuthenticator.login_service = 'your hosted service title'
&lt;/pre&gt;

&lt;p&gt;啟動後的 Jupyterhub, 就會將登入導向 Google, 之後再透過回呼函式進入 Jupyterhub 環境. 而且 Google 目前的所有服務已經全面支援 IPV6, 因此適用純 IPV6 的伺服主機.&lt;/p&gt;
&lt;p&gt;下圖就是登入 Gmail 帳號, 進入 &lt;a href="https://console.developers.google.com"&gt;https://console.developers.google.com&lt;/a&gt; 後, 準備建立 Oauth Client 認証註冊的畫面:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201607/jupyterhub_google_oauth_1.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;下圖顯示, 這裡要註冊的 Client ID 類別為 Web Application:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201607/jupyterhub_google_oauth_2.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;接著在登記建立應用程式的認証流程中, 輸入 Authorized Javascript origin: https://your.server.domain:9443, 以及 Authorized redirect URI: https://your.server.domain:9443/hub/oauth_callback, 設置完成後, 即可取得與網際應用程式對應的 Client_id 與 Client_secret.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201607/jupyterhub_google_oauth_3.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;完成設定後的登入畫面如下, 由於此台測試機採純 IPV6 位址上網, 只有啟動 IPV6 上網設置的客戶端或透過 IPV4/IPV6 雙支援的代理主機才能擷取.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201607/jupyterhub_google_oauth_4.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;以下則是 Jupyterhub_config.py 設定檔案內容:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
# jupyterhub_config.py
# jupyterhub -f /etc/jupyterhub/jupyterhub_config.py
c = get_config()

import os
pjoin = os.path.join

runtime_dir = os.path.join('/srv/jupyterhub')
ssl_dir = pjoin(runtime_dir, 'ssl')
if not os.path.exists(ssl_dir):
    os.makedirs(ssl_dir)

# https on :9443
c.JupyterHub.port = 9443
c.JupyterHub.ip = '2001:288::8888'
#c.JupyterHub.proxy_api_ip = '2001:288::8888'
c.JupyterHub.ssl_key = pjoin(ssl_dir, 'jupyterhub.key')
c.JupyterHub.ssl_cert = pjoin(ssl_dir, 'jupyterhub.crt')

# put the JjupyterHub cookie secret and state db
# in /var/run/jupyterhub
c.JupyterHub.cookie_secret_file = pjoin(runtime_dir, 'jupyterhub_cookie_secret')
c.JupyterHub.db_url = pjoin(runtime_dir, 'jupyterhub.sqlite')

# or `--db=/path/to/jupyterhub.sqlite` on the command-line

# put the log file in /var/log
c.JupyterHub.extra_log_file = '/var/log/jupyterhub.log'

# use Google OAuthenticator for local users
c.JupyterHub.authenticator_class = 'oauthenticator.LocalGoogleOAuthenticator'
c.GoogleOAuthenticator.oauth_callback_url = 'https://your.server.domain:9443/hub/oauth_callback' 
c.GoogleOAuthenticator.client_id = 'your_google_oauth_client_id'
c.GoogleOAuthenticator.client_secret = 'your_google_oauth_client_secret'
c.GoogleOAuthenticator.hosted_domain = 'your.hosted.domain'
c.GoogleOAuthenticator.login_service = 'your hosted service title'

'''
# use Github OAuthenticator for local users (not compatible with IPV6 service yet)
c.JupyterHub.authenticator_class = 'oauthenticator.LocalGitHubOAuthenticator'
c.GitHubOAuthenticator.oauth_callback_url = 'https://your.server.domain:9443/hub/oauth_callback' 
c.GitHubOAuthenticator.client_id = 'your_github_oauth_application_client_id'
c.GitHubOAuthenticator.client_secret = 'your_github_oauth_application_client_secret'
'''
# create system users that don't exist yet
c.LocalAuthenticator.create_system_users = True

# specify users and admin
# needed for LocalGitHubOAuthenticator
c.Authenticator.whitelist = {'u_admin1', 'u_admin2', 'u_scrum1', 'u_scrum2'}
c.Authenticator.admin_users = {'u_admin1','u_admin2'}

# start single-user notebook servers in ~/assignments,
# with ~/assignments/Welcome.ipynb as the default landing page
# this config could also be put in
# /etc/ipython/ipython_notebook_config.py
#c.Spawner.notebook_dir = '~/tmp'
c.Spawner.notebook_dir = '/home/notebook'
#c.Spawner.args = ['--NotebookApp.default_url=/notebooks/Welcome.ipynb']
&lt;/pre&gt;

&lt;p&gt;由上面的設定檔案可以得知, 能登入 Jupyterhub 的帳號位於 c.Authenticator.whitelist 中, 且管理者則列入 c.Authenticator.admin_users 設定.&lt;/p&gt;
&lt;p&gt;至於與上述設定配合的 Google 認証模組的程式碼位於: /usr/local/lib/python3.4/dist-packages/oauthenticator/google.py, 管理者可以仔細了解下列程式碼的運作流程, 並配合團隊的需求進行修改.&lt;/p&gt;
&lt;pre class="brush: python"&gt;
"""
Custom Authenticator to use Google OAuth with JupyterHub.

Derived from the GitHub OAuth authenticator.
"""

import os
import json

from tornado             import gen
from tornado.auth        import GoogleOAuth2Mixin
from tornado.web         import HTTPError

from traitlets           import Unicode

from jupyterhub.auth     import LocalAuthenticator
from jupyterhub.utils    import url_path_join

from .oauth2 import OAuthLoginHandler, OAuthCallbackHandler, OAuthenticator

class GoogleLoginHandler(OAuthLoginHandler, GoogleOAuth2Mixin):
    '''An OAuthLoginHandler that provides scope to GoogleOAuth2Mixin's
       authorize_redirect.'''
    def get(self):
        guess_uri = '{proto}://{host}{path}'.format(
            proto=self.request.protocol,
            host=self.request.host,
            path=url_path_join(
                self.hub.server.base_url,
                'oauth_callback'
            )
        )

        redirect_uri = self.authenticator.oauth_callback_url or guess_uri
        self.log.info('redirect_uri: %r', redirect_uri)

        self.authorize_redirect(
            redirect_uri=redirect_uri,
            client_id=self.authenticator.client_id,
            scope=['openid', 'email'],
            response_type='code')

class GoogleOAuthHandler(OAuthCallbackHandler, GoogleOAuth2Mixin):
    @gen.coroutine
    def get(self):
        self.settings['google_oauth'] = {
            'key': self.authenticator.client_id,
            'secret': self.authenticator.client_secret,
            'scope': ['openid', 'email']
        }
        self.log.debug('google: settings: "%s"', str(self.settings['google_oauth']))
        # FIXME: we should verify self.settings['google_oauth']['hd']

        # "Cannot redirect after headers have been written" ?
        #OAuthCallbackHandler.get(self)
        username = yield self.authenticator.get_authenticated_user(self, None)
        self.log.info('google: username: "%s"', username)
        if username:
            user = self.user_from_username(username)
            self.set_login_cookie(user)
            self.redirect(url_path_join(self.hub.server.base_url, 'home'))
        else:
            # todo: custom error
            raise HTTPError(403)

class GoogleOAuthenticator(OAuthenticator, GoogleOAuth2Mixin):

    login_handler = GoogleLoginHandler
    callback_handler = GoogleOAuthHandler

    hosted_domain = Unicode(
        os.environ.get('HOSTED_DOMAIN', ''),
        config=True,
        help="""Hosted domain used to restrict sign-in, e.g. mycollege.edu"""
    )
    login_service = Unicode(
        os.environ.get('LOGIN_SERVICE', 'Google'),
        config=True,
        help="""Google Apps hosted domain string, e.g. My College"""
    )

    @gen.coroutine
    def authenticate(self, handler, data=None):
        code = handler.get_argument('code', False)
        if not code:
            raise HTTPError(400, "oauth callback made without a token") 
        if not self.oauth_callback_url:
            raise HTTPError(500, "No callback URL")
        user = yield handler.get_authenticated_user(
            redirect_uri=self.oauth_callback_url,
            code=code)
        access_token = str(user['access_token'])

        http_client = handler.get_auth_http_client()

        response = yield http_client.fetch(
            self._OAUTH_USERINFO_URL + '?access_token=' + access_token
        )

        if not response:
            self.clear_all_cookies()
            raise HTTPError(500, 'Google authentication failed')

        body = response.body.decode()
        self.log.debug('response.body.decode(): {}'.format(body))
        bodyjs = json.loads(body)

        username = bodyjs['email']

        if self.hosted_domain:
            if not username.endswith('@'+self.hosted_domain) or \
                bodyjs['hd'] != self.hosted_domain:
                raise HTTPError(403,
                    "You are not signed in to your {} account.".format(
                        self.hosted_domain)
                )
            else:
                username = username.split('@')[0]

        return username

class LocalGoogleOAuthenticator(LocalAuthenticator, GoogleOAuthenticator):
    """A version that mixes in local system user creation"""
    pass
&lt;/pre&gt;</summary><category term="cadlab"></category><category term="Jupyterhub"></category><category term="IPV6"></category><category term="oauth2"></category></entry><entry><title>純 IPV6 環境下安裝 Jupyterhub</title><link href="http://cadlab.mde.tw/post/chun-ipv6-huan-jing-xia-an-zhuang-jupyterhub.html" rel="alternate"></link><updated>2016-06-30T20:23:15+08:00</updated><author><name>Cad Lab</name></author><id>tag:cadlab.mde.tw,2016-06-30:post/chun-ipv6-huan-jing-xia-an-zhuang-jupyterhub.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/jupyterhub/jupyterhub"&gt;https://github.com/jupyterhub/jupyterhub&lt;/a&gt; 是一套支援多用戶的網際運算伺服器, 這裡展示如何在純 IPV6 的 Ubuntu 14.04 環境下進行安裝設定.&lt;/p&gt;


&lt;p&gt;首先假如沒有固定的 IPV4 位址, 就必須透過 IPV4/IPV6 雙支援的代理主機執行 apt-get, pip3 與 http 連結.&lt;/p&gt;
&lt;p&gt;要讓 apt-get 使用代理主機, 必須編輯 /etc/apt/apt.conf, 並且納入下列內容:&lt;/p&gt;
&lt;p&gt;Acquire::http::Proxy "http://username:password@your.proxy.server:3128";&lt;/p&gt;
&lt;p&gt;接著就可以進行 Jupyterhub 執行所需的 apt-get install 安裝:&lt;/p&gt;
&lt;p&gt;安裝 npm 與 nodejs-legacy 套件:&lt;/p&gt;
&lt;p&gt;sudo apt-get install npm nodejs-legacy&lt;/p&gt;
&lt;p&gt;安裝 pip3 工具:&lt;/p&gt;
&lt;p&gt;sudo apt-get install python3-pip&lt;/p&gt;
&lt;p&gt;安裝 jupyterhub 與 notebook 模組:&lt;/p&gt;
&lt;p&gt;sudo pip3 --proxy http://2001:288:6004:17::17:3128 install jupyterhub&lt;/p&gt;
&lt;p&gt;sudo pip3 --proxy http://2001:288:6004:17::17:3128 install notebook&lt;/p&gt;
&lt;p&gt;接著為了要採 https 啟動, 需要建立認証編碼用的 crt 與 key 檔案:&lt;/p&gt;
&lt;p&gt;sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout jupyterhub.key -out jupyterhub.crt&lt;/p&gt;
&lt;p&gt;完成後就可以指定 IP 啟動:&lt;/p&gt;
&lt;p&gt;jupyterhub --ip your_server_ip --port 443 --ssl-key jupyterhub.key --ssl-cert jupyterhub.crt&lt;/p&gt;
&lt;p&gt;或不指定 IP 方式啟動:&lt;/p&gt;
&lt;p&gt;jupyterhub  --port 9443 --ssl-key jupyterhub.key --ssl-cert jupyterhub.crt&lt;/p&gt;
&lt;p&gt;啟動之後則可以透過 https://your_server_ip:9443 連結, 以系統帳號登入.&lt;/p&gt;
&lt;p&gt;接下來要讓 Jupyterhub 隨著伺服器開機時啟動, 需要建立 /etc/jupyterhub/jupyterhub_config.py 與 /etc/init.d/jupyterhub 等兩個設定檔案, 並且配置 /srv/jupyterhub 目錄作為啟動目錄, 且將 jupyterhub.key 與  jupyterhub.crt 放入 /srv/jupyterhub/ssl 目錄中.&lt;/p&gt;
&lt;p&gt;/etc/jupyterhub/jupyterhub_config.py 檔案內容:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
# jupyterhub_config.py
# jupyterhub -f /etc/jupyterhub/jupyterhub_config.py
c = get_config()

import os
pjoin = os.path.join

runtime_dir = os.path.join('/srv/jupyterhub')
ssl_dir = pjoin(runtime_dir, 'ssl')
if not os.path.exists(ssl_dir):
    os.makedirs(ssl_dir)

# https on :9443
c.JupyterHub.port = 9443
# 以 IPV6 位址綁定 Jupyterhub
c.JupyterHub.ip = '2001:288:1::8888'
c.JupyterHub.ssl_key = pjoin(ssl_dir, 'jupyterhub.key')
c.JupyterHub.ssl_cert = pjoin(ssl_dir, 'jupyterhub.crt')

# put the JjupyterHub cookie secret and state db
# in /var/run/jupyterhub
c.JupyterHub.cookie_secret_file = pjoin(runtime_dir, 'jupyterhub_cookie_secret')
c.JupyterHub.db_url = pjoin(runtime_dir, 'jupyterhub.sqlite')
# or `--db=/path/to/jupyterhub.sqlite` on the command-line

# put the log file in /var/log
c.JupyterHub.log_file = '/var/log/jupyterhub.log'

# use GitHub OAuthenticator for local users
'''
c.JupyterHub.authenticator_class = 'oauthenticator.LocalGitHubOAuthenticator'
c.GitHubOAuthenticator.oauth_callback_url = os.environ['OAUTH_CALLBACK_URL']
# create system users that don't exist yet
c.LocalAuthenticator.create_system_users = True
'''
# specify users and admin
c.Authenticator.whitelist = {'username1', 'username2'}
c.Authenticator.admin_users = {'username1', 'username2'}

# start single-user notebook servers in ~/assignments,
# with ~/assignments/Welcome.ipynb as the default landing page
# this config could also be put in
# /etc/ipython/ipython_notebook_config.py
#c.Spawner.notebook_dir = '~/tmp'
#c.Spawner.args = ['--NotebookApp.default_url=/notebooks/Welcome.ipynb']
&lt;/pre&gt;

&lt;p&gt;/etc/init.d/jupyterhub 檔案內容:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
#! /bin/sh
### BEGIN INIT INFO
# Provides:          jupyterhub
# Required-Start:    $remote_fs $syslog
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start jupyterhub
# Description:       This file should be used to construct scripts to be
#                    placed in /etc/init.d.
### END INIT INFO

# Author: Alisue &amp;lt;lambdalisue@hashnote.net&amp;gt;
#
# Please remove the "Author" lines above and replace them
# with your own name if you copy and modify this script.

# Do NOT "set -e"

# PATH should only include /usr/* if it runs after the mountnfs.sh script
PATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin
DESC="Multi-user server for Jupyter notebooks"
NAME=jupyterhub
DAEMON=/usr/local/bin/jupyterhub
DAEMON_ARGS="--config=/etc/jupyterhub/jupyterhub_config.py"
PIDFILE=/var/run/$NAME.pid
SCRIPTNAME=/etc/init.d/$NAME

# Exit if the package is not installed
[ -x "$DAEMON" ] || exit 0

# Read configuration variable file if it is present
[ -r /etc/default/$NAME ] &amp;amp;&amp;amp; . /etc/default/$NAME

# Load the VERBOSE setting and other rcS variables
. /lib/init/vars.sh

# Define LSB log_* functions.
# Depend on lsb-base (&amp;gt;= 3.2-14) to ensure that this file is present
# and status_of_proc is working.
. /lib/lsb/init-functions

#
# Function that starts the daemon/service
#
do_start()
{
    # Return
    #   0 if daemon has been started
    #   1 if daemon was already running
    #   2 if daemon could not be started
    start-stop-daemon --start --quiet --pidfile $PIDFILE --exec $DAEMON --test &amp;gt; /dev/null \
        || return 1
    start-stop-daemon --start --background --make-pidfile --quiet --pidfile $PIDFILE --exec $DAEMON -- \
        $DAEMON_ARGS \
        || return 2
    # Add code here, if necessary, that waits for the process to be ready
    # to handle requests from services started subsequently which depend
    # on this one.  As a last resort, sleep for some time.
}

#
# Function that stops the daemon/service
#
do_stop()
{
    # Return
    #   0 if daemon has been stopped
    #   1 if daemon was already stopped
    #   2 if daemon could not be stopped
    #   other if a failure occurred
    start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --pidfile $PIDFILE --name $NAME
    RETVAL="$?"
    [ "$RETVAL" = 2 ] &amp;amp;&amp;amp; return 2
    # Wait for children to finish too if this is a daemon that forks
    # and if the daemon is only ever run from this initscript.
    # If the above conditions are not satisfied then add some other code
    # that waits for the process to drop all resources that could be
    # needed by services started subsequently.  A last resort is to
    # sleep for some time.
    start-stop-daemon --stop --quiet --oknodo --retry=0/30/KILL/5 --exec $DAEMON
    [ "$?" = 2 ] &amp;amp;&amp;amp; return 2
    # Many daemons don't delete their pidfiles when they exit.
    rm -f $PIDFILE
    return "$RETVAL"
}

#
# Function that sends a SIGHUP to the daemon/service
#
do_reload() {
    #
    # If the daemon can reload its configuration without
    # restarting (for example, when it is sent a SIGHUP),
    # then implement that here.
    #
    start-stop-daemon --stop --signal 1 --quiet --pidfile $PIDFILE --name $NAME
    return 0
}

case "$1" in
  start)
    [ "$VERBOSE" != no ] &amp;amp;&amp;amp; log_daemon_msg "Starting $DESC" "$NAME"
    do_start
    case "$?" in
        0|1) [ "$VERBOSE" != no ] &amp;amp;&amp;amp; log_end_msg 0 ;;
        2) [ "$VERBOSE" != no ] &amp;amp;&amp;amp; log_end_msg 1 ;;
    esac
    ;;
  stop)
    [ "$VERBOSE" != no ] &amp;amp;&amp;amp; log_daemon_msg "Stopping $DESC" "$NAME"
    do_stop
    case "$?" in
        0|1) [ "$VERBOSE" != no ] &amp;amp;&amp;amp; log_end_msg 0 ;;
        2) [ "$VERBOSE" != no ] &amp;amp;&amp;amp; log_end_msg 1 ;;
    esac
    ;;
  status)
    status_of_proc "$DAEMON" "$NAME" &amp;amp;&amp;amp; exit 0 || exit $?
    ;;
  #reload|force-reload)
    #
    # If do_reload() is not implemented then leave this commented out
    # and leave 'force-reload' as an alias for 'restart'.
    #
    #log_daemon_msg "Reloading $DESC" "$NAME"
    #do_reload
    #log_end_msg $?
    #;;
  restart|force-reload)
    #
    # If the "reload" option is implemented then remove the
    # 'force-reload' alias
    #
    log_daemon_msg "Restarting $DESC" "$NAME"
    do_stop
    case "$?" in
      0|1)
        do_start
        case "$?" in
            0) log_end_msg 0 ;;
            1) log_end_msg 1 ;; # Old process is still running
            *) log_end_msg 1 ;; # Failed to start
        esac
        ;;
      *)
        # Failed to stop
        log_end_msg 1
        ;;
    esac
    ;;
  *)
    #echo "Usage: $SCRIPTNAME {start|stop|restart|reload|force-reload}" &amp;gt;&amp;amp;2
    echo "Usage: $SCRIPTNAME {start|stop|status|restart|force-reload}" &amp;gt;&amp;amp;2
    exit 3
    ;;
esac

:
&lt;/pre&gt;

&lt;p&gt;設定隨機啟動步驟:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
$ sudo chmod +x /etc/init.d/jupyterhub
# Create a default config to /etc/jupyterhub/jupyterhub_config.py
$ sudo jupyterhub --generate-config -f /etc/jupyterhub/jupyterhub_config.py
# Start jupyterhub
$ sudo service jupyterhub start
# Stop jupyterhub
$ sudo service jupyterhub stop
# Start jupyterhub on boot
$ sudo update-rc.d jupyterhub defaults
&lt;/pre&gt;

&lt;p&gt;設定完成後, 利用 sudo /etc/init.d/jupyterhub start 進行測試, 利用 /etc/init.d/jupyterhub stop 關閉.&lt;/p&gt;
&lt;p&gt;啟動後, 則可開啟瀏覽器連結 https://[2001:288:1::8888]:9443 , 以系統帳號登入 Jupyterhub.&lt;/p&gt;
&lt;p&gt;參考資料:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://jupyterhub.readthedocs.io"&gt;https://jupyterhub.readthedocs.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://gist.github.com/lambdalisue/f01c5a65e81100356379"&gt;https://gist.github.com/lambdalisue/f01c5a65e81100356379&lt;/a&gt;&lt;/p&gt;</summary><category term="cadlab"></category><category term="Jupyterhub"></category><category term="IPV6"></category></entry><entry><title>純 IPV6 環境下的 CMSimply</title><link href="http://cadlab.mde.tw/post/chun-ipv6-huan-jing-xia-de-cmsimply.html" rel="alternate"></link><updated>2016-06-28T12:39:54+08:00</updated><author><name>Cad Lab</name></author><id>tag:cadlab.mde.tw,2016-06-28:post/chun-ipv6-huan-jing-xia-de-cmsimply.html</id><summary type="html">&lt;p&gt;IPV6 是工業 4.0 的一項重要技術, 隨著電腦輔助設計室導入 IPV6, 作為網際程式教學用的 CMSimply 也必須配合轉到 IPV6 相容的環境.&lt;/p&gt;


&lt;p&gt;有關機械設計工程系 IPV6 位址規劃, 請參考 &lt;a href="http://cadlab.mde.tw/post/ji-jie-she-ji-gong-cheng-xi-ipv6-wang-zhi-fen-pei.html"&gt;http://cadlab.mde.tw/post/ji-jie-she-ji-gong-cheng-xi-ipv6-wang-zhi-fen-pei.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;至於測試純 IPV6 環境, 假如是在 Host 主機內部, 可以啟用 Host-only 的網路設定, 以內部 fd00::/8 網址進行測試. 假如是要建立外部 IPV6 測試主機, 則可使用 Bridged 網路卡, 直接在廣域網路上執行測試, 相關設定細節請參考 &lt;a href="http://cadlab.mde.tw/post/kua-cao-zuo-xi-tong-de-virtualbox-vdi-dang-an.html"&gt;http://cadlab.mde.tw/post/kua-cao-zuo-xi-tong-de-virtualbox-vdi-dang-an.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;CMSimply 的原始碼位於: &lt;a href="https://github.com/chiamingyen/cmsimply.git"&gt;https://github.com/chiamingyen/cmsimply.git&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;本次版本的修改, 主要問題在原先的 tinymce3 無法正確解析 IPV6 網址, 有些團隊著重在修改 tinymce3, 讓舊程式碼可以在 IPV6 環境中使用, 但是 &lt;a href="https://www.tinymce.com/"&gt;https://www.tinymce.com/&lt;/a&gt; 第 4 版的程式碼較第 3 版精簡許多 ,設定也比較多元, 因此 CADLab 決定直接將 CMSimply 的 html5 編輯器升級到 tinymce4.&lt;/p&gt;
&lt;p&gt;升級修改的部份主要集中在 3 個項目, 也就是(1)設定差異, (2)檔案引用差異, (3)程式碼 highlight 引用差異等, 首先就是 tinymce3 與 tinymce4 的啟用設定不同, 許多舊的方法都已經作廢, 因此將程式碼引用導向開放源版本的 tinymce4 之後, 就必須配合修改設定, 與 CMSimply 有關的主要設定檔為全域方法中的 editorhead:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def editorhead():
    return '''
&amp;lt;br /&amp;gt;
&amp;lt;script src="//cdn.tinymce.com/4/tinymce.min.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src="/static/tinymce4/tinymce/plugins/sh4tinymce/plugin.min.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;link rel = "stylesheet" href = "/static/tinymce4/tinymce/plugins/sh4tinymce/style/style.css"&amp;gt;
&amp;lt;script&amp;gt;
tinymce.init({
  selector: "textarea",
  height: 500,
  element_format : "xhtml",
  language : "en",
  plugins: [
    'advlist autolink lists link image charmap print preview hr anchor pagebreak',
    'searchreplace wordcount visualblocks visualchars code fullscreen',
    'insertdatetime media nonbreaking save table contextmenu directionality',
    'emoticons template paste textcolor colorpicker textpattern imagetools sh4tinymce'
  ],
  toolbar1: 'insertfile save undo redo | styleselect | bold italic | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent',
  toolbar2: 'link image | print preview media | forecolor backcolor emoticons | code sh4tinymce',
  relative_urls: false,
  toolbar_items_size: 'small',
  file_picker_callback: function(callback, value, meta) {
        cmsFilePicker(callback, value, meta);
    },
  templates: [
    { title: 'Test template 1', content: 'Test 1' },
    { title: 'Test template 2', content: 'Test 2' }
  ],
  content_css: [
    '//fonts.googleapis.com/css?family=Lato:300,300i,400,400i',
    '//www.tinymce.com/css/codepen.min.css'
  ]
});

function cmsFilePicker(callback, value, meta) {
    tinymce.activeEditor.windowManager.open({
        title: 'Uploaded File Browser',
        url: '/file_selector?type=' + meta.filetype,
        width: 800,
        height: 550,
    }, {
        oninsert: function (url, objVals) {
            callback(url, objVals);
        }
    });
};
&amp;lt;/script&amp;gt;
'''
&lt;/pre&gt;

&lt;p&gt;其中最重要的設定為 relative_urls: false, 主要是讓 tinymce4 針對編輯內容中的網址引用, 採用絕對網址, 而不要讓 tinymce4 將 IPV6 網址修改為相對網址, 因為轉換過程會截斷 IPV6 網址而出錯.&lt;/p&gt;
&lt;p&gt;第 2 項重要的設定則是:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
file_picker_callback: function(callback, value, meta) {
        cmsFilePicker(callback, value, meta);
    }
&lt;/pre&gt;

&lt;p&gt;也就是所謂 file_picker_callback 函式的宣告, 這裡使用 anonymous 函式格式, 將檔案選擇的回呼函式設為 cmsFilePicker, 也就是隨後編寫的:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
function cmsFilePicker(callback, value, meta) {
    tinymce.activeEditor.windowManager.open({
        title: 'Uploaded File Browser',
        url: '/file_selector?type=' + meta.filetype,
        width: 800,
        height: 550,
    }, {
        oninsert: function (url, objVals) {
            callback(url, objVals);
        }
    });
&lt;/pre&gt;

&lt;p&gt;其中的關鍵是要求使用者按下檔案引用選擇按鈕時, 會經由 url 所指定的  '/file_selector?type=' + meta.filetype' 執行, 而這個 file_selector 方法內容為:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
@cherrypy.expose
def file_selector(self, type=None, page=1, item_per_page=10, keyword=None):
    if not self.isAdmin():
        raise cherrypy.HTTPRedirect("login")
    else:
        if type == "file":
            type = 'downloads'
            return file_lister("downloads", type, page, item_per_page)
        elif type == "image":
            #return images_file_selector()
            return file_lister("images", type, page, item_per_page)
&lt;/pre&gt;

&lt;p&gt;可以根據 type 決定引用上傳的 file 或 image, 分別導向不同的伺服器目錄, 列出可以引用的檔案.&lt;/p&gt;
&lt;p&gt;而且因為 file_lister 方法中的所有可選檔案, 都以 anchor 製作, 內容如下:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def file_lister(directory, type=None, page=1, item_per_page=10):
    files = os.listdir(download_root_dir+directory)
    total_rows = len(files)
    totalpage = math.ceil(total_rows/int(item_per_page))
    starti = int(item_per_page) * (int(page) - 1) + 1
    endi = starti + int(item_per_page) - 1
    outstring = file_selector_script()
    notlast = False
    if total_rows &amp;gt; 0:
        outstring += "&amp;lt;br /&amp;gt;"
        if (int(page) * int(item_per_page)) &amp;lt; total_rows:
            notlast = True
        if int(page) &amp;gt; 1:
            outstring += "&amp;lt;a href='"
            outstring += "file_selector?type="+type+"&amp;amp;page=1&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&amp;gt;&amp;lt;&amp;lt;&amp;lt;/a&amp;gt; "
            page_num = int(page) - 1
            outstring += "&amp;lt;a href='"
            outstring += "file_selector?type="+type+"&amp;amp;page="+str(page_num)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&amp;gt;Previous&amp;lt;/a&amp;gt; "
        span = 10
        for index in range(int(page)-span, int(page)+span):
        #for ($j=$page-$range;$j&amp;lt;$page+$range;$j++)
            if index&amp;gt;= 0 and index&amp;lt; totalpage:
                page_now = index + 1 
                if page_now == int(page):
                    outstring += "&amp;lt;font size='+1' color='red'&amp;gt;"+str(page)+" &amp;lt;/font&amp;gt;"
                else:
                    outstring += "&amp;lt;a href='"
                    outstring += "file_selector?type="+type+"&amp;amp;page="+str(page_now)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
                    outstring += "'&amp;gt;"+str(page_now)+"&amp;lt;/a&amp;gt; "

        if notlast == True:
            nextpage = int(page) + 1
            outstring += " &amp;lt;a href='"
            outstring += "file_selector?type="+type+"&amp;amp;page="+str(nextpage)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&amp;gt;Next&amp;lt;/a&amp;gt;"
            outstring += " &amp;lt;a href='"
            outstring += "file_selector?type="+type+"&amp;amp;page="+str(totalpage)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&amp;gt;&amp;gt;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt;"
        if (int(page) * int(item_per_page)) &amp;lt; total_rows:
            notlast = True
            if type == "downloads":
                outstring += downloadselect_access_list(files, starti, endi)+"&amp;lt;br /&amp;gt;"
            else:
                outstring += imageselect_access_list(files, starti, endi)+"&amp;lt;br /&amp;gt;"
        else:
            outstring += "&amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt;"
            if type == "downloads":
                outstring += downloadselect_access_list(files, starti, total_rows)+"&amp;lt;br /&amp;gt;"
            else:
                outstring += imageselect_access_list(files, starti, total_rows)+"&amp;lt;br /&amp;gt;"
        if int(page) &amp;gt; 1:
            outstring += "&amp;lt;a href='"
            outstring += "file_selector?type="+type+"&amp;amp;page=1&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&amp;gt;&amp;lt;&amp;lt;&amp;lt;/a&amp;gt; "
            page_num = int(page) - 1
            outstring += "&amp;lt;a href='"
            outstring += "file_selector?type="+type+"&amp;amp;page="+str(page_num)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&amp;gt;Previous&amp;lt;/a&amp;gt; "
        span = 10
        for index in range(int(page)-span, int(page)+span):
        #for ($j=$page-$range;$j&amp;lt;$page+$range;$j++)
            if index &amp;gt;=0 and index &amp;lt; totalpage:
                page_now = index + 1
                if page_now == int(page):
                    outstring += "&amp;lt;font size='+1' color='red'&amp;gt;"+str(page)+" &amp;lt;/font&amp;gt;"
                else:
                    outstring += "&amp;lt;a href='"
                    outstring += "file_selector?type="+type+"&amp;amp;page="+str(page_now)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
                    outstring += "'&amp;gt;"+str(page_now)+"&amp;lt;/a&amp;gt; "
        if notlast == True:
            nextpage = int(page) + 1
            outstring += " &amp;lt;a href='"
            outstring += "file_selector?type="+type+"&amp;amp;page="+str(nextpage)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&amp;gt;Next&amp;lt;/a&amp;gt;"
            outstring += " &amp;lt;a href='"
            outstring += "file_selector?type="+type+"&amp;amp;page="+str(totalpage)+"&amp;amp;item_per_page="+str(item_per_page)+"&amp;amp;keyword="+str(cherrypy.session.get('download_keyword'))
            outstring += "'&amp;gt;&amp;gt;&amp;gt;&amp;lt;/a&amp;gt;"
    else:
        outstring += "no data!"

    if type == "downloads":
        return outstring+"&amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;a href='fileuploadform'&amp;gt;file upload&amp;lt;/a&amp;gt;"
    else:
        return outstring+"&amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;a href='imageuploadform'&amp;gt;image upload&amp;lt;/a&amp;gt;"
&lt;/pre&gt;

&lt;p&gt;因此, 當使用者進入跳出的檔案引用頁面, 必須要透過選用的 anchor 項目, 跳回引用檔案的主頁面中, 並且帶回引用檔案的所在位置連結及屬性:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def file_selector_script():
    return '''
&amp;lt;script language="javascript" type="text/javascript"&amp;gt;
$(function(){
    $('.a').on('click', function(event){
        setLink();
    });
});

function setLink (url, objVals) {
    top.tinymce.activeEditor.windowManager.getParams().oninsert(url, objVals);
    top.tinymce.activeEditor.windowManager.close();
    return false;
}
&amp;lt;/script&amp;gt;
'''
&lt;/pre&gt;

&lt;p&gt;修改至此, 在 CMSimply 導入 tinymce4 的檔案引用程序已經完成, 只要檔案引用的網址採用全網址, 而且配合既有的檔案上傳功能, 已經可以正常在 IPV6 網址環境中運作.&lt;/p&gt;
&lt;p&gt;最後, 只剩下程式碼的 highlight 功能, 也必須同步升級到 tinymce4, 這裡選擇使用 &lt;a href="http://lab.nomadonweb.com/en/sh4tinymce"&gt;http://lab.nomadonweb.com/en/sh4tinymce&lt;/a&gt; 所釋出的 plugin.&lt;/p&gt;
&lt;p&gt;只需要在 tinymce4 引用的 cdn core plugins 之外, 額外導入自帶的 sh4tinymce 模組 .js 與 .css 即可. 也就是在 editorhead 的前頭導入時所設定的內容:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&amp;lt;script src="//cdn.tinymce.com/4/tinymce.min.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src="/static/tinymce4/tinymce/plugins/sh4tinymce/plugin.min.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;link rel = "stylesheet" href = "/static/tinymce4/tinymce/plugins/sh4tinymce/style/style.css"&amp;gt;
&lt;/pre&gt;

&lt;p&gt;上述將 CMSimply 升級使用 tinymce4 並引用 sh4tinymce 套件之後的執行畫面:&lt;/p&gt;
&lt;p&gt;CMSimply 在純 IPV6 網址伺服器中運行, 進入 html5 編輯畫面:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/cmsimply_for_ipv6_1.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;加入 tinymce4 中的 file_picker_callback 設定後, file 與 image 多了一個引用按鈕:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/cmsimply_for_ipv6_2.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;加入 tinymce4 中的 file_picker_callback 設定後, 使用者編輯內容時可以引用伺服器既有的 image 檔案:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/cmsimply_for_ipv6_3.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;加入 tinymce4 中的 file_picker_callback 設定後, 使用者編輯內容時可以引用伺服器既有的 file 檔案:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/cmsimply_for_ipv6_4.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;導入 sh4tinymce plugin 之後, 可以將程式碼置入 highlight 編輯設定:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/cmsimply_for_ipv6_5.png" width="800" /&gt;&lt;/p&gt;</summary><category term="cadlab"></category><category term="網際內容管理系統"></category><category term="CMSimply"></category><category term="IPV6"></category></entry><entry><title>網際機械設計 2D 繪圖</title><link href="http://cadlab.mde.tw/post/wang-ji-ji-jie-she-ji-2d-hui-tu.html" rel="alternate"></link><updated>2016-06-26T10:06:56+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-06-26:post/wang-ji-ji-jie-she-ji-2d-hui-tu.html</id><summary type="html">&lt;p&gt;&lt;a href="http://2015fallhw.github.io/arcidau/Flintlock.html"&gt;http://2015fallhw.github.io/arcidau/Flintlock.html&lt;/a&gt; 是一個典型的網際機械設計 2D 繪圖範例, CADLab 希望能夠利用 Brython 重新建立一個直接以 Python3 在網頁中繪圖的類似應用.&lt;/p&gt;


&lt;style type="text/css" media="screen"&gt;

#flintlockImg {
  float: right;
  display: inline;  /* IE6 hack to fix double margin bug */
  width: 24em;
  margin: 1em 2em 1em 1em;
}

#flintlockImg img {
  width: 100%;
  padding: 0.5em;
  border: 1px solid #404040;
}

#cvsUpper, #cvsLower {
  position: relative;
  width: 600px;
  height: 300px;
  text-align: center;  /* this will center console if it has display:inline-block */
  background-color: #aabdd3;
}
&lt;/style&gt;

&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/Cango-8v03.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/Cango2D-7v01-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/CangoAxes-1v33.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/flintlockPartDefs-02.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/CangoAnimation-4v01.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/gearUtils-05.js"&gt;&lt;/script&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;script type="text/javascript"&gt;

    if (typeof addLoadEvent === "undefined")
    {
      var addLoadEvent = function(func)
      {
        var oldonload = window.onload;
        if (typeof window.onload != 'function')
        {
          window.onload = func;
        }
        else
        {
            window.onload = function(){oldonload(); func();}
        }
      }
    }

    if (typeof addEvent === "undefined")
    {
      var addEvent = function(element, eventType, handler)
      {
        if (element.attachEvent)
        {
          return element.attachEvent('on'+eventType, handler);
        }
        return element.addEventListener(eventType, handler, false);
      };
    }

    function cancelBubble(e)
    {
      var evt = e ? e:window.event;
      if (evt.stopPropagation) evt.stopPropagation();
      if (evt.cancelBubble!=null) evt.cancelBubble = true;
    }
&lt;/script&gt;

&lt;script type="text/javascript"&gt;

function enableBtn(btnId)
{
  var btn = document.getElementById(btnId);
  btn.disabled = false;
}

function disableBtn(btnId)
{
  var btn = document.getElementById(btnId);
  btn.disabled = true;
}

function FlintlockDemo(cvsU, cvsL)
{
  "use strict"
  var innerGCL0, innerGCL1,
      outerGC,
      // Lock components (Cango2D groups)
      cockObj,
      fizzenObj,
      plateObj,
      searSpringObj,
      searObj,
      tumblerObj,
      mainSpringObj,
      screwsObj,
      // draw outside in lower canvas
      plateOutside,
      cockOutside,
      fizzenOutside,
      fizzenSpring,
      outScrews;

  this.fire_JS = function()
    {
    innerGCL0.playAnimation(0, 1000);   // play for 1000 then pause
    outerGC.playAnimation(0, 1000);

    disableBtn('cock');
    disableBtn('fire');
    setTimeout("enableBtn('load')", 1000);
  };

  this.load_JS = function()
  {
    innerGCL0.playAnimation(1000, 3500);    // resume from pause play until 3500
    outerGC.playAnimation(1000, 3500);

    disableBtn('load');
    disableBtn('fire');
    setTimeout("enableBtn('cock')", 2500);

  };

  this.cock_JS = function()
  {
    innerGCL0.playAnimation(3500, 5000);      // resume from pause play until 5000
    outerGC.playAnimation(3500, 5000);

    disableBtn('load');
    disableBtn('cock');
    setTimeout("enableBtn('fire')", 1500);
  };

  // Upper display
  innerGCL0 = new Cango(cvsU);                     // layer for the cock and fizzen
  innerGCL0.setWorldCoords(-250, -100, 500);       // square pixels origin in center of canvas
  innerGCL1 = new Cango(innerGCL0.createLayer());  // layer for main spring and sear
  innerGCL1.dupCtx(innerGCL0);

  // construct all the component objects
  cockObj = makeCock(innerGCL0);
  fizzenObj = makeFizzenInside(innerGCL0);
  plateObj = makePlate(innerGCL0);
  searSpringObj = makeSearSpring(innerGCL1);
  searObj = makeSear(innerGCL1);
  tumblerObj = makeTumbler(innerGCL1);
  mainSpringObj = makeMainSpring(innerGCL1);
  screwsObj = makeScrews(innerGCL1);

        var innerTwnr = new Tweener(0, 5000);
  var innerData = {
      cockRot:     [0, 54, 54, 18, 18,  0],
    cockRotTimes:[0, 10, 20, 60, 70, 90],
    fizzenRot:     [0, 0, 73, 73,  0],
    fizzenRotTimes:[0, 4,  8, 60, 70],
    searSpringRot:     [0, -5, -6, -3.5,  0, -2, -3.5, -3.5,  0,  0, -2, -3, -3.5,  0],
    searSpringRotTimes:[0,  5, 10,   15, 20, 30,   40,   50, 60, 70, 75, 80,   85, 90],
    searRot:     [0, 10, 12,  7,  0,  4,   7,   7,  0,  0,  4, 5.5,  7,  0],
    searRotTimes:[0,  5, 10, 15, 20, 30,  40,  50, 60, 70, 75,  80, 85, 90],
      tumblerRot:     [0, 54, 54, 18, 18,  0],
    tumblerRotTimes:[0, 10, 20, 60, 70, 90],
    mainSpringRot:     [0, -7, -7, -2, -2,  0],
    mainSpringRotTimes:[0, 10, 20, 60, 70, 90]
  };

  function initCock(opts)
  {
    this.nextState.x = cockCxOfs;
    this.nextState.y = -cockCyOfs;
  }

  function initFissen(opts)
  {
    this.nextState.x = fizzenCxOfs;
    this.nextState.y = -fizzenCyOfs;
  }

  function initSearSpring(opts)
  {
    this.nextState.x = searSpringCxOfs;
    this.nextState.y = -searSpringCyOfs;
  }

  function initSear(opts)
  {
    this.nextState.x = searCxOfs;
    this.nextState.y = -searCyOfs;
  }

  function initMainSpring(opts)
  {
    this.nextState.x = mainSpringCxOfs;
    this.nextState.y = -mainSpringCyOfs;
  }

  function cockPathFn(time, opts)
  {
    var cockRotVal = innerTwnr.getVal(time, opts.cockRot, opts.cockRotTimes);

    this.nextState.rot = cockRotVal;
  }

  function fizzenPathFn(time, opts)
  {
    var fizzenRotVal = innerTwnr.getVal(time, opts.fizzenRot, opts.fizzenRotTimes);

    this.nextState.rot = fizzenRotVal;
  }

  function searSpringPathFn(time, opts)
  {
    var searSpringRotVal = innerTwnr.getVal(time, opts.searSpringRot, opts.searSpringRotTimes);

    this.nextState.rot = searSpringRotVal;
  }

  function searPathFn(time, opts)
  {
    var searRotVal = innerTwnr.getVal(time, opts.searRot, opts.searRotTimes);

    this.nextState.rot = searRotVal;
  }

  function tumblerPathFn(time, opts)
  {
    var tumblerRotVal = innerTwnr.getVal(time, opts.tumblerRot, opts.tumblerRotTimes);

    this.nextState.rot = tumblerRotVal;
  }

  function mainSpringPathFn(time, opts)
  {
    var mainSpringRotVal = innerTwnr.getVal(time, opts.mainSpringRot, opts.mainSpringRotTimes);

    this.nextState.rot = mainSpringRotVal;
  }

  innerGCL0.animate(cockObj, initCock, cockPathFn, innerData);
  innerGCL0.animate(fizzenObj, initFissen, fizzenPathFn, innerData);
  innerGCL0.animate(plateObj);
  innerGCL1.animate(searSpringObj, initSearSpring, searSpringPathFn, innerData);
  innerGCL1.animate(searObj, initSear, searPathFn, innerData);
  innerGCL1.animate(tumblerObj, initCock, tumblerPathFn, innerData);
  innerGCL1.animate(mainSpringObj, initMainSpring, mainSpringPathFn, innerData);
  innerGCL1.animate(screwsObj);

  // Lower display
  outerGC = new Cango(cvsL);
  outerGC.setWorldCoords(-250, -100, 500);

  // construct all the component objects
  plateOutside = makePlateOutside(outerGC);
  cockOutside = makeCockOutside(outerGC);
  fizzenOutside = makeFizzenOutside(outerGC);
  fizzenSpring = makeFizzenSpring(outerGC);
  outScrews = makeOutScrews(outerGC);

        var outerTwnr = new Tweener(0, 5000);
  var outerData = {
      outerCockRot:     [0, -54, -54, -18, -18,  0],
    outerCockRotTimes:[0,  10,  20,  60,  70, 90],
    outerFizRot:     [0, 0, -73, -73,  0],
    outerFizRotTimes:[0, 4,   8,  60, 70],
    outerFizSpringRot:     [0, 0, 5, 6, 3.5, 0,  0,    3,  4,    3,  0],
    outerFizSpringRotTimes:[0, 4, 5, 6,   7, 8, 60, 62.5, 65, 67.5, 70]
  };

  function initCockOutside(opts)
  {
    this.nextState.x = -cockCxOfs;
    this.nextState.y = -cockCyOfs;
  }

  function initFissenOutside(opts)
  {
    this.nextState.x = -fizzenCxOfs;
    this.nextState.y = -fizzenCyOfs;
  }

  function initFissenSpring(opts)
  {
    this.nextState.x = -fizzenSpringCxOfs;
    this.nextState.y = -fizzenSpringCyOfs;
  }

  function outerCockPathFn(time, opts)
  {
    var cockRotVal = outerTwnr.getVal(time, opts.outerCockRot, opts.outerCockRotTimes);

    this.nextState.rot = cockRotVal;
  }

  function outerFizzenPathFn(time, opts)
  {
    var fizzenRotVal = outerTwnr.getVal(time, opts.outerFizRot, opts.outerFizRotTimes);

    this.nextState.rot = fizzenRotVal;
  }

  function fizzenSpringPathFn(time, opts)
  {
    var fizzenSpringRotVal = outerTwnr.getVal(time, opts.outerFizSpringRot, opts.outerFizSpringRotTimes);

    this.nextState.rot = fizzenSpringRotVal;
  }

  outerGC.animate(plateOutside);
  outerGC.animate(cockOutside, initCockOutside, outerCockPathFn, outerData);
  outerGC.animate(fizzenOutside, initFissenOutside, outerFizzenPathFn, outerData);
  outerGC.animate(fizzenSpring, initFissenSpring, fizzenSpringPathFn, outerData);
  outerGC.animate(outScrews);

  disableBtn('load');
  disableBtn('cock');
  enableBtn('fire');
}

var consoleBtns =
{
  f1:function(){demo.load_JS()},
  f2:function(){demo.cock_JS()},
  f3:function(){demo.fire_JS()},
  f4:function(){}
};

&lt;/script&gt;

&lt;script type="text/javascript"&gt;
addLoadEvent( function(){
  demo = new FlintlockDemo('cvsUpper', 'cvsLower');
  enableStickyNav();
});
&lt;/script&gt;

&lt;div class="consoleHolder"&gt;
&lt;div class="console"&gt;
&lt;div class="bezel"&gt;

    &lt;div class="scrnBevel"&gt;
    &lt;canvas id="cvsUpper" width="600" height="300"&gt;&lt;/canvas&gt;
    &lt;canvas id="cvsLower" width="600" height="300"&gt;&lt;/canvas&gt;
    &lt;/div&gt;  &lt;!-- scrnBevel --&gt;

    &lt;table class="btnHolder" cellspacing="0" cellpadding="0"&gt;
    &lt;tr align="center"&gt;
      &lt;td width="33%"&gt;&lt;button type="button" onclick="consoleBtns.f1()" class="button-link" id="load"&gt;HALF COCK&lt;/button&gt;&lt;/td&gt;
      &lt;td width="33%"&gt;&lt;button type="button" onclick="consoleBtns.f2()" class="button-link" id="cock"&gt;COCK&lt;/button&gt;&lt;/td&gt;
      &lt;td width="33%"&gt;&lt;button type="button" onclick="consoleBtns.f3()" class="button-link" id="fire"&gt;FIRE&lt;/button&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/table&gt;

&lt;/div&gt;

&lt;p&gt;&lt;!-- bezel --&gt;
&lt;div style="clear: both;"&gt;&lt;/div&gt;
&lt;/div&gt; &lt;!-- console --&gt;
&lt;/div&gt;   &lt;!-- consoleHolder --&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;利用 &lt;a href="http://2015fallhw.github.io/cptocadp/static/gearUtils-05.js"&gt;http://2015fallhw.github.io/cptocadp/static/gearUtils-05.js&lt;/a&gt; 程式庫, 繪製正齒輪:&lt;/p&gt;
&lt;!-- 齒輪繪圖 --&gt;

&lt;canvas id='gear1' width='800' height='750'&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
# 針對 Javascript 既有的物件, 則必須透過 JSConstructor 轉換
from javascript import JSConstructor
import math

# 主要用來取得畫布大小
canvas = doc["gear1"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
#ctx = canvas.getContext("2d")
# 針對類別的轉換, 將 Cango.js 中的 Cango 物件轉為 Python cango 物件
cango = JSConstructor(window.Cango)
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
cobj = JSConstructor(window.Cobj)
creategeartooth = JSConstructor(window.createGearTooth)

# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="plotarea" 的 canvas 上
cgo = cango("gear1")

######################################
# 畫正齒輪輪廓
#####################################
# n 為齒數
n = 17
# pa 為壓力角
pa = 25
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
m = 0.8*canvas.width/n
# pr 為節圓半徑
pr = n*m/2 # gear Pitch radius
# generate gear
data = creategeartooth(m, n, pa)
# Brython 程式中的 print 會將資料印在 Browser 的 console 區
#print(data)
gearTooth = cobj(data, "SHAPE", {
        "fillColor":"#ddd0dd",
        "border": True,
        "strokeColor": "#606060" })
gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
# 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
gear = gearTooth.dup()
# gear 為單一齒的輪廓資料
#cgo.render(gearTooth)

# 利用單齒輪廓旋轉, 產生整個正齒輪外形
for i in range(1, n):
    # 將 gearTooth 中的資料複製到 newTooth
    newTooth = gearTooth.dup()
    # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
    newTooth.rotate(360*i/n)
    # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
    gear.appendPath(newTooth, True) # trim move command = True

# 建立軸孔
# add axle hole, hr 為 hole radius
hr = 0.6*pr # diameter of gear shaft
shaft = cobj(shapedefs.circle(hr), "PATH")
shaft.revWinding()
gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path
cx = canvas.width/2
cy = canvas.height/2
gear.translate(cx, cy)
# render 繪出靜態正齒輪輪廓
cgo.render(gear)
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;上述正齒輪繪圖原始碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&amp;lt;canvas id='gear1' width='800' height='750'&amp;gt;&amp;lt;/canvas&amp;gt;

&amp;lt;script type="text/python"&amp;gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
# 針對 Javascript 既有的物件, 則必須透過 JSConstructor 轉換
from javascript import JSConstructor
import math

# 主要用來取得畫布大小
canvas = doc["gear1"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
#ctx = canvas.getContext("2d")
# 針對類別的轉換, 將 Cango.js 中的 Cango 物件轉為 Python cango 物件
cango = JSConstructor(window.Cango)
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
cobj = JSConstructor(window.Cobj)
creategeartooth = JSConstructor(window.createGearTooth)

# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="plotarea" 的 canvas 上
cgo = cango("gear1")

######################################
# 畫正齒輪輪廓
#####################################
# n 為齒數
n = 17
# pa 為壓力角
pa = 25
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
m = 0.8*canvas.width/n
# pr 為節圓半徑
pr = n*m/2 # gear Pitch radius
# generate gear
data = creategeartooth(m, n, pa)
# Brython 程式中的 print 會將資料印在 Browser 的 console 區
#print(data)
gearTooth = cobj(data, "SHAPE", {
        "fillColor":"#ddd0dd",
        "border": True,
        "strokeColor": "#606060" })
gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
# 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
gear = gearTooth.dup()
# gear 為單一齒的輪廓資料
#cgo.render(gearTooth)

# 利用單齒輪廓旋轉, 產生整個正齒輪外形
for i in range(1, n):
    # 將 gearTooth 中的資料複製到 newTooth
    newTooth = gearTooth.dup()
    # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
    newTooth.rotate(360*i/n)
    # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
    gear.appendPath(newTooth, True) # trim move command = True

# 建立軸孔
# add axle hole, hr 為 hole radius
hr = 0.6*pr # diameter of gear shaft
shaft = cobj(shapedefs.circle(hr), "PATH")
shaft.revWinding()
gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path
cx = canvas.width/2
cy = canvas.height/2
gear.translate(cx, cy)
# render 繪出靜態正齒輪輪廓
cgo.render(gear)
&amp;lt;/script&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;直接利用 Canvas 繪製正齒輪:&lt;/p&gt;
&lt;canvas id='gear2' width='800' height='700'&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
# 導入 browser 模組中的 document, 並設為 doc 變數
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

# 準備在 id="gear2" 的 canvas 中繪圖
canvas = doc["gear2"]
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2
r = 0.8*(canvas.width/2)
# 齒數
n = 53
# 壓力角
pa = 20
Spur(ctx).Gear(x, y, r, n, pa, "blue")
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;上述直接利用 Canvas 繪正齒輪的原始碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&amp;lt;canvas id='gear2' width='800' height='700'&amp;gt;&amp;lt;/canvas&amp;gt;

&amp;lt;script type="text/python3"&amp;gt;
# 導入 browser 模組中的 document, 並設為 doc 變數
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&amp;gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&amp;gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&amp;gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

# 準備在 id="gear2" 的 canvas 中繪圖
canvas = doc["gear2"]
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2
r = 0.8*(canvas.width/2)
# 齒數
n = 53
# 壓力角
pa = 20
Spur(ctx).Gear(x, y, r, n, pa, "blue")
&amp;lt;/script&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;正齒輪囓合繪圖:&lt;/p&gt;
&lt;canvas id='gear3' width='800' height='400'&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
# 導入 browser 模組中的 document, 並設為 doc 變數
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)

                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

# 準備在 id="gear3" 的 canvas 中繪圖
canvas = doc["gear3"]
ctx = canvas.getContext("2d")

# 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角
# 壓力角 pa 單位為角度
pa = 20
# 第1齒輪齒數
n_g1 = 17
# 第2齒輪齒數
n_g2 = 11
# 第3齒輪齒數
n_g3 = 13
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
m = (0.8*canvas.width)/(n_g1+n_g2+n_g3)
# 根據模數 m, 計算各齒輪的節圓半徑
rp_g1 = m*n_g1/2
rp_g2 = m*n_g2/2
rp_g3 = m*n_g3/2
#單一正齒輪繪圖呼叫格式 Spur(ctx).Gear(x, y, r, n, pa, "blue")
# 開始繪製囓合齒輪輪廓
# 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 的 80%, 所以兩邊各預留 10% 距離
x_g1 = canvas.width*0.1+rp_g1
# y 方向繪圖區域上方預留 canvas.height 的 20%
y_g1 = canvas.height*0.2+rp_g1
# 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同
x_g2 = x_g1 + rp_g1 + rp_g2
y_g2 = y_g1
# 第3齒輪的圓心座標
x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3
y_g3 = y_g1

# 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2
# 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g1, y_g1)
# rotate to engage
ctx.rotate(math.pi/2)
# put it back
ctx.translate(-x_g1, -y_g1)
# 繪製第一個齒輪輪廓
Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, "blue")
ctx.restore()

# 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g2, y_g2)
# rotate to engage
ctx.rotate(-math.pi/2-math.pi/n_g2)
# put it back
ctx.translate(-x_g2, -y_g2)
Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, "black")
ctx.restore()

# 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g3, y_g3)
# rotate to engage
# math.pi+math.pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度
# 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快
# 第1個 -math.pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度
# -math.pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合
# (math.pi+math.pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, 
# 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, 
# 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3
ctx.rotate(-math.pi/2-math.pi/n_g3+(math.pi+math.pi/n_g2)*n_g2/n_g3)
# put it back
ctx.translate(-x_g3, -y_g3)
Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, "red")
ctx.restore()
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;上述正齒輪囓合繪圖原始碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&amp;lt;canvas id='gear3' width='800' height='400'&amp;gt;&amp;lt;/canvas&amp;gt;

&amp;lt;script type="text/python3"&amp;gt;
# 導入 browser 模組中的 document, 並設為 doc 變數
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&amp;gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&amp;gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)

                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&amp;gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

# 準備在 id="gear3" 的 canvas 中繪圖
canvas = doc["gear3"]
ctx = canvas.getContext("2d")

# 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角
# 壓力角 pa 單位為角度
pa = 20
# 第1齒輪齒數
n_g1 = 17
# 第2齒輪齒數
n_g2 = 11
# 第3齒輪齒數
n_g3 = 13
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
m = (0.8*canvas.width)/(n_g1+n_g2+n_g3)
# 根據模數 m, 計算各齒輪的節圓半徑
rp_g1 = m*n_g1/2
rp_g2 = m*n_g2/2
rp_g3 = m*n_g3/2
#單一正齒輪繪圖呼叫格式 Spur(ctx).Gear(x, y, r, n, pa, "blue")
# 開始繪製囓合齒輪輪廓
# 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 的 80%, 所以兩邊各預留 10% 距離
x_g1 = canvas.width*0.1+rp_g1
# y 方向繪圖區域上方預留 canvas.height 的 20%
y_g1 = canvas.height*0.2+rp_g1
# 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同
x_g2 = x_g1 + rp_g1 + rp_g2
y_g2 = y_g1
# 第3齒輪的圓心座標
x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3
y_g3 = y_g1

# 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2
# 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g1, y_g1)
# rotate to engage
ctx.rotate(math.pi/2)
# put it back
ctx.translate(-x_g1, -y_g1)
# 繪製第一個齒輪輪廓
Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, "blue")
ctx.restore()

# 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g2, y_g2)
# rotate to engage
ctx.rotate(-math.pi/2-math.pi/n_g2)
# put it back
ctx.translate(-x_g2, -y_g2)
Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, "black")
ctx.restore()

# 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g3, y_g3)
# rotate to engage
# math.pi+math.pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度
# 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快
# 第1個 -math.pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度
# -math.pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合
# (math.pi+math.pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, 
# 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, 
# 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3
ctx.rotate(-math.pi/2-math.pi/n_g3+(math.pi+math.pi/n_g2)*n_g2/n_g3)
# put it back
ctx.translate(-x_g3, -y_g3)
Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, "red")
ctx.restore()
&amp;lt;/script&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;轉為 Brython 繪圖的模擬應用:&lt;/p&gt;
&lt;canvas id='robot' width='800' height='400'&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import window

cango2d = JSConstructor(window.Cango2D)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
tweener = JSConstructor(window.Tweener)

cgo = cango2d("robot")
# 清除畫面
cgo.clearCanvas("lightyellow")
cgo.setWorldCoords(-50, -50, 300)

# 加上基軸與第一桿
# 畫筆移到 -20, -10, 畫直線到 -10,-10 以及 -10,0 
standData = ['M', -20,-10, 'L', -10,-10, -10,0, 'A', 10,10,0,0,0,10,0, 'L',10,-10, 20,-10, 20,-40, -20,-40,'z']
stand = obj2d(standData, "SHAPE", {
        "fillColor":'darkgray',
        "border": True,
        "strokeColor": "#222222" })
axle0 = obj2d(shapedefs.circle(10), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222" })
armGrp = cgo.createGroup2D(stand, axle0)

segData = ['M',0,-8, 'A',8,8,0,0,0,0,8, 'L',50,8, 'A',8,8,0,0,0,50,-8, 'Z']
seg1 = obj2d(segData, "SHAPE", {
        "fillColor":'darkGray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": -1 })
# 利用 zIndex 決定疊層的先後次序
axle1 = obj2d(shapedefs.circle(8), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": 1 })
axle1.translate(50, 0)
seg1Grp = cgo.createGroup2D(seg1, axle1)
armGrp.addObj(seg1Grp)

# 加上第二軸
seg2 = obj2d(segData, "SHAPE", {
        "fillColor":'darkGray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": -1 })
axle2 = obj2d(shapedefs.circle(8), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": 1 })
axle2.translate(50, 0)
seg2Grp = cgo.createGroup2D(seg2, axle2)
cgo.render(seg2Grp)
# 請注意 seg2Grp 加上 seg1Grp 物件上
seg1Grp.addObj(seg2Grp)

seg3 = obj2d(segData, "SHAPE", {
        'fillColor':'darkGray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': -1 })
axle3 = obj2d(shapedefs.circle(6), "SHAPE", {
        'fillColor':'gray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': 1 })
axle3.translate(50, 0)
seg3Grp = cgo.createGroup2D(seg3, axle3)
seg2Grp.addObj(seg3Grp)

seg4Data = ['M',0,-6, 'A',6,6,0,0,0,0,6, 'L',40,6, 40,12, 50,12, 50,-12, 40,-12, 40,-6, 'Z']
seg4 = obj2d(seg4Data, "SHAPE", {
        'fillColor':'darkGray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': -1 })
seg3Grp.addObj(seg4)

# setup animation
animData = {'s1': [0, 80, 45, 0],
                  's2': [0, -60, -60, 0],
                  's3': [0, -90, 0, 90, 0],
                  's4': [0, 30, -90, 0]}

armTwnr = tweener(0, 3500, 'loop')

def initArm(opts):
    seg2Grp.transform.translate(50,0)
    seg3Grp.transform.translate(50,0)
    seg4.transform.translate(50,0)


def armPathFn(time, opts):
    seg1Rot = armTwnr.getVal(time, opts.s1)
    seg2Rot = armTwnr.getVal(time, opts.s2)
    seg3Rot = armTwnr.getVal(time, opts.s3)
    seg4Rot = armTwnr.getVal(time, opts.s4)

    seg1Grp.transform.rotate(seg1Rot)
    seg2Grp.transform.rotate(seg2Rot)
    seg2Grp.transform.translate(50,0)
    seg3Grp.transform.rotate(seg3Rot)
    seg3Grp.transform.translate(50,0)
    seg4.transform.rotate(seg4Rot)
    seg4.transform.translate(50,0)

cgo.animate(armGrp, initArm, armPathFn, animData)
cgo.playAnimation()
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;上述動態模擬的原始碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&amp;lt;canvas id='robot' width='800' height='400'&amp;gt;&amp;lt;/canvas&amp;gt;

&amp;lt;script type="text/python"&amp;gt;
from javascript import JSConstructor
from browser import window

cango2d = JSConstructor(window.Cango2D)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
tweener = JSConstructor(window.Tweener)

cgo = cango2d("robot")
# 清除畫面
cgo.clearCanvas("lightyellow")
cgo.setWorldCoords(-50, -50, 300)

# 加上基軸與第一桿
# 畫筆移到 -20, -10, 畫直線到 -10,-10 以及 -10,0 
standData = ['M', -20,-10, 'L', -10,-10, -10,0, 'A', 10,10,0,0,0,10,0, 'L',10,-10, 20,-10, 20,-40, -20,-40,'z']
stand = obj2d(standData, "SHAPE", {
        "fillColor":'darkgray',
        "border": True,
        "strokeColor": "#222222" })
axle0 = obj2d(shapedefs.circle(10), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222" })
armGrp = cgo.createGroup2D(stand, axle0)

segData = ['M',0,-8, 'A',8,8,0,0,0,0,8, 'L',50,8, 'A',8,8,0,0,0,50,-8, 'Z']
seg1 = obj2d(segData, "SHAPE", {
        "fillColor":'darkGray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": -1 })
# 利用 zIndex 決定疊層的先後次序
axle1 = obj2d(shapedefs.circle(8), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": 1 })
axle1.translate(50, 0)
seg1Grp = cgo.createGroup2D(seg1, axle1)
armGrp.addObj(seg1Grp)

# 加上第二軸
seg2 = obj2d(segData, "SHAPE", {
        "fillColor":'darkGray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": -1 })
axle2 = obj2d(shapedefs.circle(8), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": 1 })
axle2.translate(50, 0)
seg2Grp = cgo.createGroup2D(seg2, axle2)
cgo.render(seg2Grp)
# 請注意 seg2Grp 加上 seg1Grp 物件上
seg1Grp.addObj(seg2Grp)

seg3 = obj2d(segData, "SHAPE", {
        'fillColor':'darkGray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': -1 })
axle3 = obj2d(shapedefs.circle(6), "SHAPE", {
        'fillColor':'gray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': 1 })
axle3.translate(50, 0)
seg3Grp = cgo.createGroup2D(seg3, axle3)
seg2Grp.addObj(seg3Grp)

seg4Data = ['M',0,-6, 'A',6,6,0,0,0,0,6, 'L',40,6, 40,12, 50,12, 50,-12, 40,-12, 40,-6, 'Z']
seg4 = obj2d(seg4Data, "SHAPE", {
        'fillColor':'darkGray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': -1 })
seg3Grp.addObj(seg4)

# setup animation
animData = {'s1': [0, 80, 45, 0],
                  's2': [0, -60, -60, 0],
                  's3': [0, -90, 0, 90, 0],
                  's4': [0, 30, -90, 0]}

armTwnr = tweener(0, 3500, 'loop')

def initArm(opts):
    seg2Grp.transform.translate(50,0)
    seg3Grp.transform.translate(50,0)
    seg4.transform.translate(50,0)


def armPathFn(time, opts):
    seg1Rot = armTwnr.getVal(time, opts.s1)
    seg2Rot = armTwnr.getVal(time, opts.s2)
    seg3Rot = armTwnr.getVal(time, opts.s3)
    seg4Rot = armTwnr.getVal(time, opts.s4)

    seg1Grp.transform.rotate(seg1Rot)
    seg2Grp.transform.rotate(seg2Rot)
    seg2Grp.transform.translate(50,0)
    seg3Grp.transform.rotate(seg3Rot)
    seg3Grp.transform.translate(50,0)
    seg4.transform.rotate(seg4Rot)
    seg4.transform.translate(50,0)

cgo.animate(armGrp, initArm, armPathFn, animData)
cgo.playAnimation()
&amp;lt;/script&amp;gt;
&lt;/pre&gt;</summary><category term="MCAD"></category><category term="Web based"></category></entry><entry><title>Wordpress 網誌文章中的網際程式碼</title><link href="http://cadlab.mde.tw/post/wordpress-wang-zhi-wen-zhang-zhong-de-wang-ji-cheng-shi-ma.html" rel="alternate"></link><updated>2016-06-26T10:06:56+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-06-26:post/wordpress-wang-zhi-wen-zhang-zhong-de-wang-ji-cheng-shi-ma.html</id><summary type="html">&lt;p&gt;從 &lt;a href="https://www.w3.org/Graphics/SVG/History"&gt;SVG 歷史&lt;/a&gt; 與 &lt;a href="https://en.wikipedia.org/wiki/WebGL#History"&gt;WebGL 歷史&lt;/a&gt;, 以及 &lt;a href="https://github.com/socketio/socket.io/blob/master/History.md"&gt; socket.io 歷史&lt;/a&gt;, 也許不難發現, 多人協同在瀏覽器為基礎的應用程式環境, 已然成型.&lt;/p&gt;


&lt;p&gt;儘管如此, 要將所有的工作全時在網路連線的環境中完成, 可能仍言之過早, 比較讓人確定的是, 多點觸控的平台伴隨著本地端的桌機或者是筆電, 還會繼續是主流的電腦輔助設計環境.&lt;/p&gt;
&lt;p&gt;在這樣的所謂 Web Based (網際) 環境中, 身為一位機械設計工程師, 除了要關注傳統的 2D/3D 靜態與動態內容表達外, 能否逐步導入多點觸控裝置的資料, 便成為重點.&lt;/p&gt;
&lt;p&gt;以網際 2D 繪圖而言, 2013 年推出的 &lt;a href="http://snapsvg.io/"&gt;http://snapsvg.io/&lt;/a&gt;, 就是一套能夠順應未來電腦輔助機械設計繪圖的工具之一.&lt;/p&gt;
&lt;p&gt;從 &lt;a href="http://chiamingyen.github.io/kmolab/blog/dao-ru-brython-yu-snapsvg-wang-ji-hui-tu.html"&gt;導入 Brython 與 Snap.svg 網際繪圖&lt;/a&gt; 的說明中, 我們已經知道能夠透過網際的 Brython 來呼叫並運用 snap.svg 程式庫, 但是假如希望完成如 &lt;a href="http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html"&gt;Pelican 靜態網頁與 Wordpress 的整合方案&lt;/a&gt; 中所談到的資料整合, 並且導入 snap.svg 到 Wordpress 與 Pelican 網誌系統, 需要注意到 Wordpress 對於內文中處理程式碼的用法, 否則由 Pelican 靜態網誌轉進 Wordpress 系統中的所有 Brython 或 Javascript 程式內容, 將會全數被 Wordpress 當作一般文字資料處理.&lt;/p&gt;
&lt;p&gt;應對的方法很簡單, 只需要明確利用 html 的註解標註, 跳過 Wordpress 對於 Brython 與 Javascript 程式碼的額外處理就行.&lt;/p&gt;
&lt;p&gt;以下舉 Snap.svg 典型的動態模擬為例:&lt;/p&gt;
&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"&gt;&lt;/script&gt;

&lt;script&gt;
//&lt;!--
window.onload=function(){
brython(1);
}
//--&gt;
&lt;/script&gt;

&lt;p&gt;&lt;svg width="800" height="600" viewBox="0 0 800 600" id="svgout"&gt;&lt;/svg&gt;&lt;/p&gt;
&lt;script type="text/python"&gt;
#&lt;!--
from javascript import JSConstructor
from browser import alert
from browser import window, document

# 透過 window 與 JSConstructor 從 Brython 物件 snap 擷取 Snap 物件的內容
snap = JSConstructor(window.Snap)

# 使用 id 為 "svgout" 的 svg 標註進行繪圖
s = snap("#svgout")

offsetY = 50

# 是否標示出繪圖範圍
#borderRect = s.rect(0,0,800,640,10,10).attr({ 'stroke': "silver", 'fill': "silver", 'strokeWidth': "3" })

g = s.group().transform('t250,120')
r0 = s.rect(150,150,100,100,20,20).attr({ 'fill': "orange", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c0 = s.circle(225,225,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4"  }).attr({ 'id': 'c0' })
g0 = s.group( r0,c0 ).attr({ 'id': 'g0' })
#g0.animate({ 'transform' : 't250,120r360,225,225' },4000)
g0.appendTo( g )
g0.animate({ 'transform' : 'r360,225,225' },4000)
# 讓 g0 可以拖動
g0.drag()

r1 = s.rect(100,100,100,100,20,20).attr({ 'fill': "red", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c1 = s.circle(175,175,10).attr({ 'fill': "silver", 'stroke': "black" , 'strokeWidth': "4"}).attr({ 'id': 'c1' })
g1 = s.group( r1,c1 ).attr({ 'id': 'g1' })
g1.appendTo( g0 ).attr({ 'id': 'g1' })
g1.animate({ 'transform' : 'r360,175,175' },4000)

r2 = s.rect(50,50,100,100,20,20).attr({ 'fill': "blue", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c2 = s.circle(125,125,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c2' })
g2 = s.group(r2,c2).attr({ 'id': 'g2' })

g2.appendTo( g1 );
g2.animate( { 'transform' : 'r360,125,125' },4000);

r3 = s.rect(0,0,100,100,20,20).attr({ 'fill': "yellow", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c3 = s.circle(75,75,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c3' })
g3 = s.group(r3,c3).attr({ 'id': 'g3' })

g3.appendTo( g2 )
g3.animate( { 'transform' : 'r360,75,75' },4000)

r4 = s.rect(-50,-50,100,100,20,20).attr({ 'fill': "green", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c4 = s.circle(25,25,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c4' })
g4 = s.group(r4,c4).attr({ 'id': 'g4' });
g4.appendTo( g3 )
g4.animate( { 'transform' : 'r360,25,25' },4000)
#--&gt;
&lt;/script&gt;

&lt;p&gt;Brython 程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&amp;lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script&amp;gt;
//&amp;lt;!--
window.onload=function(){
brython(1);
}
//--&amp;gt;
&amp;lt;/script&amp;gt;

&amp;lt;svg width="800" height="600" viewBox="0 0 800 600" id="svgout"&amp;gt;&amp;lt;/svg&amp;gt;

&amp;lt;script type="text/python"&amp;gt;
#&amp;lt;!--
from javascript import JSConstructor
from browser import alert
from browser import window, document

# 透過 window 與 JSConstructor 從 Brython 物件 snap 擷取 Snap 物件的內容
snap = JSConstructor(window.Snap)

# 使用 id 為 "svgout" 的 svg 標註進行繪圖
s = snap("#svgout")

offsetY = 50

# 是否標示出繪圖範圍
#borderRect = s.rect(0,0,800,640,10,10).attr({ 'stroke': "silver", 'fill': "silver", 'strokeWidth': "3" })

g = s.group().transform('t250,120')
r0 = s.rect(150,150,100,100,20,20).attr({ 'fill': "orange", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c0 = s.circle(225,225,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4"  }).attr({ 'id': 'c0' })
g0 = s.group( r0,c0 ).attr({ 'id': 'g0' })
#g0.animate({ 'transform' : 't250,120r360,225,225' },4000)
g0.appendTo( g )
g0.animate({ 'transform' : 'r360,225,225' },4000)
# 讓 g0 可以拖動
g0.drag()

r1 = s.rect(100,100,100,100,20,20).attr({ 'fill': "red", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c1 = s.circle(175,175,10).attr({ 'fill': "silver", 'stroke': "black" , 'strokeWidth': "4"}).attr({ 'id': 'c1' })
g1 = s.group( r1,c1 ).attr({ 'id': 'g1' })
g1.appendTo( g0 ).attr({ 'id': 'g1' })
g1.animate({ 'transform' : 'r360,175,175' },4000)

r2 = s.rect(50,50,100,100,20,20).attr({ 'fill': "blue", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c2 = s.circle(125,125,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c2' })
g2 = s.group(r2,c2).attr({ 'id': 'g2' })

g2.appendTo( g1 );
g2.animate( { 'transform' : 'r360,125,125' },4000);

r3 = s.rect(0,0,100,100,20,20).attr({ 'fill': "yellow", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c3 = s.circle(75,75,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c3' })
g3 = s.group(r3,c3).attr({ 'id': 'g3' })

g3.appendTo( g2 )
g3.animate( { 'transform' : 'r360,75,75' },4000)

r4 = s.rect(-50,-50,100,100,20,20).attr({ 'fill': "green", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c4 = s.circle(25,25,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c4' })
g4 = s.group(r4,c4).attr({ 'id': 'g4' });
g4.appendTo( g3 )
g4.animate( { 'transform' : 'r360,25,25' },4000)
#--&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/pre&gt;</summary><category term="Wordpress"></category><category term="MCAD"></category></entry><entry><title>Onshape Featurescript Spur Gear 零件</title><link href="http://cadlab.mde.tw/post/onshape-featurescript-spur-gear-ling-jian.html" rel="alternate"></link><updated>2016-06-16T06:21:54+08:00</updated><author><name>Cad Lab</name></author><id>tag:cadlab.mde.tw,2016-06-16:post/onshape-featurescript-spur-gear-ling-jian.html</id><summary type="html">&lt;p&gt;從 &lt;a href="https://forum.onshape.com/discussion/4064/use-opfillet-for-a-sketch"&gt;https://forum.onshape.com/discussion/4064/use-opfillet-for-a-sketch&lt;/a&gt; 的討論, 我們得知, 目前無法利用 FeatureScript 在繪圖平面中利用 opFillet, 對特定平面圖元進行倒圓角運算, 因此延續&lt;a href="http://cadlab.mde.tw/post/onshape-featurescript-spur-gear-lun-kuo-hui-tu.html"&gt;上一篇利用漸開線正齒輪輪廓&lt;/a&gt;轉換為正齒輪零件, 就必須在實體模型中進行倒圓角運算.&lt;/p&gt;


&lt;p&gt;這裡的 FeatureScript 程式碼, 基本架構引用 &lt;a href="https://cad.onshape.com/documents/57494152e4b05f50e871a72c/w/a4a3f09939bf1f43a8e4f133/e/2b865798923d6f648f7196f9"&gt;Onshape 官方正齒輪繪圖 FeatureScript 程式第1版&lt;/a&gt; 的內容, 只將推導的漸開線點座標, 透過 skFitSpline 轉為平滑曲線, 但是原版的 offset 參數, 目前只導入 offsetAngle, 以便產生的正齒輪, 可以在組立件中進行囓合.&lt;/p&gt;
&lt;p&gt;17 齒漸開線正齒輪 FeatureScript 程式繪圖:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/summer_featurescript_spur_17t.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;170 齒漸開線正齒輪 FeatureScript 程式繪圖:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/summer_featurescript_spur_170t.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;2016 Spring 的協同產品設計實習課程, 就要在這個 Onshape FeatureScript 正齒輪零件程式的練習中劃下句點, 下學期的電腦輔助設計實習課程仍將採用 Onshape 與 FreeCAD, 當然 PTC Creo Parametric 年久失修的 Pro/Web.Link 仍可列入參考, 只是 Onshape 加上 FeatureScript 的魅力, 至今沒有其他 MCAD 套件可以比擬, 假如您是隸屬於特定團隊的電腦輔助機械設計工程師, 一定要試試 Onshape, 並且利用 FeatureScript 程式客製化產品開發流程中特定的重要零件. 一旦領略雲端電腦輔助機械設計套件的威力之後, 應該就再也回不去了.&lt;/p&gt;
&lt;p&gt;我們當然也知道台灣有許多創新產品開發公司, 至今仍然使用著多年前的 MACD 套件, 忍受著系統更新維護與版本老舊的諸多問題, 假如以購買一套桌上版的商用中端 MCAD 套件, 等於可以連續付月費使用 Onshape 5 年來說, 在日新月異的當下, 5 年前的任何一套 MCAD, 即便功能再強, 也早就應該要更迭換新了, 何況, 檢查一下過去 5 年來工程師為了應付機電整合與製程規劃, 儲存在特定電腦硬碟中的紛亂版本, 將設計研發重心逐步轉換到 Onshape 應該才是解決之道.&lt;/p&gt;
&lt;p&gt;以下為上述漸開線正齒輪零件繪圖的 FeatureScript 原始碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 355;
import(path : "onshape/std/geometry.fs", version : "355.0");

annotation { "Feature Type Name" : "Summer Spur Gear", "Feature Name Template" : "Spur Gear (#teeth teeth)", "Filter Selector" : "fs", "Editing Logic Function" : "editGearLogic" }
export const SpurGear = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "teeth", "UIHint" : "ALWAYS_HIDDEN" }
        definition.teeth is string; //used to name the feature only

        annotation { "Name" : "Number of teeth" }
        isInteger(definition.numTeeth, TEETH_BOUNDS);

        annotation { "Name" : "Input type" }
        definition.GearInputType is GearInputType;

        if (definition.GearInputType == GearInputType.module)
        {
            annotation { "Name" : "Module" }
            isLength(definition.module, MODULE_BOUNDS);
        }

        if (definition.GearInputType == GearInputType.diametralPitch)
        {
            annotation { "Name" : "Diametral pitch" }
            isReal(definition.diametralPitch, POSITIVE_REAL_BOUNDS);
        }

        if (definition.GearInputType == GearInputType.circularPitch)
        {
            annotation { "Name" : "Circular pitch" }
            isLength(definition.circularPitch, LENGTH_BOUNDS);
        }

        annotation { "Name" : "Pitch circle diameter" }
        isLength(definition.pitchCircleDiameter, LENGTH_BOUNDS);

        annotation { "Name" : "Pressure angle" }
        isAngle(definition.pressureAngle, PRESSURE_ANGLE_BOUNDS);

        annotation { "Name" : "Center hole" }
        definition.centerHole is boolean;

        if (definition.centerHole)
        {
            annotation { "Name" : "Hole diameter" }
            isLength(definition.centerHoleDia, CENTERHOLE_BOUNDS);

            annotation { "Name" : "Keyway" }
            definition.key is boolean;

            if (definition.key)
            {
                annotation { "Name" : "Key width" }
                isLength(definition.keyWidth, KEY_BOUNDS);

                annotation { "Name" : "Key height" }
                isLength(definition.keyHeight, KEY_BOUNDS);
            }
        }

        annotation { "Name" : "Select origin position" }
        definition.centerPoint is boolean;

        if (definition.centerPoint)
        {
            annotation { "Name" : "Sketch vertex for center", "Filter" : EntityType.VERTEX &amp;amp;&amp;amp; SketchObject.YES, "MaxNumberOfPicks" : 1 }
            definition.center is Query;
        }

        annotation { "Name" : "Extrude depth" }
        isLength(definition.gearDepth, BLEND_BOUNDS);

        annotation { "Name" : "Extrude direction", "UIHint" : "OPPOSITE_DIRECTION" }
        definition.flipGear is boolean;

        annotation { "Name" : "Offset" }
        definition.offset is boolean;

        if (definition.offset)
        {
            annotation { "Name" : "Root diameter" }
            isLength(definition.offsetClearance, ZERO_DEFAULT_LENGTH_BOUNDS);

            annotation { "Name" : "Outside diameter" }
            isLength(definition.offsetDiameter, ZERO_DEFAULT_LENGTH_BOUNDS);

            annotation { "Name" : "Tooth angle" }
            isAngle(definition.offsetAngle, ANGLE_360_ZERO_DEFAULT_BOUNDS);
        }
    }
    {
        var offsetDiameter = 0 * meter;
        var offsetClearance = 0 * meter;
        var offsetAngle = 0 * degree;

        if (definition.offset)
        {
            offsetDiameter = definition.offsetDiameter;
            offsetClearance = definition.offsetClearance;
            offsetAngle = definition.offsetAngle;
        }

        if (definition.centerHole &amp;amp;&amp;amp; definition.centerHoleDia &amp;gt;= definition.pitchCircleDiameter - 4 * definition.module)
        {
            throw regenError("Center hole diameter must be less than the root diameter", ["centerHoleDia"]);
        }

        if (definition.key &amp;amp;&amp;amp; definition.keyHeight / 2 + definition.centerHoleDia &amp;gt;= definition.pitchCircleDiameter - 4 * definition.module)
        {
            throw regenError("Center hole diameter plus Key height must be less than the root diameter", ["keyHeight"]);
        }
        // if no center vertex selected build gear on the front plane at the origin
        var location = vector(0, 0, 0) * meter;
        var sketchPlane = plane(location, vector(0, -1, 0), vector(1, 0, 0));
        var center3D = location;

        // else find location of selected vertex and its sketch plane and create a new sketch for the gear profile
        if (definition.centerPoint)
        {
            location = evaluateQuery(context, definition.center)[0];
            sketchPlane = evOwnerSketchPlane(context, { "entity" : location });
            center3D = evVertexPoint(context, { "vertex" : location });
        }

        const gearSketch = newSketchOnPlane(context, id + "gearSketch", { "sketchPlane" : sketchPlane });
        const center2D = worldToPlane(sketchPlane, center3D);

        var filletEdges = [];
        var regionPoint;
        // 漸開線近似點數
        var imax = 5;
        // 使用者所選的齒輪圓心 x 座標
        var midx = center2D[0];
        // 使用者所選的齒輪圓心 y 座標
        var midy = center2D[1];
        // 齒數
        var n = definition.numTeeth;
        // 模數
        var m = definition.module;
        // 壓力角, 單位為角度
        var pa = definition.pressureAngle;
        // 齒輪的節圓半徑
        var rp = m*n/2;

        // 正齒輪囓合用的定位線
        skLineSegment(gearSketch, "line", {
        "start" : vector(midx,midy),
        "end" : vector(midx,midy+rp)
        });

        // 齒根, 暫時不考慮納入 offsetClearance
        var d = 2.5*rp/n;
        // 齒頂圓半徑, 暫不考慮納入 offsetDiameter
        var ra = rp + m;
        // 基圓半徑
        var rb = rp*cos(pa);
        //print(rb);
        // 齒根圓半徑
        var rd = rp - d;
        // 分段後齒頂與齒根半徑差增量
        var dr = 0*meter;
        // 若 rb &amp;gt; rd 時從基圓開始繪製漸開線, 但是若 rd &amp;gt; rb, 則漸開線從 rd 畫到齒頂圓
        if (rd &amp;gt; rb)
        {
            // 半徑差的分段, 由齒根圓到齒頂圓
            dr = (ra-rd)/imax;
        }
        else
        {
            // 半徑差的分段, 由基圓到齒頂圓
            dr = (ra-rb)/imax;
        }
        // PI 為實數值沒有單位, tan(pa)也沒有單位, pa 已經設定單位為 degree
        var rot = PI/(2*n)*radian;
        // 用來設定 entity id 用的增量變數
        var nameId = 1;
        var r = 0*meter;
        // theta 為浮點數字
        var theta = 0;
        var inv = 0*radian;
        var inc = 0*radian;
        // 當 r=rp 時 ,計算 inv_rp 用來旋轉漸開線用
        // theta 為沒有單位的實數
        theta = sqrt((rp*rp)/(rb*rb)-1);
        // atan(theta) 為 radian
        // Onshape SG 的 const alpha 就是這裡的 inv_rp
        // Onshape SG 的 const beta 就是這裡的 rot-inv_rp
        var inv_rp = theta*radian-atan(theta);
        // 漸開線上點的 x 座標
        var xpt = 0*meter;
        // 漸開線上點的 y 座標
        var ypt = 0*meter;
        // 左側漸開線第1點座標 left first x and y
        var lfx = 0*meter;
        var lfy = 0*meter;
        // 右側漸開線第1點座標 right first x and y
        var rfx = 0*meter;
        var rfy = 0*meter;
        // 左側齒根圓上點座標 left x of dedendum point
        var lxd = 0*meter;
        var lyd = 0*meter;
        // 右側齒根圓上點座標 right x of dedendum point
        var rxd = 0*meter;
        var ryd = 0*meter;
        // 左側齒根圓上點座標 right x of dedendum point (advanced)
        var lxd_ad = 0*meter;
        var lyd_ad = 0*meter;
        var inc_ad = 0*radian;

        for (var j=0;j&amp;lt;n;j+=1)
        {
            var involute1 = [];
            var involute2 = [];
            var arcDone = false;
            var point1;
            var point2;

            // 當 j 增量時, 按照齒數輪廓繞行旋轉增量角度, 加入 offsetAngle 參數
            inc = (2.*j*PI/n)*radian+offsetAngle;
            inc_ad = (2.*(j+1)*PI/n)*radian+offsetAngle;
            if (rd&amp;gt;rb)
            {
                // 當齒根半徑因為齒數增多後大於基圓半徑時, 漸開線從齒根圓長起
                theta = sqrt((rd*rd)/(rb*rb)-1.);
                inv = theta*radian-atan(theta);
                // 左側漸開線第1點座標
                // 左側輪廓線配合逆時針旋轉 inc 角度
                lfx = midx+rd*sin(inv-rot-inv_rp+inc);
                lfy = midy+rd*cos(inv-rot-inv_rp+inc);
                point1 = vector(lfx, lfy);
                lxd = lfx;
                lyd = lfy;
                lxd_ad = midx+rd*sin(inv-rot-inv_rp+inc_ad);
                lyd_ad = midy+rd*cos(inv-rot-inv_rp+inc_ad);
                // 右側漸開線第1點座標
                // 右側輪廓線配合順時針旋轉 inc 角度
                rfx = midx-rd*sin(inv-rot-inv_rp-inc);
                rfy = midy+rd*cos(inv-rot-inv_rp-inc);
                point2 = vector(rfx, rfy);
                rxd = rfx;
                ryd = rfy;
            }
            else
            {
                // 當基圓半徑大於齒根圓時, 漸開線從基圓長起
                //theta = sqrt((rb*rb)/(rb*rb)-1.);
                theta = 0;
                inv = theta*radian-atan(theta);
                // 左側漸開線第1點座標
                lfx = midx+rb*sin(inv-rot-inv_rp+inc);
                lfy = midy+rb*cos(inv-rot-inv_rp+inc);
                point1 = vector(lfx, lfy);
                lxd = midx+rd*sin(inv-rot-inv_rp+inc);
                lyd = midy+rd*cos(inv-rot-inv_rp+inc);
                lxd_ad = midx+rd*sin(inv-rot-inv_rp+inc_ad);
                lyd_ad = midy+rd*cos(inv-rot-inv_rp+inc_ad);
                // 左側從基圓點到齒根圓點, 畫直線 left from base point to dedendum point
                skLineSegment(gearSketch, "line_lbd" ~ nameId, {
                "start" : vector(lfx,lfy),
                "end" : vector((lxd),(lyd))
                });
                // 右側漸開線第1點座標
                rfx = midx-rb*sin(inv-rot-inv_rp-inc);
                rfy = midy+rb*cos(inv-rot-inv_rp-inc);
                point2 = vector(rfx, rfy);
                rxd = midx-rd*sin(inv-rot-inv_rp-inc);
                ryd = midy+rd*cos(inv-rot-inv_rp-inc);
                // 右側從基圓點到齒根圓點, 畫直線 right from base point to dedendum point
                skLineSegment(gearSketch, "line_rbd" ~ nameId, {
                "start" : vector(rfx,rfy),
                "end" : vector((rxd),(ryd))
                });
            }
            // 處理齒根的圓弧
            if (!arcDone) // create base arc between involutes once per tooth
            {
                var mid = getArcMidPoint(center2D, vector(lxd_ad,lyd_ad), vector(rxd,ryd)); // sketch arc is arc 3 points so need addtional point on arc

                if (mid != undefined) // if no base cylinder present (due to pressure angle), don't draw it
                {
                    // 齒根圓上的圓弧
                    skArc(gearSketch, "arc-d" ~ nameId, {
                                "start" : vector(lxd_ad,lyd_ad),
                                "mid" : mid,
                                "end" : vector(rxd,ryd)
                            });
                }
                if (rd&amp;gt;rb)
                {   
                    // 只有在齒根圓半徑大於基圓時, 將漸開線起點作為倒圓角的基準點
                    // find points in 3D space where edges need to be filleted later
                    filletEdges = append(filletEdges, toWorldVector(planeToCSys(sketchPlane), point2, definition.gearDepth, definition.flipGear));
                    filletEdges = append(filletEdges, toWorldVector(planeToCSys(sketchPlane), point1, definition.gearDepth, definition.flipGear));
                }
                else
                {
                    // 當小齒數時, 從基圓到齒根圓有一條直線, 因此倒圓角基準點必須以齒根圓上的點為基準
                    // find points in 3D space where edges need to be filleted later
                    filletEdges = append(filletEdges, toWorldVector(planeToCSys(sketchPlane), vector(rxd, ryd), definition.gearDepth, definition.flipGear));
                    filletEdges = append(filletEdges, toWorldVector(planeToCSys(sketchPlane), vector(lxd, lyd), definition.gearDepth, definition.flipGear));
                }
                // find area to extrude
                regionPoint = vector(point1[0] * 0.95 + center2D[0]*0.05, point1[1] * 0.95+center2D[1]*0.05, 0 * meter);
                arcDone = true;
            }
            // 將漸開線第1點存入 involute1 與 involute2 陣列中
            involute1 = append(involute1, point1);
            involute2 = append(involute2, point2);

            for (var i=1; i&amp;lt;imax+1; i+= 1)
            {
                // 先處理中線左側的漸開線
                // 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if (rd&amp;gt;rb)
                {
                    r = rd+i*dr;
                }
                else
                {
                    r = rb+i*dr;
                }
                theta = sqrt((r*r)/(rb*rb)-1);
                var inv = theta*radian-atan(theta);
                // 漸開線上的點座標
                xpt = midx+r*sin(inv-rot-inv_rp+inc);
                ypt = midy+r*cos(inv-rot-inv_rp+inc);
                point1 = vector(xpt, ypt);
                // 更新漸開線點座標
                lfx = xpt;
                lfy = ypt;
                //nameId += 1;
                involute1 = append(involute1, point1);
            }
            // 紀錄左側漸開線的最後一點, 也就是齒頂圓上的點座標
            var lastlx = xpt;
            var lastly = ypt;
            // another side
            for (var i=1; i&amp;lt;imax+1; i+= 1)
            {
                if (rd&amp;gt;rb)
                {
                    r = rd+i*dr;
                }
                else
                {
                    r = rb+i*dr;
                }
                theta = sqrt((r*r)/(rb*rb)-1);
                var inv = theta*radian-atan(theta);
                // 漸開線上的點座標
                xpt = midx-r*sin(inv-rot-inv_rp-inc);
                ypt = midy+r*cos(inv-rot-inv_rp-inc);
                point2 = vector(xpt, ypt);
                // 更新漸開線點座標
                rfx = xpt;
                rfy = ypt;
                //nameId += 1;
                involute2 = append(involute2, point2);
            }
            var lastrx = xpt;
            var lastry = ypt;

            // create involute sketch splines
            skFitSpline(gearSketch, "spline-a" ~ nameId, {
                        "points" : involute1
                    });
            skFitSpline(gearSketch, "spline-b" ~ nameId, {
                        "points" : involute2
                    });
            // 要注意, 若對調 vector(lastrx, lastry) 與 vector(lastlx, lastly) 則無法求得中點
            var mid_a = getArcMidPoint(center2D, vector(lastrx,lastry), vector(lastlx,lastly));
            if (mid_a != undefined)
            {
                skArc(gearSketch, "arc-a" ~ nameId, {
                            "start" : vector(lastlx,lastly),
                            "mid" : mid_a,
                            "end" : vector(lastrx,lastry)
                        }); 
            }
            nameId += 1;
        }
        if (definition.centerHole)
        {
            if (definition.key)
            {
                var keyVector = vector(0, 1);
                var perpKeyVector = vector(-1, 0);
                var keyHeight = (definition.keyHeight + definition.centerHoleDia) / 2;

                var points = [
                    center2D - (definition.keyWidth / 2) * perpKeyVector,
                    center2D - (definition.keyWidth / 2) * perpKeyVector + keyHeight * keyVector,
                    center2D + (definition.keyWidth / 2) * perpKeyVector + keyHeight * keyVector,
                    center2D + (definition.keyWidth / 2) * perpKeyVector];

                for (var i = 0; i &amp;lt; size(points); i += 1)
                {
                    skLineSegment(gearSketch, "line" ~ nameId,
                            { "start" : points[i],
                                "end" : points[(i + 1) % size(points)]
                            });
                    nameId += 1;
                }
            }

            // center hole circle sketch
            skCircle(gearSketch, "Center", {
                        "center" : center2D,
                        "radius" : definition.centerHoleDia / 2
                    });
        }
    skSolve(gearSketch);

    extrude(context, id + "extrude1", {
                "entities" : qContainsPoint(qCreatedBy(id + "gearSketch", EntityType.FACE), toWorld(planeToCSys(sketchPlane), regionPoint)),
                "endBound" : BoundingType.BLIND,
                "depth" : definition.gearDepth,
                "oppositeDirection" : definition.flipGear
            });


    var filletEdges3D = [];

    for (var i = 0; i &amp;lt; size(filletEdges); i += 1)
    {
        // Find the edges that intersect the points previously collected
        filletEdges3D = append(filletEdges3D, qContainsPoint(qCreatedBy(id + "extrude1", EntityType.EDGE), filletEdges[i]));
    }

    const filletRadius = norm(filletEdges[1] - filletEdges[0]) / 4; // arbitrary fillet size = one fourth the distance between the edges

    if (filletRadius &amp;gt;= 0.2 * millimeter) // arbitrary small size assuming tooling cannot hold a fillet radius smaller than this
    {

        try(opFillet(context, id + "fillet1", {
                        "entities" : qUnion(filletEdges3D),
                        "radius" : filletRadius
                    }));

    }

    // Remove sketch entities - no longer required
    opDeleteBodies(context, id + "delete", { "entities" : qCreatedBy(id + "gearSketch") });

    // created PCD sketch
    const PCDSketch = newSketchOnPlane(context, id + "PCDsketch", { "sketchPlane" : sketchPlane });
    skCircle(PCDSketch, "PCD", {
                "center" : center2D,
                "radius" : definition.pitchCircleDiameter / 2,
                "construction" : true
            });
    skSolve(PCDSketch);
    });

function getArcMidPoint(center is Vector, start is Vector, end is Vector)
{
    // need to convert 2D vectors back to 3D for vector angle calculation
    const center3D = vector(center[0], center[1], 0 * meter);
    const start3D = vector(start[0], start[1], 0 * meter);
    const end3D = vector(end[0], end[1], 0 * meter);

    const angle = vectorAngle(center3D - start3D, center3D - end3D) / 2;
    // if angle is less than zero then arc was flipped
    if (angle &amp;lt;= 0 * radian)
        return;
    start = center - start;

    var ca = cos(angle); // in radians
    var sa = sin(angle);
    return center - vector(ca * start[0] - sa * start[1], sa * start[0] + ca * start[1]);
}

function vectorAngle(vector1 is Vector, vector2 is Vector)
{
    // function assumes vectors are on a 2D plane so Z is always zero and the normal vector is always [0, 0, 1]
    return atan2(dot(vector(0, 0, 1), cross(vector1, vector2)), dot(vector1, vector2));
}

function toWorldVector(csys is CoordSystem, point is Vector, depth is map, direction is boolean) returns Vector
{
    var dir = direction ? -1 : 1;
    var vector3D = vector(point[0], point[1], dir * depth / 2);
    return toWorld(csys, vector3D);
}

export function editGearLogic(context is Context, id is Id, oldDefinition is map, definition is map, isCreating is boolean, specifiedParameters is map, hiddenBodies is Query) returns map
{
    // isCreating is required in the function definition for edit logic to work when editing an existing feature
    if (oldDefinition.numTeeth != definition.numTeeth)
    {
        definition.module = definition.pitchCircleDiameter / definition.numTeeth;
        definition.circularPitch = definition.module * PI;
        definition.diametralPitch = 1 * inch / definition.module;
        definition.teeth = toString(definition.numTeeth); //to name the feature
        return definition;
    }

    if (oldDefinition.circularPitch != definition.circularPitch)
    {
        definition.module = definition.circularPitch / PI;
        definition.pitchCircleDiameter = (definition.circularPitch * definition.numTeeth) / PI;
        definition.diametralPitch = 1 * inch / definition.module;
        return definition;
    }

    if (oldDefinition.pitchCircleDiameter != definition.pitchCircleDiameter)
    {
        definition.module = definition.pitchCircleDiameter / definition.numTeeth;
        definition.circularPitch = (PI * definition.pitchCircleDiameter) / definition.numTeeth;
        definition.diametralPitch = 1 * inch / definition.module;
        return definition;
    }

    if (oldDefinition.module != definition.module)
    {
        definition.circularPitch = definition.module * PI;
        definition.pitchCircleDiameter = definition.numTeeth * definition.module;
        definition.diametralPitch = 1 * inch / definition.module;
        return definition;
    }

    if (oldDefinition.diametralPitch != definition.diametralPitch)
    {
        definition.circularPitch = PI / (definition.diametralPitch / inch);
        definition.module = definition.circularPitch / PI;
        definition.pitchCircleDiameter = (definition.circularPitch * definition.numTeeth) / PI;
        return definition;
    }

    return definition;
}

const TEETH_BOUNDS =
{
            "min" : 4,
            "max" : 250,
            (unitless) : [4, 25, 250]
        } as IntegerBoundSpec;

const PRESSURE_ANGLE_BOUNDS =
{
            "min" : 12 * degree,
            "max" : 35 * degree,
            (degree) : [12, 20, 35]
        } as AngleBoundSpec;

const MODULE_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.001, 500],
            (centimeter) : 0.1,
            (millimeter) : 1.0,
            (inch) : 0.04
        } as LengthBoundSpec;

const CENTERHOLE_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.01, 500],
            (centimeter) : 1.0,
            (millimeter) : 10.0,
            (inch) : 0.375
        } as LengthBoundSpec;

const KEY_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.003, 500],
            (centimeter) : 0.3,
            (millimeter) : 3.0,
            (inch) : 0.125
        } as LengthBoundSpec;

export enum GearInputType
{
    annotation { "Name" : "Module" }
    module,
    annotation { "Name" : "Diametral pitch" }
    diametralPitch,
    annotation { "Name" : "Circular pitch" }
    circularPitch
}
&lt;/pre&gt;</summary><category term="Onshape"></category><category term="FeatureScript"></category></entry><entry><title>Onshape Featurescript Spur Gear 輪廓繪圖</title><link href="http://cadlab.mde.tw/post/onshape-featurescript-spur-gear-lun-kuo-hui-tu.html" rel="alternate"></link><updated>2016-06-15T01:38:02+08:00</updated><author><name>Cad Lab</name></author><id>tag:cadlab.mde.tw,2016-06-15:post/onshape-featurescript-spur-gear-lun-kuo-hui-tu.html</id><summary type="html">&lt;p&gt;學習 Onshape 可以從 614 頁的 pdf 格式導引手冊: &lt;a href="https://cad.onshape.com/help/PDF/Onshape.pdf"&gt;https://cad.onshape.com/help/PDF/Onshape.pdf&lt;/a&gt; 下手, 在手動操作逐漸熟悉之後, 就可以透過下列的 FeatureScript 程式客製化理想中的各種零件, 這裡先來看看漸開線正齒輪輪廓繪圖, 有關齒輪的參考資料, 請參閱 &lt;a href="http://khkgears.net/gear-knowledge/"&gt;http://khkgears.net/gear-knowledge/&lt;/a&gt;.&lt;/p&gt;


&lt;p&gt;從 &lt;a href="http://chiamingyen.github.io/kmolab/blog/ji-jie-she-ji-gong-cheng-shi-de-she-ji-mo-ni-yu-shi-zuo.html"&gt;機械設計工程師的設計模擬與實作&lt;/a&gt; 文章中, 可以看到利用 Brython 直接在網際畫布上以小段直線繪製漸開線正齒輪輪廓的程式原始碼. 類似的正齒輪繪圖可以參考 &lt;a href="http://web.mit.edu/harishm/www/papers/involuteEWC.pdf"&gt;Approximation of Involute Curves for CAD-System Processing&lt;/a&gt; 論文中的說明, 完成 &lt;a href="http://www.arc.id.au/GearDrawing.html"&gt;靜態與動態的漸開線正齒輪繪圖與模擬&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;以下主要以教導 FeatureScript 為目的, 依據下列圖示作為參考:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/spur_gear_dimension_4.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;假設齒數為 n, 模數為 m, 壓力角為 pa, 則正齒輪的節圓半徑為 &lt;span class="math"&gt;\(rp = m*n/2\)&lt;/span&gt;, 且基圓半徑 &lt;span class="math"&gt;\(rb = rp*cos(pa)\)&lt;/span&gt;, 假設齒根 &lt;span class="math"&gt;\(d = 2.5*rp/n\)&lt;/span&gt;, 齒頂圓半徑 &lt;span class="math"&gt;\(ra = rp + m\)&lt;/span&gt;, 齒根圓半徑 &lt;span class="math"&gt;\(rd = rp - d\)&lt;/span&gt;, 接著當齒數 n 小於 &lt;span class="math"&gt;\(2.5/(1-cos(pa))\)&lt;/span&gt; 時就能夠從基圓開始繪製漸開線到齒頂圓, 若 n 大於 &lt;span class="math"&gt;\(2.5/(1-cos(pa))\)&lt;/span&gt;, 則漸開線必須從齒根圓畫起, 而不是從基圓畫起 (因為基圓半徑已經小於齒根圓半徑). 有關這一點, Onshape 官方釋出的漸開線&lt;a href="https://cad.onshape.com/documents/57494152e4b05f50e871a72c/w/a4a3f09939bf1f43a8e4f133/e/2b865798923d6f648f7196f9"&gt;正齒輪繪圖 FeatureScript 程式第1版&lt;/a&gt;也未能納入考量, 因此當選擇壓力角 20 度時, 若齒數超過 43 齒, 或者選擇壓力角 15.5 度, 當齒數超過 70 齒, 正齒輪的輪廓就會出錯. 之後當以下的練習完成後, 就可以將漸開線納入 spline 中, 並且加上齒輪底部的導倒圓角後, 就能夠修正上述的錯誤.&lt;/p&gt;
&lt;p&gt;以下為 17 齒, 模數 20 mm, 壓力角 20 度的漸開線正齒輪輪廓繪圖:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/onshape_spur_gear1.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;以下為 170 齒, 模數 20 mm, 壓力角 20 度的漸開線正齒輪輪廓繪圖:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/onshape_spur_gear2.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;以下為對應的 FeatureScript 正齒輪輪廓繪圖程式碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 355;
import(path : "onshape/std/geometry.fs", version : "355.0");

annotation { "Feature Type Name" : "Spur2" }
export const spur = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        // 正齒輪齒數, 由使用者輸入, 型別為整數
        annotation { "Name" : "Number of Gear Tooth" }
        isInteger(definition.n, POSITIVE_COUNT_BOUNDS);
        // 正齒輪模數, 由使用者輸入, 型別為長度, 為內建尺寸單位
        annotation { "Name" : "Module" }
        isLength(definition.module, LENGTH_BOUNDS);
        // 正齒輪壓力角, 由使用者輸入, 型別為角度, 為內建角度單位
        annotation { "Name" : "Pressure Angle" }
        isAngle(definition.pa, ANGLE_360_BOUNDS);
        // 正齒輪圓心座標點, 由使用者選擇
        annotation { "Name" : "Select a point", "Filter" : EntityType.VERTEX, "MaxNumberOfPicks" : 1 }
        definition.point is Query;
    }
    {
        // Precondition 中的查詢, 需要 evalue 才能傳回對應的 entity
        var location = evaluateQuery(context, definition.point)[0];
        // location 變數為點座標對應的 entity, 必須透過 evVetexPoint 的評量才能傳回對應的點座標
        var center3D = evVertexPoint(context, {
                "vertex" : location
        });

        // 作圖平面利用 evOwnerSketch 評量, 與 location entity 同一個平面
        var sketchPlane = evOwnerSketchPlane(context, {
                "entity" : location
        });
        // 作圖畫
        const gearSketch = newSketchOnPlane(context, id + "gearSketch", {
                "sketchPlane" : sketchPlane
        });
        // 利用 worldToPlane, 將 center3D 轉換為 sketchPlane 上的平面點座標
        const center2D = worldToPlane(sketchPlane, center3D);
        //print(center2D);
        // 漸開線近似點數
        var imax = 5;
        // 使用者所選的齒輪圓心 x 座標
        var midx = center2D[0];
        // 使用者所選的齒輪圓心 y 座標
        var midy = center2D[1];
        // 齒數
        var n = definition.n;
        // 模數
        var m = definition.module;
        // 壓力角, 單位為角度
        var pa = definition.pa;
        // 齒輪的節圓半徑
        var rp = m*n/2;
        skLineSegment(gearSketch, "line", {
        "start" : vector(midx,midy),
        "end" : vector(midx,midy+rp)
        });
        // 齒根
        var d = 2.5*rp/n;
        // 齒頂圓半徑
        var ra = rp + m;
        // 基圓半徑
        var rb = rp*cos(pa);
        //print(rb);
        // 齒根圓半徑
        var rd = rp - d;
        // 分段後齒頂與齒根半徑差增量
        var dr = 0*meter;
        // 若 rb &amp;gt; rd 時從基圓開始繪製漸開線, 但是若 rd &amp;gt; rb, 則漸開線從 rd 畫到齒頂圓
        if (rd &amp;gt; rb)
        {
            // 半徑差的分段, 由齒根圓到齒頂圓
            dr = (ra-rd)/imax;
        }
        else
        {
            // 半徑差的分段, 由基圓到齒頂圓
            dr = (ra-rb)/imax;
        }
        // PI 為實數值沒有單位, tan(pa)也沒有單位, pa 已經設定單位為 degree, 這裡為了與 radian 運算
        // 系統會自動轉為 radian
        var rot = PI/(2*n)*radian;
        //print(sigma);
        // 分別用來設定 entity id 用的增量變數
        var nameId = 1;
        var nameId2 = 1;
        var r = 0*meter;
        // theta 為浮點數字
        var theta = 0;
        var inv = 0*radian;
        var inc = 0*radian;
        // 當 r=rp 時 ,計算 inv_rp 用來旋轉漸開線用
        // theta 為沒有單位的實數
        theta = sqrt((rp*rp)/(rb*rb)-1);
        // atan(theta) 為 radian
        var inv_rp = theta*radian-atan(theta);
        // 漸開線上點的 x 座標
        var xpt = 0*meter;
        // 漸開線上點的 y 座標
        var ypt = 0*meter;
        // 左側漸開線第1點座標 left first x and y
        var lfx = 0*meter;
        var lfy = 0*meter;
        // 右側漸開線第1點座標 right first x and y
        var rfx = 0*meter;
        var rfy = 0*meter;
        // 左側齒根圓上點座標 left x of dedendum point
        var lxd = 0*meter;
        var lyd = 0*meter;
        // 右側齒根圓上點座標 right x of dedendum point
        var rxd = 0*meter;
        var ryd = 0*meter;
        // 左側齒根圓上點座標 right x of dedendum point (advanced)
        var lxd_ad = 0*meter;
        var lyd_ad = 0*meter;
        var inc_ad = 0*radian;
        for (var j=0;j&amp;lt;n;j+=1)
        {
            // 當 j 增量時, 按照齒數輪廓繞行旋轉增量角度
            inc = (2.*j*PI/n)*radian;
            inc_ad = (2.*(j+1)*PI/n)*radian;
            if (rd&amp;gt;rb)
            {
                // 當齒根半徑因為齒數增多後大於基圓半徑時, 漸開線從齒根圓長起
                theta = sqrt((rd*rd)/(rb*rb)-1.);
                inv = theta*radian-atan(theta);
                // 左側漸開線第1點座標
                // 左側輪廓線配合逆時針旋轉 inc 角度
                lfx = midx+rd*sin(inv-rot-inv_rp+inc);
                lfy = midy+rd*cos(inv-rot-inv_rp+inc);
                lxd = lfx;
                lyd = lfy;
                lxd_ad = midx+rd*sin(inv-rot-inv_rp+inc_ad);
                lyd_ad = midy+rd*cos(inv-rot-inv_rp+inc_ad);
                // 右側漸開線第1點座標
                // 右側輪廓線配合順時針旋轉 inc 角度
                rfx = midx-rd*sin(inv-rot-inv_rp-inc);
                rfy = midy+rd*cos(inv-rot-inv_rp-inc);
                rxd = rfx;
                ryd = rfy;
                // 齒根圓上的直線 on dedendum points
                skLineSegment(gearSketch, "line_dd" ~ nameId, {
                "start" : vector(rxd,ryd),
                "end" : vector((lxd_ad),(lyd_ad))
                });
            }
            else
            {
                // 當基圓半徑大於齒根圓時, 漸開線從基圓長起
                theta = sqrt((rb*rb)/(rb*rb)-1.);
                inv = theta*radian-atan(theta);
                // 左側漸開線第1點座標
                lfx = midx+rb*sin(inv-rot-inv_rp+inc);
                lfy = midy+rb*cos(inv-rot-inv_rp+inc);
                lxd = midx+rd*sin(inv-rot-inv_rp+inc);
                lyd = midy+rd*cos(inv-rot-inv_rp+inc);
                lxd_ad = midx+rd*sin(inv-rot-inv_rp+inc_ad);
                lyd_ad = midy+rd*cos(inv-rot-inv_rp+inc_ad);
                // 從基圓點到齒根圓點, 畫直線 left from base point to dedendum point
                skLineSegment(gearSketch, "line_lbd" ~ nameId, {
                "start" : vector(lfx,lfy),
                "end" : vector((lxd),(lyd))
                });
                // 右側漸開線第1點座標
                rfx = midx-rb*sin(inv-rot-inv_rp-inc);
                rfy = midy+rb*cos(inv-rot-inv_rp-inc);
                rxd = midx-rd*sin(inv-rot-inv_rp-inc);
                ryd = midy+rd*cos(inv-rot-inv_rp-inc);
                // 從基圓點到齒根圓點, 畫直線 right from base point to dedendum point
                skLineSegment(gearSketch, "line_rbd" ~ nameId, {
                "start" : vector(rfx,rfy),
                "end" : vector((rxd),(ryd))
                });
                // 齒根圓上的直線 on dedendum points
                skLineSegment(gearSketch, "line_dd" ~ nameId, {
                "start" : vector(rxd,ryd),
                "end" : vector((lxd_ad),(lyd_ad))
                });
            }

            for (var i=1; i&amp;lt;imax+1; i+= 1)
            {
                // 先處理中線左側的漸開線
                // 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if (rd&amp;gt;rb)
                {
                    r = rd+i*dr;
                }
                else
                {
                    r = rb+i*dr;
                }
                theta = sqrt((r*r)/(rb*rb)-1);
                var inv = theta*radian-atan(theta);
                // 漸開線上的點座標
                xpt = midx+r*sin(inv-rot-inv_rp+inc);
                ypt = midy+r*cos(inv-rot-inv_rp+inc);
                // lxd, lyd 為漸開線上的繪線起點座標
                skLineSegment(gearSketch, "lineb" ~ nameId, {
                "start" : vector(lfx,lfy),
                "end" : vector((xpt),(ypt))
                });
                // 更新漸開線點座標
                lfx = xpt;
                lfy = ypt;
                nameId += 1;
            }
            // 紀錄左側漸開線的最後一點, 也就是齒頂圓上的點座標
            var lastlx = xpt;
            var lastly = ypt;
            // another side
            for (var i=1; i&amp;lt;imax+1; i+= 1)
            {
                if (rd&amp;gt;rb)
                {
                    r = rd+i*dr;
                }
                else
                {
                    r = rb+i*dr;
                }
                theta = sqrt((r*r)/(rb*rb)-1);
                var inv = theta*radian-atan(theta);
                // 漸開線上的點座標
                xpt = midx-r*sin(inv-rot-inv_rp-inc);
                ypt = midy+r*cos(inv-rot-inv_rp-inc);
                // rxd, ryd 為漸開線上的繪線起點座標
                skLineSegment(gearSketch, "linec" ~ nameId, {
                "start" : vector(rfx,rfy),
                "end" : vector((xpt),(ypt))
                });
                // 更新漸開線點座標
                rfx = xpt;
                rfy = ypt;
                nameId += 1;
            }
            var lastrx = xpt;
            var lastry = ypt;
            // 齒頂連線
            skLineSegment(gearSketch, "lined" ~ nameId2, {
            "start" : vector(lastlx,lastly),
            "end" : vector(lastrx,lastry)
            });
            nameId2 += 1;
        }
    skSolve(gearSketch);
    });
&lt;/pre&gt;

&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="Onshape"></category><category term="FeatureScript"></category></entry><entry><title>電腦輔助設計室相關區域網路設定</title><link href="http://cadlab.mde.tw/post/dian-nao-fu-zhu-she-ji-shi-xiang-guan-qu-yu-wang-lu-she-ding.html" rel="alternate"></link><updated>2016-06-14T22:36:38+08:00</updated><author><name>Cad Lab</name></author><id>tag:cadlab.mde.tw,2016-06-14:post/dian-nao-fu-zhu-she-ji-shi-xiang-guan-qu-yu-wang-lu-she-ding.html</id><summary type="html">&lt;p&gt;今天早上發現一台 Asus 電腦, 裝了 IIS 8 的伺服器佔用了 17.9 的 IPV4 網路位址, 導致原先配置的 Ubuntu 16.04 代理主機無法正常連線.&lt;/p&gt;


&lt;p&gt;其實自從 2012 年起台灣就已經逐步完善 IPV6 的網路環境, 而且各種最新的操作系統也都已經提供 IPV6 相關協定的支援, 但是許多用戶仍然只用 IPV4 協定, 而且無論是客戶端或伺服器端, 一律搶佔已經不敷分配的 IPV4 網路位址.&lt;/p&gt;
&lt;p&gt;當然, 電腦輔助設計室周遭相關的區域網路, 目前只有兩種伺服器非採用 IPV4 協定不可, 一種是各式 CAD/CAE/CAM/PLM 軟體的網路認証主機, 一種則是同時支援 IPV4/IPV6 的 Proxy Servers.&lt;/p&gt;
&lt;p&gt;各式 CAD/CAE/CAM/PLM 軟體的網路認証主機, 早就已經支援 IPV6, 因此採用 IPV6 協定設置的認証主機, 可以服務純 IPV6 的客戶端, 但是仍然有許多的客戶端仍然使用純 IPV4 協定上網, 因此這些客戶端除非採用內部虛擬主機的自我認証, 否則仍然必須採用 IPV4 協定, 連接到區域或廣域網路上的認証伺服器.&lt;/p&gt;
&lt;p&gt;在台灣教育界有一個非常有趣的現象, 假如用戶堅持要使用合法購買的各式 CAD/CAE/CAM/PLM 軟體, 負責管理的團隊就必須花錢買罪受, 肩負多元合法軟體的認証伺服器的管理, 而且大部份負責代理這些軟體套件的公司, 都希望將網路認証授權綁在特定的封閉區域網路上, 一來, 可以多賣些套數, 二來也能避開紛擾較多的廣域網路認証主機的管理工作.&lt;/p&gt;
&lt;p&gt;上面提到佔用合法 IP 位址的電腦, 網卡的硬體位址以 9c:5c:8e 開頭, 這個網卡從 &lt;a href="http://aruljohn.com/mac/9C5C8E"&gt;http://aruljohn.com/mac/9C5C8E&lt;/a&gt; 就可以得知來自 Asus, 因此合理的推論, 是一台 Asus 的伺服器, 並且從 http 連線可以看到 IIS 8, 因此應該是安裝 MS 2012 Server 以上的伺服操作系統. 並且從已經開啟的 3389 埠號, 也可以確定 Remote Desktop 已經啟用, 並且允許廣域網路上的任何主機連線. 比較特殊的是沒有任何的 https 埠號啟用, 因此假如這台伺服器提供任何需要使用者輸入帳號密碼的應用, 這些帳號密碼已經透過明碼傳遞曝露在區域網路的封包中.&lt;/p&gt;
&lt;p&gt;其實, 上述合法 IPV4 位址被搶佔的問題, 早就可以透過 MAC 綁定 IPV4 的方案解決, 但是因為電腦輔助設計室中的伺服器數量超過 30 台, 許多伺服器的任務多元, 且經常更換, 因此自 2015 年秋季開始, 已經透過校方建置的雲端虛擬主機逐步取代實體主機, 而且部份上課的網路連線也將採純 IPV6 設定上網, 一旦各 Proxy Server 的任務確定, 就可以將伺服器 MAC 位址與 IPV4 位址綁定, 上述的網址佔用問題就不會存在.&lt;/p&gt;
&lt;p&gt;接下來, 看一下有關電腦輔助設計室相關區域網路的 IPV6 網路設定, 虎尾科技大學機械設計工程系的 IPV6 網址區段為 2001:288:6004:17, 路由器的通道為 2001:288:6004:17::254, 而校方的 DNS 為 2001:288:6004:1::2, 中華電信的 DNS 則為 2001:b000:168::1, 因此使用者要設定 IPV6 網路連線, 只需要知道自己電腦所配置的網段即可.&lt;/p&gt;
&lt;p&gt;從 IPV6 的網路定址格式, 機械設計工程系可用網段為 2001:288:6004:17:0000:0000:0000:0000 ~ 2001:288:6004:17:FFFF:FFFF:FFFF:FFFF, 總共可配置 IPV6 總數為 16^16 = 1.8446744e+19, 可以透過教師編號 (例如為 3001), 將則其所屬的學生與實習研究室 IPV6 分配網段為 2001:288:6004:17:3001:0000:0000:0000 ~ 2001:288:6004:17:3001:FFFF:FFFF:FFFF (可配置位址總數為 16^12 = 2.8147498e+14), 且將 2001:288:6004:17:0000:0000:0000:0000 ~ 2001:288:6004:17:0000:0000:0000:FFFF 保留給電腦輔助設計室與工作站室相關主機使用 (可配置 IPV6 位址總數為 16^4 = 65536), 而行政管理相關的 IPV6 網段則使用 2001:288:6004:17:168:0000:0000:0000 ~ 2001:288:6004:17:168:FFFF:FFFF:FFFF (可配置位址總數為 16^12 = 2.8147498e+14).&lt;/p&gt;
&lt;p&gt;之後, 將要利用回收的 20 個 IPV4 網址來配置同時支援 IPV4/IPV6 的 Proxy Server, 並且利用雙協定支援的 DNS 來配置這些伺服器, 遙望 IPV6 的世界, 應該再沒有 IPV6 網址短缺的機會了!&lt;/p&gt;</summary><category term="電腦輔助設計室"></category><category term="IPV6"></category><category term="IPV4"></category></entry><entry><title>Onshape Featurescript Tutorial 導引</title><link href="http://cadlab.mde.tw/post/onshape-featurescript-tutorial-dao-yin.html" rel="alternate"></link><updated>2016-06-14T22:36:38+08:00</updated><author><name>Cad Lab</name></author><id>tag:cadlab.mde.tw,2016-06-14:post/onshape-featurescript-tutorial-dao-yin.html</id><summary type="html">&lt;p&gt;Onshape 配合公開 FeatureScript 特徵程式語言的過程, 特別製作了一個詳細的教學導引:&lt;a href="https://cad.onshape.com/FsDoc/tutorials/create-a-slot-feature.html"&gt;https://cad.onshape.com/FsDoc/tutorials/create-a-slot-feature.html&lt;/a&gt;, 從這個導引中, 可以一窺 FeatureScript 的基本用法.&lt;/p&gt;


&lt;p&gt;左下角所謂的頁面創建功能 (也就是 + 號所在), 增加了創建 Feature Studio (特徵工房) 的選項, 可以讓使用者利用特徵工房中的 IDE (Integrated Development Environment) 環境, 開發獨特的客製化特徵程式.&lt;/p&gt;
&lt;p&gt;所以 Feature Studio 是 Onshape 的一種特殊頁面 (Tab), 其中提供編修 FeatureScript 程式的各種工具.&lt;/p&gt;
&lt;p&gt;進入 Feature Studio 後, 通常第一件事就是按下 New Feature 按鈕, 可以在特徵程式編輯區 (採用 &lt;a href="https://github.com/ajaxorg/ace"&gt;Ace.js&lt;/a&gt;) 中帶出 FeatureScript 程式的 Template codes (程式模版). 程式模版中包含所導入的 FeatureScript 程式庫版本, 以及即將讓使用者定義的客製化特徵函式區, 模版程式如下:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
// 宣告所使用的 FeatureScript 版次
FeatureScript 355;
// 配合所使用的 FeatureScript 版次, 導入 geometry 標準程式庫
import(path : "onshape/std/geometry.fs", version : "355.0");

// 利用 New Feature 所產生的程式模版, 包含 annotation 與 myFeature 常數的 export
// 其中使用了匿名函式的立即實例化, 使用者負責填入此一匿名函式的 precondition 與函式內容
// precondition 區主要在設定 FeatureScript 的 GUI 介面, 而函式內容則可實際產生各式特徵操作
annotation { "Feature Type Name" : "My Feature" }
export const myFeature = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        // 特徵程式的使用者介面對話設計, 包括輸入表單, 各式選單以及使用者動態選擇的各種幾何特徵
    }
    {
        // 定義函式的幾何操作內容
    });
&lt;/pre&gt;

&lt;p&gt;在 precondition 的大括號中間, 以鍵盤輸入 qu, FeatureScript Studio 就會啟動 Autocompletion 功能, 列出可以選用的 Query 設定, 並且列出詳細的使用說明, 其中的 Query parameter 是 snippet 小程式段外, 其餘都是查詢函式.&lt;/p&gt;
&lt;p&gt;Query parameter 的程式段如下:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
annotation { "Name" : "My Query", "Filter" : EntityType.FACE, "MaxNumberOfPicks" : 1 }
definition.myQuery is Query;
&lt;/pre&gt;

&lt;p&gt;當使用者在 precondition 對話區建立兩個查詢變數後, 就可以提交 (commit) 所增加的 FeatureScript 程式, 提交程式的目的在讓其他的頁面 (Tabs) 可以使用此一特徵程式. 另外假如 Feature Studio 中有新增資料尚未提交, 頁面上的特徵程式名稱前面會多一個 * 號, 一旦提交後, 此一 * 符號就會消失, 表示所有新增或編修的 FeatureScript 程式都已經提交到 Document 的模型本體.&lt;/p&gt;
&lt;p&gt;FeatureScript 語法中的 annotation 資料型別為 map, 類似 Python 的 Dictionary 資料型別, 且 map 的 key 一律為字串, 以 slot 程式範例而言, annotation { "Feature Type Name" : "Slot" } 中的 "Feature Type Name" 為每一個特徵函式的必要字串鍵值, 這裡的對應名稱為 "slot".&lt;/p&gt;
&lt;p&gt;從導引影片的操作, 也可以看到當使用者利用某一個平面草圖執行擠出後, 原先的草圖將會內定隱藏, 但隨後將需要選擇此一草圖上的其他線段, 因此必須在特徵瀏覽視窗中, 將此草圖顯示出來.&lt;/p&gt;
&lt;p&gt;另外, 當使用者在設計 FeatureScript 程式的 Query 對話區表單時, 可以透過 "Filter" 字串鍵進行控制可選的幾何元素, 例如, "Slot path" 對應的 "Filter" 為 EntityType.EDGE, 表示只能選擇 EDGE 幾何元件, 且透過 "MaxNumberOfPicks", 限定只能選擇一個 EDGE.
"Part to cut" 的 Query 則以 EntityType.BODY &amp;amp;&amp;amp; BodyType.SOLID 界定, 表示只能選擇 SOLID BODY.&lt;/p&gt;
&lt;p&gt;其次, FeatureScript 的所有尺寸, 角度與重量變數, 都隨使用者所選擇的單位而自動換算, 而且支援不同單位的&lt;a href="https://cad.onshape.com/FsDoc/intro.html"&gt;混合運算&lt;/a&gt;, 因此除了在互動區設定的 definition.variable_name 會根據 Onshape Document 中的單位為準外, 其他在函式定義過程中新增的其他變數, 必須自行加註單位, 否則會產生具單位尺寸與無單位設定的變數運算的錯誤.&lt;/p&gt;
&lt;p&gt;接下來, 當使用者開始進入函式內容的幾何模型操作時, 就必須對 id 型別有些認識. 模型主體 (Context) 中的所有特徵, 子特徵與操作, 都配置獨特的 id 加以辨識. 獨特的 id 可以在查詢, 錯誤回報或者取用特徵或操作時有所依據. id 的標示依照模型本體中各特徵與操作的關係, 以從屬架構表示. 也就是說 ,每一個操作項目的 id 都有其上層對應項目的 id. 過程中可以利用 newId() 函式來產生根項目 id, 隨後的子 id 則利用 + 運算子進行附加.&lt;/p&gt;
&lt;p&gt;在 Onshape FeatureScript 手冊中舉例, id + "foo" 中的 "foo" 就是子項目的 id 名稱, 而其父項目就是 id 變數. 依此類推, id + "foo" + "bar" 的就是以 "bar" 作為子項目的 id, 而其父項目的 id 就是 id + "foo". 而且在 FeatureScript 中 id 的資料型別為陣列, 其算元素為字串, 可以經過陣列元素表示各項目的路徑. &lt;/p&gt;
&lt;p&gt;例如, newId() + "foo" + "bar" 等同 id 值為 ["foo", "bar"], 但是實際操作仍以前面的用法為主.&lt;/p&gt;
&lt;p&gt;slot 教學導引的後段操作, 接續在互動介面區所設定的兩個 Query 與一個 Parameter 輸入, Query1 是選擇 "Slot path", 並將選擇與 definition.slotPath 變數對應, Query2 則選擇 "Part to cut", 以 definition.partToCut 表示, 而切槽的寬度則由使用者在欄位中輸入, 以 definition.width 變數表示.&lt;/p&gt;
&lt;p&gt;接下來, 則以 definition.slotPath 透過 opExtrude 操作長出橫貫 "Part to cut" 本體的平面, 接著利用 opThicken 操作, 對用來切槽的平面增加厚度, 而且一旦平面加厚成為實體之後, 就利用 opDeleteBodies 操作, 將此平面刪除, 最後的操作則是利用 opBoolean 操作, 以增厚的平面實體對 "Part to cut" 進行除料, 就完成 slot 客製 FeatureScript 程式的製作.&lt;/p&gt;
&lt;p&gt;slot FeatureScript 程式碼如下:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 355;
import(path : "onshape/std/geometry.fs", version : "355.0");

annotation { "Feature Type Name" : "Slot" }
export const slot = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        // Query for EDGE entity
        annotation { "Name" : "Slot path", "Filter" : EntityType.EDGE, "MaxNumberOfPicks" : 1 }
        definition.slotPath is Query;
        // Query for Body entity
        annotation { "Name" : "Part to cut", "Filter" : EntityType.BODY &amp;&amp; BodyType.SOLID, "MaxNumberOfPicks" : 1 }
        definition.partToCut is Query;
        // parameter input field for width
        annotation { "Name" : "Width" }
        isLength(definition.width, LENGTH_BOUNDS);
    }
    {
        // Extrude operation, id is extrude1
        opExtrude(context, id + "extrude1", {
               "entities" : definition.slotPath,
               "direction" : evOwnerSketchPlane(context, {"entity" : definition.slotPath}).normal,
               "endBound" : BoundingType.THROUGH_ALL,
               "startBound" : BoundingType.THROUGH_ALL
        });

        // Thicken operation for extrude1 entity
        opThicken(context, id + "thicken1", {
               "entities" : qCreatedBy(id + "extrude1", EntityType.BODY),
               "thickness1" : definition.width / 2,
               "thickness2" : definition.width / 2
        });

        // DeleteBodies operation to delete extrude1
        opDeleteBodies(context, id + "delete1", {
               "entities" : qCreatedBy(id + "extrude1", EntityType.BODY)
        });

        // Boolean operation to subtract the thicken1 from partToCut part
        opBoolean(context, id + "boolean1", {
               "tools" : qCreatedBy(id + "thicken1", EntityType.BODY),
               "targets" : definition.partToCut,
               "operationType" : BooleanOperationType.SUBTRACTION
        });

    });
&lt;/pre&gt;

&lt;p&gt;有了 slot 操作基礎後, 就可以進一步完成繪製齒輪與鏈輪輪廓的程式模版:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 355;
import(path : "onshape/std/geometry.fs", version : "355.0");

annotation { "Feature Type Name" : "Gear test" }
export const gearTest = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        // 圓半徑直接輸入表單為 radius 的欄位中
        annotation { "Name" : "radius" }
        isLength(definition.radius, LENGTH_BOUNDS);
        // 在 Select a point 輸入區為查詢, 只能選擇既有的 VERTEX, 且只選一個點
        annotation { "Name" : "Select a point", "Filter" : EntityType.VERTEX, "MaxNumberOfPicks" : 1 }
        definition.point is Query;
    }
    {
        // Precondition 中的查詢, 需要 evalue 才能傳回對應的 entity
        var location = evaluateQuery(context, definition.point)[0];
        // location 變數為點座標對應的 entity, 必須透過 evVetexPoint 的評量才能傳回對應的點座標
        var center3D = evVertexPoint(context, {
                "vertex" : location
        });

        // 作圖面利用 evOwnerSketch 評量, 與 location entity 同一個平面
        var sketchPlane = evOwnerSketchPlane(context, {
                "entity" : location
        });
        // 利用 worldToPlane, 將 center3D 轉換為 sketchPlane 上的平面點座標
        const center2D = worldToPlane(sketchPlane, center3D);
        // 接下來利用 sketchPlane 建立一個草圖畫布元件
        const gearSketch = newSketchOnPlane(context, id + "gearSketch", {
                "sketchPlane" : sketchPlane
        });

        // 有了草圖畫布元件, 就可以在其上進行各式平面繪圖, 這裡利用 center2D 點作為圓心, definition.radius 作為半徑畫圓
        skCircle(gearSketch, "circle1", {
                "center" : center2D,
                "radius" : definition.radius
        });

        // 接著從圓心, 沿 x 軸方向畫一條長度為半徑的直線
        skLineSegment(gearSketch, "line1", {
                "start" : center2D,
                "end" : center2D + vector(1, 0) * definition.radius
        });

        // 這裡使用固定點在畫布上繪製平滑曲線, 之後可以直接用來繪製各種齒輪或鏈輪輪廓
        skFitSpline(gearSketch, "spline1", {
                "points" : [
                    vector( 0,  0) * inch,
                    vector( 0, -1) * inch,
                    vector( 1,  1) * inch,
                    vector(-1,  0) * inch,
                    vector( 0,  0) * inch
                ]
        });

        // 利用 skSolve 解出畫布上的所有繪圖內容, 並顯示出來
        skSolve(gearSketch);
    });
&lt;/pre&gt;</summary><category term="Onshape"></category><category term="FeatureScript"></category></entry><entry><title>CADLab 新電腦系統</title><link href="http://cadlab.mde.tw/post/cadlab-xin-dian-nao-xi-tong.html" rel="alternate"></link><updated>2016-06-14T22:36:38+08:00</updated><author><name>Cad Lab</name></author><id>tag:cadlab.mde.tw,2016-06-14:post/cadlab-xin-dian-nao-xi-tong.html</id><summary type="html">&lt;p&gt;CPU 選擇: &lt;span style="background-color: #ffff00;"&gt;Intel i7-6700&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Ram  選擇: &lt;span style="background-color: #ffff00;"&gt;16GB (8GBx2) DDR4-3000 (至少還可再升級 8GBx2)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;HD: &lt;span style="background-color: #ffff00;"&gt;2TB (64MB) SATA III&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Video Card: &lt;span style="background-color: #ffff00;"&gt;NVIDIA GEFORCE GTX950 2GB GDDR5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;NIC: &lt;span style="background-color: #ffff00;"&gt;1Gbits/s*5 (除了主機板上的兩片網路卡之外 ,再加上 3 片外接式網路卡, 以便與各開機磁區中的虛擬機橋接出虛擬的多台連外伺服器)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;參考:&lt;/p&gt;
&lt;p&gt;i7: &lt;a href="https://en.wikipedia.org/wiki/List_of_Intel_Core_i7_microprocessors"&gt;https://en.wikipedia.org/wiki/List_of_Intel_Core_i7_microprocessors&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;i7-6700: &lt;a href="http://ark.intel.com/products/88196"&gt;http://ark.intel.com/products/88196&lt;/a&gt;&lt;/p&gt;</summary><category term="電腦輔助設計室"></category><category term="電腦硬體"></category></entry><entry><title>Onshape FeatureScript 程式語言 (一)</title><link href="http://cadlab.mde.tw/post/onshape-featurescript-cheng-shi-yu-yan-yi.html" rel="alternate"></link><updated>2016-06-14T22:36:38+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-06-14:post/onshape-featurescript-cheng-shi-yu-yan-yi.html</id><summary type="html">&lt;p&gt;接續上一篇文章, 整理目前 Onshape 已經釋出的 FeatureScript 相關應用範例.&lt;/p&gt;


&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/574941a2e4b05f50e871a75a/w/1c096ba7cb6b4bb6d74f8ffa/e/8c83ef9b92095a980e185cf8"&gt;Curve Pattern FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494139e4b04aa3f56f8243/w/cad51c78bef702f93d689668/e/0cfa9d7c4606e1f2ae32be16"&gt;Helix in Fill FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494120e4b04aa3f56f8206/w/d17e3ff3f757fabdb9084368/e/ab4048d5790d64d16e68e02d"&gt;3D Spline Fill FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494101e4b04aa3f56f81ed/w/b2ffdc215aff14ea3817b535/e/1626934c31793c1d4d18eb6f"&gt;Brick FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494096e4b05f50e871a70e/w/165ebc7b4103e5b6c91e3f5b/e/bfd58761a0e39c157f11bd42"&gt;Measure Distance FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/5749420ae4b04aa3f56f8288/w/ed9f79b9809ffe7610f9c537/e/aa01cfec5e04037e7ca611b7"&gt;Lighten FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Snap Hook FeatureScript 程式原始碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
/*    
    Snap Hook

    This custom feature creates a common fastening feature in plastic part design.

    The Snap Hook is just one version of this type of fastening feature 
    and could be easily extended to include many other types. This was built
    to show that you can create complex, compound features easily.

    Version 1 - April 26, 2016 - Neil Cooke, Onshape Inc.
*/ 

FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

annotation { "Feature Type Name" : "Snap Hook" }
export const SnapHook = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Sketch point locations", "Filter" : EntityType.VERTEX &amp;&amp; SketchObject.YES &amp;&amp; ConstructionObject.NO }
        definition.locations is Query;

        annotation { "Name" : "Height type" }
        definition.style is HookStyle;

        if (definition.style == HookStyle.BLIND)
        {
            annotation { "Name" : "Height", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.height, HOOK_HEIGHT);
        }
        else
        {
            annotation { "Name" : "Parallel face or plane", "Filter" : EntityType.FACE, "MaxNumberOfPicks" : 1 }
            definition.parallelFace is Query;
        }

        annotation { "Name" : "Width", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.hookWidth, HOOK_WIDTH);

        annotation { "Name" : "Flip direction", "UIHint" : "OPPOSITE_DIRECTION" }
        definition.hookFlipDirection is boolean;

        annotation { "Name" : "Edge to define direction", "Filter" : EntityType.EDGE, "MaxNumberOfPicks" : 1 }
        definition.hookDirection is Query;

        annotation { "Name" : "Thickness", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.hookThickness, HOOK_THK);

        annotation { "Name" : "Undercut depth", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.hookDepth, HOOK_THK);

        annotation { "Name" : "Lip height", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.flatHeight, HOOK_LIP);

        annotation { "Name" : "Insertion angle", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isAngle(definition.deflectionAngle, HOOK_ANGLE);

        annotation { "Name" : "Draft", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"], "Default" : true }
        definition.hasDraft is boolean;

        if (definition.hasDraft == true)
        {
            annotation { "Name" : "Draft angle", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
            isAngle(definition.draftAngle, ANGLE_STRICT_90_BOUNDS);

            annotation { "Name" : "Back face draft angle", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isAngle(definition.backDraftAngle, ANGLE_STRICT_90_BOUNDS);
        }
        annotation { "Name" : "Cutout", "Default" : true }
        definition.hasCutout is boolean;

        annotation { "Name" : "Merge scope", "Filter" : EntityType.BODY &amp;&amp; BodyType.SOLID }
        definition.booleanScope is Query;
    }

    {
        // get all the user selected locations
        const locations = evaluateQuery(context, definition.locations);

        // if a solid body intersects the first point in the list, automatically use that in the merge scope
        const targetBody = evaluateQuery(context, qContainsPoint(qBodyType(qEverything(EntityType.BODY), BodyType.SOLID), evVertexPoint(context, { "vertex" : locations[0] })));

        if (size(targetBody) == 0 &amp;&amp; definition.booleanScope != undefined)
            definition.targetBody = definition.booleanScope; // if not, get user to select merge scope
        else
            definition.targetBody = targetBody[0];

        var sketchPlane is Plane = evOwnerSketchPlane(context, { "entity" : locations[0] });
        var topPlane;

        var hookVector = vector(1, 0); // by default pointing across in x

        // if user has defined hook direction, work out the vector
        if (definition.hookDirection != undefined)
        {
            const directionResult = try(evAxis(context, { "axis" : definition.hookDirection }));

            if (directionResult != undefined)
                hookVector = normalize(vector(directionResult.direction[0], directionResult.direction[1]));
        }

        if (definition.hookFlipDirection)
            hookVector = hookVector * -1;

        // get vector perpendicular to hook direction
        var perpHookVector = vector(hookVector[1] * -1, hookVector[0]);

        // define the plane for the top of the boss
        if (definition.style == HookStyle.PLANE &amp;&amp; definition.parallelFace != undefined)
            topPlane = evPlane(context, { "face" : definition.parallelFace });
        else
            topPlane = plane(sketchPlane.origin + definition.height * sketchPlane.normal, sketchPlane.normal);

        var nameId = 1;
        var chamferPoints = [];
        var frontFacePoints = [];
        var backFacePoints = [];

        const sketch1 = newSketchOnPlane(context, id + "sketch1", { "sketchPlane" : topPlane });
        const sketch2 = newSketchOnPlane(context, id + "sketch2", { "sketchPlane" : topPlane });
        const sketch3 = newSketchOnPlane(context, id + "sketch3", { "sketchPlane" : topPlane });

        definition.depth = definition.hookDepth / tan(definition.deflectionAngle) + definition.flatHeight;

        // Build 3 sketches each with a rectangle
        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skRectangle(sketch1, "rectangleHook" ~ nameId, {
                        "firstCorner" : vector(point[0], point[1]) + (definition.hookWidth / 2) * hookVector,
                        "secondCorner" : vector(point[0], point[1]) - (definition.hookWidth / 2) * hookVector - definition.hookDepth * perpHookVector
                    });

            skRectangle(sketch2, "rectangleThickness" ~ nameId, {
                        "firstCorner" : vector(point[0], point[1]) - (definition.hookWidth / 2) * hookVector,
                        "secondCorner" : vector(point[0], point[1]) + (definition.hookWidth / 2) * hookVector + definition.hookThickness * perpHookVector
                    });

            skRectangle(sketch3, "completeRectangle" ~ nameId, {
                        "firstCorner" : vector(point[0], point[1]) - (definition.hookWidth / 2) * hookVector - definition.hookDepth * perpHookVector,
                        "secondCorner" : vector(point[0], point[1]) + (definition.hookWidth / 2) * hookVector + definition.hookThickness * perpHookVector
                    });

            // Keep a list of the centerpoints of the edges where the chamfers may go
            var chamferPoint2d = vector(point[0], point[1]) - definition.hookDepth * perpHookVector;
            if (definition.hasDraft)
            {
                chamferPoint2d = vector(point[0], point[1]) - (definition.hookDepth - definition.depth * tan(definition.draftAngle)) * perpHookVector;
            }
            chamferPoints = append(chamferPoints, toWorld(planeToCSys(topPlane), vector(chamferPoint2d[0], chamferPoint2d[1], definition.depth)));

            var backFacePoint2d = vector(point[0], point[1]) + definition.hookThickness * perpHookVector;
            backFacePoints = append(backFacePoints, toWorld(planeToCSys(topPlane), vector(backFacePoint2d[0], backFacePoint2d[1], 0 * meter)));
            frontFacePoints = append(frontFacePoints, toWorld(planeToCSys(topPlane), vector(point[0], point[1], 0 * meter)));

            nameId += 1;
        }
        skSolve(sketch1);
        skSolve(sketch2);
        skSolve(sketch3);

        extrude(context, id + ("extrude1"), {
                    "entities" : qSketchRegion(id + "sketch2"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "depth" : definition.depth,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.ADD,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        extrude(context, id + ("extrude2"), {
                    "entities" : qSketchRegion(id + "sketch3"),
                    "endBound" : BoundingType.BLIND,
                    "depth" : definition.depth,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : false,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : true,
                    "operationType" : NewBodyOperationType.ADD,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        var chamferEdges = [];

        for (var i = 0; i &lt; size(chamferPoints); i += 1)
        {
            // Find the edges that intersect the points previously collected
            chamferEdges = append(chamferEdges, qContainsPoint(qCreatedBy(id + "extrude2", EntityType.EDGE), chamferPoints[i]));
        }

        try(opChamfer(context, id + "chamfer1", {
                        "entities" : qUnion(chamferEdges),
                        "chamferType" : ChamferType.OFFSET_ANGLE,
                        "width" : definition.depth - definition.flatHeight,
                        "angle" : definition.deflectionAngle,
                        "oppositeDirection" : true
                    }));

        if (definition.hasDraft)
        {
            var backFaces = [];
            var frontFaces = [];

            for (var i = 0; i &lt; size(backFacePoints); i += 1)
            {
                // Find the edges that intersect the points previously collected
                backFaces = append(backFaces, qContainsPoint(qCreatedBy(id + "extrude1", EntityType.FACE), backFacePoints[i]));
                frontFaces = append(frontFaces, qContainsPoint(qCreatedBy(id + "extrude1", EntityType.FACE), frontFacePoints[i]));
            }

            opPlane(context, id + "plane1", {
                        "plane" : topPlane,
                        "size" : 0.1 * meter
                    });

            opDraft(context, id + "draft1", {
                        "neutralPlane" : qCreatedBy(id + "plane1", EntityType.FACE),
                        "pullVec" : topPlane.normal,
                        "draftFaces" : qUnion(frontFaces),
                        "angle" : 0 * degree
                    });

            opDraft(context, id + "draft2", {
                        "neutralPlane" : qCreatedBy(id + "plane1", EntityType.FACE),
                        "pullVec" : topPlane.normal,
                        "draftFaces" : qUnion(backFaces),
                        "angle" : definition.backDraftAngle + definition.draftAngle
                    });
        }

        if (definition.hasCutout)
        {
            extrude(context, id + ("extrude3"), {
                        "entities" : qSketchRegion(id + "sketch1"),
                        "endBound" : BoundingType.THROUGH_ALL,
                        "depth" : definition.depth,
                        "endBoundEntityBody" : definition.targetBody,
                        "oppositeDirection" : true,
                        "hasDraft" : definition.hasDraft,
                        "draftAngle" : definition.draftAngle,
                        "draftPullDirection" : false,
                        "operationType" : NewBodyOperationType.REMOVE,
                        "defaultScope" : false,
                        "booleanScope" : definition.targetBody
                    });
        }

        // Remove sketch entities and plane - no longer required
        var sketches = [qCreatedBy(id + "sketch1"), qCreatedBy(id + "sketch2"), qCreatedBy(id + "sketch3"), qCreatedBy(id + "plane1")];
        opDeleteBodies(context, id + "delete", { "entities" : qUnion(sketches) });

    }, {});

const HOOK_ANGLE =
{
            "min" : -TOLERANCE.zeroAngle * radian,
            "max" : (2 * PI + TOLERANCE.zeroAngle) * radian,
            (degree) : [15, 30, 60]
        } as AngleBoundSpec;

const HOOK_HEIGHT =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.015, 500],
            (centimeter) : 1.5,
            (millimeter) : 15.0,
            (inch) : 0.6
        } as LengthBoundSpec;

const HOOK_WIDTH =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.005, 500],
            (centimeter) : 0.5,
            (millimeter) : 5.0,
            (inch) : 0.2
        } as LengthBoundSpec;

const HOOK_THK =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.002, 500],
            (centimeter) : 0.2,
            (millimeter) : 2.0,
            (inch) : 0.08
        } as LengthBoundSpec;

const HOOK_LIP =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.001, 500],
            (centimeter) : 0.1,
            (millimeter) : 1.0,
            (inch) : 0.04
        } as LengthBoundSpec;

export enum HookStyle
{
    annotation { "Name" : "Blind" }
    BLIND,
    annotation { "Name" : "Up to face" }
    PLANE
}
&lt;/pre&gt;

&lt;p&gt;Fill Pattern FeatureScript 程式碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");
import(path : "onshape/std/transform.fs", version : "336.0");

/**
 * Performs a pattern of faces within a face. The instances are placed in a hexagonal pattern and no instances will be 
 * created that cross the boundary of the face. If a border is set then no instances are created within a border of that size
 * @param definition {{
 *      @field entities A collection of faces that will be patterned
 *      @field target A planar face that contains the 'entities' faces and that will contain the pattern
 *      @field direction Specifies the alignment of the pattern in the face
 *      @field distance The distance between the center of the instances
 *      @field border The width of the "exclusion zone" at the edge of the target face     
 * }}
 */
annotation { "Feature Type Name" : "Fill pattern", "Filter Selector" : "allparts" }
export const fillPattern = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Faces to pattern",
                     "Filter" : EntityType.FACE &amp;&amp; ConstructionObject.NO &amp;&amp; SketchObject.NO }
        definition.entities is Query;
        annotation { "Name" : "Target face", "Filter" : GeometryType.PLANE, "MaxNumberOfPicks" : 1 }
        definition.target is Query;
        annotation { "Name" : "Direction", "Filter" : QueryFilterCompound.ALLOWS_AXIS, "MaxNumberOfPicks" : 1 }
        definition.direction is Query;        
        annotation { "Name" : "Distance" }
        isLength(definition.distance, LENGTH_BOUNDS);
        annotation { "Name" : "Border" }
        isLength(definition.border, NONNEGATIVE_ZERO_DEFAULT_LENGTH_BOUNDS);
    }
    {
        var transforms = [];
        var instanceNames = [];

        var direction = try(evAxis(context, { "axis" : definition.direction })).direction;
        println(direction);
        var normal = try(evPlane(context, {
            "face" : definition.target
        })).normal;

        // For a hexagonal pattern we have two directions, with one being at an angle of 60 degrees from the other.
        // If we pattern in both those directions then we get a hexagonal pattern with equal spacing
        var vertical = cross(normal, direction);
        var angled = (direction * cos(60 * degree)) + (vertical * sin(60 * degree));

        // We want to get the edges of the target face so that we can get the distance from the face boundary
        // However, because the tool faces ought to be "in" the target face we don't want to count those
        // We can use booleans on the queries, which is pretty nice. We can also take the opportunity to ensure
        // that at least some edges are shared
        var allTargetEdges = qEdgeAdjacent(definition.target, EntityType.EDGE);
        var toolEdges = qEdgeAdjacent(definition.entities, EntityType.EDGE);
        var targetEdges = qSubtraction(allTargetEdges, toolEdges);
        var edgesInFace = qIntersection([allTargetEdges, toolEdges]);
        if (size(evaluateQuery(context, edgesInFace)) == 0) {
            throw regenError("The entities must share edges with the target face");
        }

        // To prevent excessive calculation we do a quick exclusion of faces based on bounding boxes
        // It doesn't need to be perfect. Get the box of the target face and of the shared edges
        var faceBox = try(evBox3d(context, {
            "topology" : definition.target
        }));
        var toolBox = try(evBox3d(context, {
            "topology" : edgesInFace
        }));

        // Again, to prevent excessive computation we will estimate the maximum number of instances and
        // fail early if we exceed some limit.
        var diagonal = faceBox.maxCorner - faceBox.minCorner;    
        var maximumIndex = round((norm(diagonal) - (definition.border * 2)) / definition.distance);
        var toolSize = norm(toolBox.maxCorner - toolBox.minCorner);
        var estimatedIndexCount = maximumIndex * maximumIndex;
        if (estimatedIndexCount &gt; 2500)
        {
            throw regenError("Too many instances in the pattern (estimate: " ~ 
                estimatedIndexCount ~ " ). Try a larger spacing.");
        }

        // Now we loop and look to see if the instance should be included
        for (var i = -maximumIndex; i &lt;= maximumIndex; i += 1)
        {
            for (var j = -maximumIndex; j &lt;= maximumIndex; j += 1)
            {
                if (abs(i) &lt; 0.5 &amp;&amp; abs(j) &lt; 0.5)
                {
                    // Zero transform = initial position =&gt; Skip
                    continue;
                }
                var translation = ((direction * i) + (angled * j)) * definition.distance;
                var instanceTransform = transform(translation);
                // Now that we have the transform we transform the tool box and see if it is within the face
                // but not too close to the edges of the face
                // Note: this isn't exact, it uses the center of the face and the size of the face box 
                // rather than transforming the geometry every time.
                var xformed = box3d(toolBox.minCorner + translation, toolBox.maxCorner + translation);
                if (clash(xformed, faceBox))
                {
                    var minDistance = evDistance(context, {
                            "side0" : targetEdges,
                            "side1" : (xformed.minCorner + xformed.maxCorner) * 0.5
                    });
                    // Note: if border is zero this still results in a border that is half the size of the tool,
                    // the border is additional on top of that
                    if (minDistance.distance &gt; (toolSize + definition.border))
                    {
                        transforms = append(transforms, instanceTransform);
                        instanceNames = append(instanceNames, "" ~ i ~ "." ~ j);
                    }
                }                
            }
        }

        // Now we set the data as needed by the applyPattern function before calling it.
        definition.patternType = PatternType.FACE;
        definition.transforms = transforms;
        definition.instanceNames = instanceNames;
        definition.seed = definition.entities;

        var remainingTransform = getRemainderPatternTransform(context, { "references" : definition.entities });
        applyPattern(context, id, definition, remainingTransform);
    }, { });

/**
 * Utility function to do a quick clash of boxes
 */
function clash(box1 is Box3d, box2 is Box3d) returns boolean
{
    for (var index = 0; index &lt; 3; index += 1)
    {
        var min1 = box1.minCorner[index];
        var max1 = box1.maxCorner[index];
        var min2 = box2.minCorner[index];
        var max2 = box2.maxCorner[index];
        // Comparisons to zero are never a good idea because values that are calculated separately are
        // rarely the same to machine precision. FeatureScript provides tolerant equality methods
        // but not tolerant inequalities. No matter, we can fashion one ourselves by checking the
        // inequality and excluding approximate equality
        if ((max1 &lt; min2 &amp;&amp; !tolerantEquals(max1, min2)) || (max2 &lt; min1 &amp;&amp; !tolerantEquals(max2, min1)))
        {
            return false;
        }
    }
    return true;
}
&lt;/pre&gt;

&lt;p&gt;Rib FeatureScript 程式碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

const RIB_THICKEN_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [0.0, 0.005, 500],
            (centimeter) : 0.5,
            (millimeter) : 5.0,
            (inch) : 0.25,
            (foot) : 0.025,
            (yard) : 0.01
        } as LengthBoundSpec;

/**
 * Specifies the direction of the rib extrusion starting from the profile
 * going up to the part.
 *
 * @value NORMAL_TO_SKETCH_PLANE : The direction of the rib extrusion goes normal to the profile sketch plane.
 * @value PARALLEL_TO_SKETCH_PLANE : The direction of the rib extrusion goes parallel to the profile sketch plane.
 */
export enum RibExtrusionDirection
{
    annotation { "Name" : "Normal to sketch plane" }
    NORMAL_TO_SKETCH_PLANE,
    annotation { "Name" : "Parallel to sketch plane" }
    PARALLEL_TO_SKETCH_PLANE
}

function isClosed(context is Context, edge is Query) returns boolean
{
    return size(evaluateQuery(context, qVertexAdjacent(edge, EntityType.VERTEX))) &lt; 2;
}

annotation { "Feature Type Name" : "Rib" }
export const rib = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Sketch profiles", "Filter" : EntityType.EDGE &amp;&amp; SketchObject.YES &amp;&amp; ConstructionObject.NO }
        definition.profiles is Query;

        annotation { "Name" : "Parts", "Filter" : EntityType.BODY }
        definition.parts is Query;

        annotation { "Name" : "Thickness" }
        isLength(definition.thickness, RIB_THICKEN_BOUNDS);

        annotation { "Name" : "Rib extrusion direction" }
        definition.ribExtrusionDirection is RibExtrusionDirection;

        annotation { "Name" : "Opposite direction", "UIHint" : "OPPOSITE_DIRECTION", "Default" : true }
        definition.oppositeDirection is boolean;

        annotation { "Name" : "Extend profiles up to part" }
        definition.extendProfilesUpToPart is boolean;

        annotation { "Name" : "Merge ribs", "Default" : true }
        definition.mergeRibs is boolean;
    }
    {
        const profiles = evaluateQuery(context, definition.profiles);
        const numberOfRibs = size(profiles);
        if (profiles == [])
        {
            throw regenError("Select sketch profiles for the rib contours");
        }

        if (evaluateQuery(context, definition.parts) == [])
        {
            throw regenError("Select parts where the rib will be fitted into");
        }

        // Create a transform for making the feature patternable via feature pattern.
        var remainingTransform = getRemainderPatternTransform(context,
                {"references" : qUnion([definition.profiles, definition.parts])});

        // Before evaluating the profiles to create the ribs, we find out how big the parts are
        // so if any extending is necessary for any rib end, we know how far we need to extend.
        // To ensure the extended profile will always go past the part(s), we use the
        // diagonal of the bounding box of the part(s) and profile(s) as the extend length.
        const partBoundingBox = evBox3d(context, {
                    "topology" : qUnion([definition.parts, definition.profiles])
                });
        const extendLength = norm(partBoundingBox.maxCorner - partBoundingBox.minCorner);

        // Create each rib (one rib per profile) as its own body.

        for (var i = 0; i &lt; numberOfRibs; i += 1)
        {
            const profile = profiles[i];
            const thickenId = id + (i ~ "thickenRib");

            try
            {
                // Keep track of the entities we will extrude as a surface which will later
                // be thickened to create the rib.  The profile and any
                // profile extensions will need to be included in the extrude operation.
                var entitiesToExtrude = [profile];

                // Get the endpoints of the profile and the normal direction at those endpoints
                // so we can determine what needs to be extended and what direction to extend.
                const profileEndTangentLines = evEdgeTangentLines(context, {
                            "edge" : profile,
                            "parameters" : [0, 1],
                            "arcLengthParameterization" : false
                        });

                // There  are 2 reasons we might need to extend the given profiles:
                // 1.  If the profile touches the part(s), make an extension of the profile past the part to ensure
                //     that there are no gaps when we thicken the profile (this can happen if the profile is not normal
                //     to the part where they intersect).
                // 2.  The extend profiles up to part checkbox has been selected.
                const partsContainPoint = function(point is Vector) returns boolean
                    {
                        return evaluateQuery(context, qContainsPoint(definition.parts, remainingTransform * point)) != [];
                    };

                var extendProfiles = makeArray(2);
                var extendedEndPoints = makeArray(2);
                const extendDirections = [-profileEndTangentLines[0].direction, profileEndTangentLines[1].direction];

                // If the profile is closed, then there is nothing to extend.
                const isProfileClosed = isClosed(context, profile);

                for (var end in [0, 1]) // Potentially extend both endpoints of the profile curve
                {
                    extendProfiles[end] = !isProfileClosed &amp;&amp; definition.extendProfilesUpToPart || partsContainPoint(profileEndTangentLines[end].origin);
                    if (extendProfiles[end])
                    {
                        extendedEndPoints[end] = profileEndTangentLines[end].origin + (extendDirections[end] * extendLength);
                        // This is actually a quick way to create a line in 3D
                        opFitSpline(context, id + (i ~ "extendProfile" ~ end), {
                                    "points" : [
                                            profileEndTangentLines[end].origin,
                                            extendedEndPoints[end]
                                        ]
                                });
                        entitiesToExtrude = append(entitiesToExtrude, qCreatedBy(id + (i ~ "extendProfile" ~ end), EntityType.EDGE));
                    }
                }

                // Find the direction to extrude a surface that will later be thickened to produce the rib.
                // First determine the normal or parallel direction, then, if specified,
                // choose the opposite of the normal or parallel direction.
                const profilePlane = evOwnerSketchPlane(context, { "entity" : profile });
                var ribDirection;
                if (definition.ribExtrusionDirection == RibExtrusionDirection.PARALLEL_TO_SKETCH_PLANE)
                {
                    // To get the parallel direction with the sketch plane, find the direction perpendicular
                    // to the sketch plane normal and the line that connects the start and end point of the profile.
                    const profileDirection = normalize(profileEndTangentLines[1].origin - profileEndTangentLines[0].origin);
                    ribDirection = cross(profilePlane.normal, profileDirection);
                }
                else
                {
                    ribDirection = profilePlane.normal;
                }

                if (definition.oppositeDirection)
                {
                    ribDirection = ribDirection * -1;
                }

                // Extrude a surface from the extended profile into the part(s), using the extend length
                // as the extrude depth to make sure the surface goes through the part(s).
                opExtrude(context, id + (i ~ "surfaceExtrude"), {
                            "entities" : qUnion(entitiesToExtrude),
                            "direction" : ribDirection,
                            "endDepth" : extendLength,
                            "endBound" : BoundingType.BLIND
                        });

                // Transform the extruded surface if needed to support feature pattern.
                transformResultIfNecessary(context, id + (i ~ "surfaceExtrude"), remainingTransform);

                // Thicken the surface to make the rib plus some excess material around the part(s).
                const halfThickness = definition.thickness / 2;
                opThicken(context, thickenId, {
                            "entities" : qCreatedBy(id + (i ~ "surfaceExtrude"), EntityType.FACE),
                            "thickness1" : halfThickness,
                            "thickness2" : halfThickness
                        });

                // Split the rib with the part(s) to separate the rib body from the thicken excess.
                var ribPartsQuery = qCreatedBy(thickenId, EntityType.BODY);
                opBoolean(context, id + (i ~ "splitOffRibExcess"), {
                            "tools" : definition.parts,
                            "targets" : ribPartsQuery,
                            "operationType" : BooleanOperationType.SUBTRACTION,
                            "keepTools" : true
                        });

                // Apply the remaining transform to the profile before doing collision testing.
                patternTransform(context, id + (i ~ "tr1"), profile, remainingTransform);
                // Do collision testing to help determine which parts of the thicken are excess.
                var clashes = evCollision(context, {
                        "tools" : ribPartsQuery,
                        "targets" : profile
                    });

                // Since we don't want the profile to actually move
                // move it back to it's original location after checking for collisions.
                patternTransform(context, id + (i ~ "tr2"), profile, inverse(remainingTransform));
                var clashBodies = mapArray(clashes, function(clash)
                {
                    return clash.toolBody;
                });

                // Specify a point at the end of the surface extrude.
                // Any thicken body that intersects with this point is excess.
                const surfaceExtrudeEndPoint = profileEndTangentLines[0].origin + (extendLength * ribDirection);

                // Collect up all the thicken excess and any other entities we've created leading
                // up to the thicken operation, because all of these need to be deleted.
                var entitiesToDelete = [
                    // Remove rib thicken excess sections that don't intersect the original profile.
                    qSubtraction(ribPartsQuery, qUnion(clashBodies)),

                    // Remove rib thicken excess sections that extend all the way to the end of
                    // the surface extrude (which we deliberately had extend well past the part,
                    // i.e. well past where a rib should be created).
                    qContainsPoint(ribPartsQuery, remainingTransform * surfaceExtrudeEndPoint),

                    // Remove the surface extrude, now that the thicken is completed and we don't need it anymore.
                    qCreatedBy(id + (i ~ "surfaceExtrude"), EntityType.BODY)
                ];

                // Delete any profile extensions created now that we don't need them anymore.
                // Also, any thicken section that intersects with the far end of an extension
                // (i.e. not the end that intersects with the profile) is thicken excess and should be deleted.
                for (var end in [0, 1])
                {
                    if (extendProfiles[end])
                    {
                        entitiesToDelete = append(entitiesToDelete, qCreatedBy(id + (i ~ "extendProfile" ~ end), EntityType.BODY));
                        entitiesToDelete = append(entitiesToDelete, qContainsPoint(ribPartsQuery, extendedEndPoints[end]));
                    }
                }

                opDeleteBodies(context, id + (i ~ "deleteRibExcess"), {
                            "entities" : qUnion(entitiesToDelete)
                        });
            }
            catch
            {
                throw regenError('Failed to create a rib from a selected profile.',
                        profile);
            }

            // Fail early if the rib body can't be created.
            if (evaluateQuery(context, qCreatedBy(thickenId, EntityType.BODY)) == [])
            {
                throw regenError('Selected profile did not produce a rib body.  Make sure the rib direction and alignment are correct.',
                        profile);
            }
        }

        // Optionally, merge the new ribs with the original parts.
        if (definition.mergeRibs)
        {
            // The original parts are first in the tools query so that they
            // will maintain their names.
            var toMerge = [definition.parts];
            for (var i = 0; i &lt; numberOfRibs; i += 1)
            {
                toMerge = append(toMerge, qCreatedBy(id, EntityType.BODY));
            }

            try
            {
                opBoolean(context, id + "mergeRibsWithParts", {
                            "tools" : qUnion(toMerge),
                            "operationType" : BooleanOperationType.UNION
                        });
            }
            catch
            {
                throw regenError('Failed to merge ribs into parts.');
            }
        }
    },
        {
            oppositeDirection : true,
            ribExtrusionDirection : RibExtrusionDirection.NORMAL_TO_SKETCH_PLANE,
            extendProfilesUpToPart : false,
            mergeRibs : true
        });

function patternTransform(context, id, query, transform)
{
    if (transform == identityTransform())
        return;
    opTransform(context, id, {
            "bodies" : qOwnerBody(query),
            "transform" : transform
    });
}
&lt;/pre&gt;</summary><category term="CADLab"></category><category term="MCAD"></category><category term="Onshape"></category><category term="FeatureScript"></category></entry><entry><title>Onshape FeatureScript 程式語言</title><link href="http://cadlab.mde.tw/post/onshape-featurescript-cheng-shi-yu-yan.html" rel="alternate"></link><updated>2016-06-14T22:36:38+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-06-14:post/onshape-featurescript-cheng-shi-yu-yan.html</id><summary type="html">&lt;p&gt;在 &lt;a href="https://embedwistia-a.akamaihd.net/deliveries/02d2dfd77d4c465c42fa30e66e3bb53f26467cbc/file.mp4"&gt;FeatureScript 簡介&lt;/a&gt;的影片中, 可以看到 Onshape 打造了一個客製化特徵功能的程式語言與社群分享機制, 任何人利用 FeatureScript 建立的延伸功能, 都能夠透過 Add custom features 指令與其他使用者分享.&lt;/p&gt;


&lt;p&gt;FeatureScript 是 Onshape 發明, 一種可用來定義客製化參數特徵用的程式語言, 具有下列特點:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;各 Document 中用戶所建立的 FeatureScript 程式碼, 位於 Feature Studio (特徵工房) 分頁中.&lt;/li&gt;
&lt;li&gt;FeatureScript 的整合開發環境 (Integrated Development Environment) 內建於 Onshape 中.&lt;/li&gt;
&lt;li&gt;Onshape 原本系統中使用的特徵功能, 其對應的 FeatureScript 程式碼, 已經採&lt;a href="https://cad.onshape.com/documents/5749364ce4b0f60f1b7940fe/w/925a5467b6e725168eb9c993/e/ff3b765aacc32576f893ed23"&gt;開放源&lt;/a&gt; (Open Source) 模式釋出.&lt;/li&gt;
&lt;li&gt;Onshape 同時提供 &lt;a href="https://cad.onshape.com/FsDoc/"&gt;FeatureScript 參考手冊&lt;/a&gt; 與 &lt;a href="https://forum.onshape.com/categories/featurescript"&gt;FeatureScript 論壇&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;登入 Onshape, 建立一個 Document 之後, 就可以透過左下角的 + 號中的 Create Feature Studio, 進入 FeatureScript 的整合開發環境, 開始編寫客製化的特徵程式碼, IDE 則提供下列相關功能:&lt;/p&gt;
&lt;p&gt;Parameter (參數)&lt;/p&gt;
&lt;p&gt;Length, Angle, Count, Query, Enum, Boolean and String&lt;/p&gt;
&lt;p&gt;Query (查詢)&lt;/p&gt;
&lt;p&gt;Everything, Nth element, Entity filter, Created by, Intersection, Subtraction, Symetric difference, Own by body, Own by body filter, Owner body, Entities adjacent to edge, Geometry type filter, Contains point, Intersects plane and Query evaluation&lt;/p&gt;
&lt;p&gt;Evaluation (評量)&lt;/p&gt;
&lt;p&gt;Tangent plane, Tangent line, Vertex point, Length measurement, Area measurement, Volume measurement, Query evaluation&lt;/p&gt;
&lt;p&gt;Sketch, Line segment, Circle, Arc, Ellipse, Rectangle, Line segment chain&lt;/p&gt;
&lt;p&gt;Cuboid, Cylinder, Extrude, Revolute, Fillet, Boolean, Transform, Import&lt;/p&gt;
&lt;p&gt;Import (導入)&lt;/p&gt;
&lt;p&gt;Format feature studio (整理特徵工房編輯格式)&lt;/p&gt;
&lt;p&gt;Commit (提交)&lt;/p&gt;
&lt;p&gt;FeatureScript 程式基本架構如下:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 355;
import(path : "onshape/std/geometry.fs", version : "355.0");
annotation { "Feature Type Name" : "My Feature" }
export const myFeature = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        // Define the parameters of the feature type
    }
    {
        // Define the function's action
    });
&lt;/pre&gt;

&lt;p&gt;上層宣告, 列舉值與指令敘述都可以加上 annotations (註解). FeatureScript 的註解使用格式類似 Python 的 Dictionary, 但是 annotation 的索引值型別必須為字串, 而且索引值為 "Feature Type Name" 的 annotation 為每一個特徵指令的必要註解.&lt;/p&gt;
&lt;p&gt;export 則可視為上述的程式碼中, 使用者所宣告的 myFeature 對應特徵物件會被優先置入 FeatureScript Template 中.&lt;/p&gt;
&lt;p&gt;此外 Onshape 任一頁面送出時, 都帶有以下標頭設置, 除了利用 X-Frame-Options:SAMEORIGIN, 不允許使用者將頁面納入 iframe 或 object 標註中外, 也避免遭受可能的網路攻擊:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
Cache-Control:must-revalidate,no-cache,no-store
Strict-Transport-Security:max-age=31536000; includeSubDomains
X-Content-Type-Options:nosniff
X-Frame-Options:SAMEORIGIN
X-XSS-Protection:1; mode=block
&lt;/pre&gt;

&lt;p&gt;以下則為目前 Onshape 官方釋出的參考應用範例:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494220e4b04aa3f56f82c2/w/888534aeb52c4daa68bbfd05/e/4a55fd2861eaa83fae0221d9"&gt;Point Pattern FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494152e4b05f50e871a72c/w/a4a3f09939bf1f43a8e4f133/e/2b865798923d6f648f7196f9"&gt;Spur Gear FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494187e4b0f60f1b7941c8/w/b98b4de33c1d47713be20e7f/e/c1f8d65fc6196f728620b857"&gt;Wave Spring FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Port feature 程式碼 (建立 SAE J1926 螺孔):&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

export enum PortSize
{
    annotation { "Name" : "5/16-24" }
    fiveSixteen,
    annotation { "Name" : "3/8-24" }
    threeEights,
    annotation { "Name" : "7/16-20" }
    sevenSixteen,
    annotation { "Name" : "1/2-20" }
    half,
    annotation { "Name" : "9/16-18" }
    nineSixteen,
    annotation { "Name" : "3/4-16" }
    threeFour,
    annotation { "Name" : "7/8-14" }
    sevenEights,
    annotation { "Name" : "1 1/16-12" }
    oneSixteen
}

annotation { "Feature Type Name" : "Port Feature" }
export const portFeature = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Port Size" }
        definition.portSize is PortSize;

        annotation { "Name" : "Points", "Filter" : EntityType.VERTEX }
        definition.points is Query;

        annotation { "Name" : "Depth" }
        isLength(definition.depth, DEPTH_BOUNDS);
    }
    {
        var ports;
        var depth = definition.depth;
        //here the vector points for each port are added to an array depending on size chosen
        if (definition.portSize == PortSize.fiveSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .019 * inch, -.031 * inch),
                    vector(-.631, -.031) * inch,
                    vector(-.53, -.132) * inch,
                    vector(-.167, -.132) * inch,
                    vector(-.136, -.163) * inch,
                    vector(-.062, -.179) * inch,
                    vector(-.062, -.336) * inch,
                    vector(0, -.336) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.threeEights)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .038 * inch, -.063 * inch),
                    vector(-.629, -.063) * inch,
                    vector(-.53, -.162) * inch,
                    vector(-.169, -.162) * inch,
                    vector(-.136, -.195) * inch,
                    vector(-.062, -.211) * inch,
                    vector(-.062, -.375) * inch,
                    vector(0, -.375) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.sevenSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .052 * inch, -.086 * inch),
                    vector(-.663, -.086) * inch,
                    vector(-.547, -.202) * inch,
                    vector(-.176, -.202) * inch,
                    vector(-.155, -.224) * inch,
                    vector(-.062, -.243) * inch,
                    vector(-.062, -.414) * inch,
                    vector(0, -.414) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.half)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .07 * inch, -.117 * inch),
                    vector(-.71, -.117) * inch,
                    vector(-.607, -.22) * inch,
                    vector(-.188, -.22) * inch,
                    vector(-.153, -.255) * inch,
                    vector(-.062, -.275) * inch,
                    vector(-.062, -.453) * inch,
                    vector(0, -.453) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.nineSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .089 * inch, -.149 * inch),
                    vector(-.773, -.149) * inch,
                    vector(-.671, -.251) * inch,
                    vector(-.195, -.251) * inch,
                    vector(-.159, -.287) * inch,
                    vector(-.062, -.308) * inch,
                    vector(-.062, -.485) * inch,
                    vector(0, -.485) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.threeFour)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .117 * inch, -.196 * inch),
                    vector(-.928, -.196) * inch,
                    vector(-.782, -.341) * inch,
                    vector(-.237, -.341) * inch,
                    vector(-.194, -.384) * inch,
                    vector(-.094, -.406) * inch,
                    vector(-.094, -.594) * inch,
                    vector(0, -.594) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.sevenEights)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .145 * inch, -.242 * inch),
                    vector(-1.032, -.242) * inch,
                    vector(-.875, -.399) * inch,
                    vector(-.245, -.399) * inch,
                    vector(-.194, -.45) * inch,
                    vector(-.094, -.471) * inch,
                    vector(-.094, -.672) * inch,
                    vector(0, -.672) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.oneSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .183 * inch, -.304 * inch),
                    vector(-1.22, -.304) * inch,
                    vector(-1, -.525) * inch,
                    vector(-.246, -.525) * inch,
                    vector(-.224, -.546) * inch,
                    vector(-.094, -.574) * inch,
                    vector(-.094, -.813) * inch,
                    vector(0, -.813) * inch,
                    vector(0, 0) * inch];
        }
        const checkLength = (ports[3] - ports[2]); 
        if (checkLength[0] &lt; 0) // check the depth entered and throw error if depth causes feature to invert
        {
            throw regenError(ErrorStringEnum.SKETCH_DIMENSION_FAILED, ["depth"]);
        }
        var points = evaluateQuery(context, definition.points);
        var numberOfPoints = size(points);
        var sketchId = id + "sketch";
        var portId = "port1";
        for (var i = 0; i &lt; numberOfPoints; i += 1) //for each point selected create a sketch using port vertices and revolve cut
        {
            sketchId = sketchId + i;
            var point = points[i];
            var sketchPlane = evOwnerSketchPlane(context, { "entity" : point });
            var cSys = planeToCSys(sketchPlane);
            var pointVertex = evVertexPoint(context, { "vertex" : point });
            var sketchPlane2 = plane(pointVertex, cSys.xAxis, cSys.zAxis);
            var sketch = newSketchOnPlane(context, sketchId, { "sketchPlane" : sketchPlane2 });
            skPolyline(sketch, portId, { "points" : ports, "constrained" : false });
            skSolve(sketch);
            var axisQuery = sketchEntityQuery(sketchId, EntityType.EDGE, portId ~ ".line0");
            revolveCut(context, id, sketch, sketchId, axisQuery);
        }
        opDeleteBodies(context, id + "delete_sketch", { "entities" : qCreatedBy(id + "sketch", EntityType.BODY) });
        // delete the sketch
    }, { /* default parameters */ });

function revolveCut(context is Context, id is Id, sketch is Sketch, sketchId is Id, axisQuery is Query)
{
    var sketchQuery = qSketchRegion(sketchId, false);
    //revolve cut
    revolve(context, sketchId + "revolve", {
                "operationType" : NewBodyOperationType.REMOVE,
                "entities" : qUnion([sketchQuery]),
                "axis" : qUnion([axisQuery]),
                "revolveType" : RevolveType.FULL,
                "defaultScope" : true });
}

const DEPTH_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.0381, 500],
            (centimeter) : 3.81,
            (millimeter) : 38.1,
            (inch) : 1.5 // set the default depth to 1.5 inch
        } as LengthBoundSpec;
&lt;/pre&gt;

&lt;p&gt;Screw Boss FeatureScript 原始碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
/*    
    Screw Boss

    This custom feature creates a common fastening feature in plastic part design.

    The Screw Boss is just one version of this type of fastening feature 
    and could be easily extended to include many other types. This was built
    to show that you can create complex, compound features easily.

    Version 1 - April 26, 2016 - Neil Cooke, Onshape Inc.
*/ 

FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

annotation { "Feature Type Name" : "Screw Boss" }
export const ScrewBoss = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Sketch points to place bosses", "Filter" : EntityType.VERTEX &amp;&amp; SketchObject.YES &amp;&amp; ConstructionObject.NO }
        definition.locations is Query;

        annotation { "Name" : "Boss style" }
        definition.style is BossStyle;

        if (definition.style == BossStyle.BLIND)
        {
            annotation { "Name" : "Boss height", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.height, BOSS_HEIGHT);
        }
        else
        {
            annotation { "Name" : "Parallel face or plane", "Filter" : EntityType.FACE, "MaxNumberOfPicks" : 1 }
            definition.parallelFace is Query;
        }

        annotation { "Name" : "Boss diameter", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.diameter, BOSS_DIA);

        annotation { "Name" : "Ribs", "Default" : true, "UIHint" : "DISPLAY_SHORT" }
        definition.hasRibs is boolean;

        if (definition.hasRibs == true)
        {
            annotation { "Name" : "Number of ribs (max 6)", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
            isInteger(definition.ribCount, RIB_COUNT_BOUNDS);

            annotation { "Name" : "Flip rib direction", "UIHint" : "OPPOSITE_DIRECTION" }
            definition.ribFlipDirection is boolean;

            annotation { "Name" : "Edge to define rib direction", "Filter" : EntityType.EDGE, "MaxNumberOfPicks" : 1 }
            definition.ribDirection is Query;

            annotation { "Name" : "Rib diameter at top", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.ribDiameter, RIB_DIA);

            annotation { "Name" : "Rib distance from top", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.ribHeight, RIB_HEIGHT);

            annotation { "Name" : "Rib thickness", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.ribThickness, RIB_THK);

            annotation { "Name" : "Chamfer", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"], "Default" : true }
            definition.hasChamfer is boolean;

            if (definition.hasChamfer == true)
            {
                annotation { "Name" : "Chamfer size", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
                isLength(definition.chamferSize, CHAMFER_SIZE);
            }
        }

        annotation { "Name" : "Hole diameter", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.holeDiam, HOLE_DIA);

        annotation { "Name" : "Wall thickness", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.wallThickness, WALL_THK);

        annotation { "Name" : "Draft", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"], "Default" : true }
        definition.hasDraft is boolean;

        if (definition.hasDraft == true)
        {
            annotation { "Name" : "Draft angle", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
            isAngle(definition.draftAngle, DRAFT_ANGLE);
        }

        annotation { "Name" : "Merge scope", "Filter" : EntityType.BODY &amp;&amp; BodyType.SOLID }
        definition.booleanScope is Query;
    }

    {
        // get all the user selected locations
        const locations = evaluateQuery(context, definition.locations);

        // if a solid body intersects the first point in the list, automatically use that in the merge scope
        const targetBody = evaluateQuery(context, qContainsPoint(qBodyType(qEverything(EntityType.BODY), BodyType.SOLID), evVertexPoint(context, { "vertex" : locations[0] })));

        if (size(targetBody) == 0 &amp;&amp; definition.booleanScope != undefined)
            definition.targetBody = definition.booleanScope; // if not, get user to select merge scope
        else
            definition.targetBody = targetBody[0];

        var sketchPlane is Plane = evOwnerSketchPlane(context, { "entity" : locations[0] });
        var topPlane;
        var ribPlane;

        // define the plane for the top of the boss
        if (definition.style == BossStyle.PLANE &amp;&amp; definition.parallelFace != undefined)
            topPlane = evPlane(context, { "face" : definition.parallelFace });
        else
            topPlane = plane(sketchPlane.origin + definition.height * sketchPlane.normal, sketchPlane.normal);

        var nameId = 1;

        definition.sketch = newSketchOnPlane(context, id + "sketch1", { "sketchPlane" : topPlane });

        // Build first feature - extruded circle
        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skCircle(definition.sketch, "circle" ~ nameId, {
                        "center" : vector(point[0], point[1]),
                        "radius" : definition.diameter / 2
                    });
            nameId += 1;
        }
        skSolve(definition.sketch);

        extrude(context, id + ("extrude1"), {
                    "entities" : qSketchRegion(id + "sketch1"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.ADD,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        // Build second feature - extruded ribs
        if (definition.hasRibs)
        {
            // define top of ribs
            ribPlane = plane(topPlane.origin - definition.ribHeight * topPlane.normal, topPlane.normal);

            var ribVector = vector(0, 1); // by default pointing up in Y

            // if user has defined rib direction, work out the vector
            if (definition.ribDirection != undefined)
            {
                const directionResult = try(evAxis(context, { "axis" : definition.ribDirection }));

                if (directionResult != undefined)
                    ribVector = normalize(vector(directionResult.direction[0], directionResult.direction[1]));
            }

            if (definition.ribFlipDirection)
                ribVector = ribVector * -1;

            definition.sketch = newSketchOnPlane(context, id + "sketch2", { "sketchPlane" : ribPlane });

            const ribPlaneCSys = planeToCSys(ribPlane);
            var chamferPoints = [];

            nameId = 1;

            for (var location in locations)
            {
                var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

                const center = vector(point[0], point[1]);

                // Build a closed "star" shaped sketch to represent the ribs
                for (var j = 0; j &lt; definition.ribCount; j += 1)
                {
                    var angle = (360 / definition.ribCount) * j * degree;

                    // The angle for each rib
                    var angledRibVector = vector(ribVector[0] * cos(angle) - ribVector[1] * sin(angle),
                        ribVector[0] * sin(angle) + ribVector[1] * cos(angle));

                    var perpRibVector = vector(angledRibVector[1] * -1, angledRibVector[0]);

                    var ribOffset = definition.ribThickness / 2 / tan(180 / definition.ribCount * degree);

                    if (definition.ribCount == 1)
                        ribOffset = 0 * meter;

                    var points = [
                        center - (definition.ribThickness / 2) * perpRibVector + (ribOffset) * angledRibVector,
                        center - (definition.ribThickness / 2) * perpRibVector + (definition.ribDiameter / 2) * angledRibVector,
                        center + (definition.ribThickness / 2) * perpRibVector + (definition.ribDiameter / 2) * angledRibVector,
                        center + (definition.ribThickness / 2) * perpRibVector + (ribOffset) * angledRibVector];

                    for (var i = 0; i &lt; size(points); i += 1)
                    {
                        skLineSegment(definition.sketch, "line" ~ nameId,
                                { "start" : points[i],
                                    "end" : points[(i + 1) % size(points)]
                                });
                        nameId += 1;
                    }

                    // Keep a list of the centerpoints of the edges where the chamfers may go
                    var chamferPoint2d = center + (definition.ribDiameter / 2) * angledRibVector;
                    chamferPoints = append(chamferPoints, toWorld(ribPlaneCSys, vector(chamferPoint2d[0], chamferPoint2d[1], 0 * meter)));
                }
                nameId += 1;
            }
            skSolve(definition.sketch);

            extrude(context, id + ("extrude2"), {
                        "entities" : qSketchRegion(id + "sketch2"),
                        "endBound" : BoundingType.UP_TO_BODY,
                        "endBoundEntityBody" : definition.targetBody,
                        "oppositeDirection" : true,
                        "hasDraft" : definition.hasDraft,
                        "draftAngle" : definition.draftAngle,
                        "draftPullDirection" : false,
                        "operationType" : NewBodyOperationType.ADD,
                        "defaultScope" : false,
                        "booleanScope" : definition.targetBody
                    });

            // Build third feature - chamfers
            if (definition.hasChamfer)
            {
                var chamferEdges = [];

                for (var i = 0; i &lt; size(chamferPoints); i += 1)
                {
                    // Find the edges that intersect the points previously collected
                    chamferEdges = append(chamferEdges, qContainsPoint(qCreatedBy(id + "extrude2", EntityType.EDGE), chamferPoints[i]));
                }

                try(opChamfer(context, id + "chamfer1", {
                                "entities" : qUnion(chamferEdges),
                                "chamferType" : ChamferType.EQUAL_OFFSETS,
                                "width" : definition.chamferSize
                            }));
            }
        }

        nameId = 1;

        // Build fourth feature - through hole to outside of part
        var holePlane = plane(topPlane.origin - definition.wallThickness * topPlane.normal, topPlane.normal);

        definition.sketch = newSketchOnPlane(context, id + "sketch3", { "sketchPlane" : holePlane });

        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skCircle(definition.sketch, "circle" ~ nameId, {
                        "center" : vector(point[0], point[1]),
                        "radius" : definition.diameter / 2 - definition.wallThickness
                    });
            nameId += 1;
        }
        skSolve(definition.sketch);

        extrude(context, id + ("extrude3"), {
                    "entities" : qSketchRegion(id + "sketch3"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.REMOVE,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        nameId = 1;

        // Build fifth feature - screw hole
        definition.sketch = newSketchOnPlane(context, id + "sketch4", { "sketchPlane" : topPlane });

        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skCircle(definition.sketch, "circle" ~ nameId, {
                        "center" : vector(point[0], point[1]),
                        "radius" : definition.holeDiam / 2
                    });
            nameId += 1;
        }
        skSolve(definition.sketch);

        extrude(context, id + ("extrude4"), {
                    "entities" : qSketchRegion(id + "sketch4"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.REMOVE,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        // Remove sketch entities - no longer required
        var sketches = [qCreatedBy(id + "sketch1"), qCreatedBy(id + "sketch2"), qCreatedBy(id + "sketch3"), qCreatedBy(id + "sketch4")];
        opDeleteBodies(context, id + "delete", { "entities" : qUnion(sketches) });

    }, {});

const BOSS_HEIGHT =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.02, 500],
            (centimeter) : 2.0,
            (millimeter) : 20.0,
            (inch) : 0.8
        } as LengthBoundSpec;

const BOSS_DIA =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.008, 500],
            (centimeter) : 0.8,
            (millimeter) : 8.0,
            (inch) : 0.3125
        } as LengthBoundSpec;

const RIB_COUNT_BOUNDS =
{
            "min" : 1,
            "max" : 6,
            (unitless) : [1, 4, 6]
        } as IntegerBoundSpec;

const RIB_DIA =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.015, 500],
            (centimeter) : 1.5,
            (millimeter) : 15.0,
            (inch) : 0.6
        } as LengthBoundSpec;

const RIB_HEIGHT =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [0, 0.005, 500],
            (centimeter) : 0.5,
            (millimeter) : 5.0,
            (inch) : 0.2
        } as LengthBoundSpec;

const RIB_THK =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.001, 500],
            (centimeter) : 0.1,
            (millimeter) : 1.0,
            (inch) : 0.04
        } as LengthBoundSpec;

const CHAMFER_SIZE =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.002, 500],
            (centimeter) : 0.2,
            (millimeter) : 2.0,
            (inch) : 0.08
        } as LengthBoundSpec;

const HOLE_DIA =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.003, 500],
            (centimeter) : 0.3,
            (millimeter) : 3.0,
            (inch) : 0.12
        } as LengthBoundSpec;

const WALL_THK =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.0015, 500],
            (centimeter) : 0.15,
            (millimeter) : 1.5,
            (inch) : 0.06
        } as LengthBoundSpec;

const DRAFT_ANGLE =
{
            "min" : -TOLERANCE.zeroAngle * radian,
            "max" : (2 * PI + TOLERANCE.zeroAngle) * radian,
            (degree) : [0, 2, 360],
            (radian) : 0.035
        } as AngleBoundSpec;

export enum BossStyle
{
    annotation { "Name" : "Blind" }
    BLIND,
    annotation { "Name" : "Up to face" }
    PLANE
}
&lt;/pre&gt;</summary><category term="CADLab"></category><category term="MCAD"></category><category term="Onshape"></category><category term="FeatureScript"></category></entry><entry><title>雲端平台上的電腦輔助機械設計</title><link href="http://cadlab.mde.tw/post/yun-duan-ping-tai-shang-de-dian-nao-fu-zhu-ji-jie-she-ji.html" rel="alternate"></link><updated>2016-05-28T07:05:43+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-28:post/yun-duan-ping-tai-shang-de-dian-nao-fu-zhu-ji-jie-she-ji.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.onshape.com/"&gt;Onshape&lt;/a&gt; 在 &lt;a href="http://wordpress-2015course.rhcloud.com/?p=4514"&gt;2015年12月&lt;/a&gt;正式全面對外公開之後, 已經啟動電腦輔助機械設計的雲端世代, 為了追求高效能的全球協同產品設計流程, 利用跨硬體裝置, 免安裝, 具備設計特徵版次管理, 而且提供類似 &lt;a href="https://cad.onshape.com/FsDoc/"&gt;Featurescript&lt;/a&gt; 客製化功能建構環境 (i.e. Feature Studio) 的全雲端電腦輔助機械設計工具, 將會日漸完備.&lt;/p&gt;


&lt;p&gt;面對 Onshape 的破壞性創新產品挑戰, SolidWorks 也以採用 &lt;a href="http://www.3ds.com/about-3ds/3dexperience-platform/"&gt;3dexperience platform&lt;/a&gt; 核心技術為主體, 推出全新的全雲端產品: &lt;a href="http://xdesign.solidworks.com/"&gt;Xdesign&lt;/a&gt; 回應.&lt;/p&gt;
&lt;p&gt;目前, SolidWorks 單機版約佔全球市場&lt;a href="http://blog.cnccookbook.com/2015/01/20/results-2015-cad-survey/"&gt;超過五分之一&lt;/a&gt;, 未來將與自家的 Xdesign 與 Onshape 免安裝全雲端產品, 競逐全球電腦輔助機械設計軟體市場. &lt;/p&gt;
&lt;p&gt;因此, 2016 年可以說是電腦輔助機械設計的雲端元年, 正好比 2006 年推出的 &lt;a href="https://en.wikipedia.org/wiki/Google_Docs,_Sheets,_and_Slides"&gt;Google Doc&lt;/a&gt;, 晚了十年.&lt;/p&gt;</summary><category term="CADLab"></category><category term="MCAD"></category></entry><entry><title>電腦輔助設計室的電腦開機磁區設置</title><link href="http://cadlab.mde.tw/post/dian-nao-fu-zhu-she-ji-shi-de-dian-nao-kai-ji-ci-qu-she-zhi.html" rel="alternate"></link><updated>2016-05-27T21:00:27+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-27:post/dian-nao-fu-zhu-she-ji-shi-de-dian-nao-kai-ji-ci-qu-she-zhi.html</id><summary type="html">&lt;p&gt;第1磁區: Windows 10 Pro + &lt;a href="https://msdn.microsoft.com/zh-tw/virtualization/hyperv_on_windows/quick_start/walkthrough_install"&gt;Hyper-V&lt;/a&gt; 安裝 Windows 7 Professional&lt;/p&gt;
&lt;p&gt;第2磁區: Windows 10 Pro + 可攜免安裝程式套件&lt;/p&gt;
&lt;p&gt;第3磁區: &lt;a href="http://releases.ubuntu.com/16.04/"&gt;Ubuntu 16.04&lt;/a&gt; Server + ubuntu-desktop&lt;/p&gt;


&lt;p&gt;第1磁區擬舀採 Windows 10 Pro 開機, 並安裝常用的 CAD/CAE/CAM 相關軟體套件的安裝為主, 針對無法在 Windows 10 Pro 執行的套件, 則建議安裝在 Hyper-V 模式下的 Windows 7 Professional 開機磁區中.&lt;/p&gt;
&lt;p&gt;第1磁區的網路設置以純 IPV4 為主, 並將最後一排的 9 台電腦, 以 IPV4/IPV6 雙支援的固定 IP 啟動 Ubuntu + &lt;a href="http://www.squid-cache.org/"&gt;Squid&lt;/a&gt; (選擇第3磁區開機), 讓上課師生自行選擇開機後透過 &lt;a href="https://en.wikipedia.org/wiki/Round-robin_DNS"&gt;Round Robin DNS&lt;/a&gt; 配置域名的代理主機增速上網.&lt;/p&gt;
&lt;p&gt;第2磁區擬採 Windows 10 Pro 開機, 並全數使用無需安裝的程式套件, 以提升套件使用效能, 網路配置則彈性配置純 IPV4 或純 IPV6 位址上網, 當採用純 IPV6 上網時, 必須啟動電腦輔助設計室中的 9 台 IPV4/IPV6 雙支援代理主機 (以 Ubuntu 磁區開機).&lt;/p&gt;</summary><category term="CADLab"></category><category term="Windows 10"></category></entry><entry><title>大學教育政策白皮書讀後心得報告</title><link href="http://cadlab.mde.tw/post/da-xue-jiao-yu-zheng-ce-bai-pi-shu-du-hou-xin-de-bao-gao.html" rel="alternate"></link><updated>2016-05-21T23:52:49+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-21:post/da-xue-jiao-yu-zheng-ce-bai-pi-shu-du-hou-xin-de-bao-gao.html</id><summary type="html">&lt;p&gt;15 年前寫的&lt;a href="http://cad-lab.github.io/cadlab_data/files/90.07_taiwan_univ_white_paperpdf"&gt;大學教育政策白皮書&lt;/a&gt;讀後心得報告&lt;/p&gt;


&lt;p&gt;科技大學的本質在教導學生獲得知識的能力，二十一世紀知識經濟最大的特色，在於必須將知識迅速化為商品，由於市場全球化的影響，未能即時將本身所擁有的知識，快速轉化為商品，並被市場接受的企業，終將難逃被時代淘汰的命運，企業如此，教育界也正面臨同樣的挑戰。&lt;/p&gt;
&lt;p&gt;教育部將大學的競爭力，視為國家競爭力的重要指標，全國各大學面對社會多元化的需求與全民終身學習的發展趨勢，如何在「大學教育政策白皮書」的基本方針下，強化各校的競爭力，建立各校的重點特色，便成為各大學今後所賴以生存的重要關鍵。&lt;/p&gt;
&lt;p&gt;事實上，「大學教育政策白皮書」中所提到的觀點，或許是台灣一般大學與科技大學所共同面臨的問題，但，就基本體制上，仍然要有所區分，方能貫徹彼此的教育目標，為社會的現在與未來，提供充足的人力資源。吾人以為，一般大學的最高目標在追求學術的卓越，而科技大學則必須掌握技術的領先，學術強調的是其具備未來的主導性，卓越的學術指的是高瞻遠矚，是未來有用的技術；而技術的領先是要培養能馬上為企業所用的科技尖兵，是能馬上將知識轉化為商品的創新發明家。也許，隨著科技進化的速度日益增快，學術與技術的區隔，也就變得越來越小，但一般大學與科技大學應有的角色與定位，仍不失為各大學爭取重點特色時，所應強調的重點。&lt;/p&gt;
&lt;p&gt;最後，談到本校在通過改名為科技大學後，如何在「大學教育政策白皮書」的指導方針下，爭取市場定位，並積極發展出屬於自己的特色，吾人以為，必須要先從小處做起，慢慢往大處做；必須要先由內做起，然後再漸漸往外落實。小處在哪裡，必須先用科學化與合理化來管理學校的每一個角落，然後才能談替企業診斷，為財團解憂。必須要先在校內建立起知識經濟的體系，然後才有可能與社會上全民學習的脈動相結合。未來，全球化經濟發展的趨勢或許很難臆測，但本校單類多科的包袱，如何逐步轉化為本校的重點特色，將是一項嚴酷的考驗，成敗的關鍵，就看現在。&lt;/p&gt;</summary><category term="大學教育"></category></entry><entry><title>Onshape 即將釋出 Featurescript 程式語言</title><link href="http://cadlab.mde.tw/post/onshape-ji-jiang-shi-chu-featurescript-cheng-shi-yu-yan.html" rel="alternate"></link><updated>2016-05-18T22:07:03+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-18:post/onshape-ji-jiang-shi-chu-featurescript-cheng-shi-yu-yan.html</id><summary type="html">&lt;p&gt;今天早上參加 Onshape 在台灣所舉行的首次實體論壇，除了持續感受到 Onshape 團隊滿滿的誠意外，最大的收穫就是得知 Featurescript 特徵程式語言，即將開放各界使用。&lt;/p&gt;


&lt;p&gt;所謂的 Featurescript， 根據了解，是一種可以透過 Feature Studio， 讓使用者修改或延伸 Onshape 特徵指令的新程式語言，據悉，目前 Onshape 所指供的特徵指令功能，也是透過 Featurescript 打造。&lt;/p&gt;
&lt;p&gt;並且，未來使用者所打造的各式客製化 Featurescript 程式，可以在 Onshape App store 中免費公開或販售。&lt;/p&gt;</summary><category term="Onshape"></category><category term="Featurescript"></category></entry></feed>