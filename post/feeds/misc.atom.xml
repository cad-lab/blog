<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>CADLab (虎尾科大MDE)</title><link href="http://cadlab.mde.tw/post/" rel="alternate"></link><link href="http://cadlab.mde.tw/post/feeds/misc.atom.xml" rel="self"></link><id>http://cadlab.mde.tw/post/</id><updated>2016-06-15T14:30:18+08:00</updated><entry><title>Onshape Featurescript Spur Gear 零件</title><link href="http://cadlab.mde.tw/post/onshape-featurescript-spur-gear-ling-jian.html" rel="alternate"></link><updated>2016-06-15T14:30:18+08:00</updated><author><name>Cad Lab</name></author><id>tag:cadlab.mde.tw,2016-06-15:post/onshape-featurescript-spur-gear-ling-jian.html</id><summary type="html">&lt;p&gt;從 &lt;a href="https://forum.onshape.com/discussion/4064/use-opfillet-for-a-sketch"&gt;https://forum.onshape.com/discussion/4064/use-opfillet-for-a-sketch&lt;/a&gt; 的討論, 我們得知, 目前無法利用 FeatureScript 在繪圖平面中利用 opFillet, 對特定平面圖元進行倒角運算, 因此延續&lt;a href="http://cadlab.mde.tw/post/onshape-featurescript-spur-gear-lun-kuo-hui-tu.html"&gt;上一篇利用漸開線正齒輪輪廓&lt;/a&gt;轉換為正齒輪零件, 就必須在實體模型中進行倒角運算.&lt;/p&gt;


&lt;p&gt;這裡的 FeatureScript 程式碼, 基本架構引用 &lt;a href="https://cad.onshape.com/documents/57494152e4b05f50e871a72c/w/a4a3f09939bf1f43a8e4f133/e/2b865798923d6f648f7196f9"&gt;Onshape 官方正齒輪繪圖 FeatureScript 程式第1版&lt;/a&gt; 的內容, 只將推導的漸開線點座標, 透過 skFitSpline 轉為平滑曲線, 但是原版的 offset 參數, 目前只導入 offsetAngle, 以便產生的正齒輪, 可以在組立件中進行囓合.&lt;/p&gt;
&lt;p&gt;17 齒漸開線正齒輪 FeatureScript 程式繪圖:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/summer_featurescript_spur_17t.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;170 齒漸開線正齒輪 FeatureScript 程式繪圖:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/summer_featurescript_spur_170t.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;2016 Spring 的協同產品設計實習課程, 就要在這個 Onshape FeatureScript 正齒輪零件程式的練習中劃下句點, 下學期的電腦輔助設計實習課程仍將採用 Onshape 與 FreeCAD, 當然 PTC Creo Parametric 年久失修的 Pro/Web.Link 仍可列入參考, 只是 Onshape 加上 FeatureScript 的魅力, 至今沒有其他 MCAD 套件可以比擬, 假如您是隸屬於特定團隊的電腦輔助機械設計工程師, 一定要試試 Onshape, 並且利用 FeatureScript 程式客製化產品開發流程中特定的重要零件. 一旦領略雲端電腦輔助機械設計套件的威力之後, 應該就再也回不去了.&lt;/p&gt;
&lt;p&gt;我們當然也知道台灣有許多創新產品開發公司, 至今仍然使用著多年前的 MACD 套件, 忍受著系統更新維護與版本老舊的諸多問題, 假如以購買一套桌上版的商用中端 MCAD 套件, 等於可以連續付月費使用 Onshape 5 年來說, 在日新月異的當下, 5 年前的任何一套 MCAD, 即便功能再強, 也早就應該要更迭換新了, 何況, 檢查一下過去 5 年來工程師為了應付機電整合與製程規劃, 儲存在特定電腦硬碟中的紛亂版本, 將設計研發重心逐步轉換到 Onshape 應該才是解決之道.&lt;/p&gt;
&lt;p&gt;以下為上述漸開線正齒輪零件繪圖的 FeatureScript 原始碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 355;
import(path : "onshape/std/geometry.fs", version : "355.0");

annotation { "Feature Type Name" : "Summer Spur Gear", "Feature Name Template" : "Spur Gear (#teeth teeth)", "Filter Selector" : "fs", "Editing Logic Function" : "editGearLogic" }
export const SpurGear = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "teeth", "UIHint" : "ALWAYS_HIDDEN" }
        definition.teeth is string; //used to name the feature only

        annotation { "Name" : "Number of teeth" }
        isInteger(definition.numTeeth, TEETH_BOUNDS);

        annotation { "Name" : "Input type" }
        definition.GearInputType is GearInputType;

        if (definition.GearInputType == GearInputType.module)
        {
            annotation { "Name" : "Module" }
            isLength(definition.module, MODULE_BOUNDS);
        }

        if (definition.GearInputType == GearInputType.diametralPitch)
        {
            annotation { "Name" : "Diametral pitch" }
            isReal(definition.diametralPitch, POSITIVE_REAL_BOUNDS);
        }

        if (definition.GearInputType == GearInputType.circularPitch)
        {
            annotation { "Name" : "Circular pitch" }
            isLength(definition.circularPitch, LENGTH_BOUNDS);
        }

        annotation { "Name" : "Pitch circle diameter" }
        isLength(definition.pitchCircleDiameter, LENGTH_BOUNDS);

        annotation { "Name" : "Pressure angle" }
        isAngle(definition.pressureAngle, PRESSURE_ANGLE_BOUNDS);

        annotation { "Name" : "Center hole" }
        definition.centerHole is boolean;

        if (definition.centerHole)
        {
            annotation { "Name" : "Hole diameter" }
            isLength(definition.centerHoleDia, CENTERHOLE_BOUNDS);

            annotation { "Name" : "Keyway" }
            definition.key is boolean;

            if (definition.key)
            {
                annotation { "Name" : "Key width" }
                isLength(definition.keyWidth, KEY_BOUNDS);

                annotation { "Name" : "Key height" }
                isLength(definition.keyHeight, KEY_BOUNDS);
            }
        }

        annotation { "Name" : "Select origin position" }
        definition.centerPoint is boolean;

        if (definition.centerPoint)
        {
            annotation { "Name" : "Sketch vertex for center", "Filter" : EntityType.VERTEX &amp;amp;&amp;amp; SketchObject.YES, "MaxNumberOfPicks" : 1 }
            definition.center is Query;
        }

        annotation { "Name" : "Extrude depth" }
        isLength(definition.gearDepth, BLEND_BOUNDS);

        annotation { "Name" : "Extrude direction", "UIHint" : "OPPOSITE_DIRECTION" }
        definition.flipGear is boolean;

        annotation { "Name" : "Offset" }
        definition.offset is boolean;

        if (definition.offset)
        {
            annotation { "Name" : "Root diameter" }
            isLength(definition.offsetClearance, ZERO_DEFAULT_LENGTH_BOUNDS);

            annotation { "Name" : "Outside diameter" }
            isLength(definition.offsetDiameter, ZERO_DEFAULT_LENGTH_BOUNDS);

            annotation { "Name" : "Tooth angle" }
            isAngle(definition.offsetAngle, ANGLE_360_ZERO_DEFAULT_BOUNDS);
        }
    }
    {
        var offsetDiameter = 0 * meter;
        var offsetClearance = 0 * meter;
        var offsetAngle = 0 * degree;

        if (definition.offset)
        {
            offsetDiameter = definition.offsetDiameter;
            offsetClearance = definition.offsetClearance;
            offsetAngle = definition.offsetAngle;
        }

        if (definition.centerHole &amp;amp;&amp;amp; definition.centerHoleDia &amp;gt;= definition.pitchCircleDiameter - 4 * definition.module)
        {
            throw regenError("Center hole diameter must be less than the root diameter", ["centerHoleDia"]);
        }

        if (definition.key &amp;amp;&amp;amp; definition.keyHeight / 2 + definition.centerHoleDia &amp;gt;= definition.pitchCircleDiameter - 4 * definition.module)
        {
            throw regenError("Center hole diameter plus Key height must be less than the root diameter", ["keyHeight"]);
        }
        // if no center vertex selected build gear on the front plane at the origin
        var location = vector(0, 0, 0) * meter;
        var sketchPlane = plane(location, vector(0, -1, 0), vector(1, 0, 0));
        var center3D = location;

        // else find location of selected vertex and its sketch plane and create a new sketch for the gear profile
        if (definition.centerPoint)
        {
            location = evaluateQuery(context, definition.center)[0];
            sketchPlane = evOwnerSketchPlane(context, { "entity" : location });
            center3D = evVertexPoint(context, { "vertex" : location });
        }

        const gearSketch = newSketchOnPlane(context, id + "gearSketch", { "sketchPlane" : sketchPlane });
        const center2D = worldToPlane(sketchPlane, center3D);

        var filletEdges = [];
        var regionPoint;
        // 漸開線近似點數
        var imax = 5;
        // 使用者所選的齒輪圓心 x 座標
        var midx = center2D[0];
        // 使用者所選的齒輪圓心 y 座標
        var midy = center2D[1];
        // 齒數
        var n = definition.numTeeth;
        // 模數
        var m = definition.module;
        // 壓力角, 單位為角度
        var pa = definition.pressureAngle;
        // 齒輪的節圓半徑
        var rp = m*n/2;

        // 正齒輪囓合用的定位線
        skLineSegment(gearSketch, "line", {
        "start" : vector(midx,midy),
        "end" : vector(midx,midy+rp)
        });

        // 齒根, 暫時不考慮納入 offsetClearance
        var d = 2.5*rp/n;
        // 齒頂圓半徑, 暫不考慮納入 offsetDiameter
        var ra = rp + m;
        // 基圓半徑
        var rb = rp*cos(pa);
        //print(rb);
        // 齒根圓半徑
        var rd = rp - d;
        // 分段後齒頂與齒根半徑差增量
        var dr = 0*meter;
        // 若 rb &amp;gt; rd 時從基圓開始繪製漸開線, 但是若 rd &amp;gt; rb, 則漸開線從 rd 畫到齒頂圓
        if (rd &amp;gt; rb)
        {
            // 半徑差的分段, 由齒根圓到齒頂圓
            dr = (ra-rd)/imax;
        }
        else
        {
            // 半徑差的分段, 由基圓到齒頂圓
            dr = (ra-rb)/imax;
        }
        // PI 為實數值沒有單位, tan(pa)也沒有單位, pa 已經設定單位為 degree
        var rot = PI/(2*n)*radian;
        // 用來設定 entity id 用的增量變數
        var nameId = 1;
        var r = 0*meter;
        // theta 為浮點數字
        var theta = 0;
        var inv = 0*radian;
        var inc = 0*radian;
        // 當 r=rp 時 ,計算 inv_rp 用來旋轉漸開線用
        // theta 為沒有單位的實數
        theta = sqrt((rp*rp)/(rb*rb)-1);
        // atan(theta) 為 radian
        // Onshape SG 的 const alpha 就是這裡的 inv_rp
        // Onshape SG 的 const beta 就是這裡的 rot-inv_rp
        var inv_rp = theta*radian-atan(theta);
        // 漸開線上點的 x 座標
        var xpt = 0*meter;
        // 漸開線上點的 y 座標
        var ypt = 0*meter;
        // 左側漸開線第1點座標 left first x and y
        var lfx = 0*meter;
        var lfy = 0*meter;
        // 右側漸開線第1點座標 right first x and y
        var rfx = 0*meter;
        var rfy = 0*meter;
        // 左側齒根圓上點座標 left x of dedendum point
        var lxd = 0*meter;
        var lyd = 0*meter;
        // 右側齒根圓上點座標 right x of dedendum point
        var rxd = 0*meter;
        var ryd = 0*meter;
        // 左側齒根圓上點座標 right x of dedendum point (advanced)
        var lxd_ad = 0*meter;
        var lyd_ad = 0*meter;
        var inc_ad = 0*radian;

        for (var j=0;j&amp;lt;n;j+=1)
        {
            var involute1 = [];
            var involute2 = [];
            var arcDone = false;
            var point1;
            var point2;

            // 當 j 增量時, 按照齒數輪廓繞行旋轉增量角度, 加入 offsetAngle 參數
            inc = (2.*j*PI/n)*radian+offsetAngle;
            inc_ad = (2.*(j+1)*PI/n)*radian+offsetAngle;
            if (rd&amp;gt;rb)
            {
                // 當齒根半徑因為齒數增多後大於基圓半徑時, 漸開線從齒根圓長起
                theta = sqrt((rd*rd)/(rb*rb)-1.);
                inv = theta*radian-atan(theta);
                // 左側漸開線第1點座標
                // 左側輪廓線配合逆時針旋轉 inc 角度
                lfx = midx+rd*sin(inv-rot-inv_rp+inc);
                lfy = midy+rd*cos(inv-rot-inv_rp+inc);
                point1 = vector(lfx, lfy);
                lxd = lfx;
                lyd = lfy;
                lxd_ad = midx+rd*sin(inv-rot-inv_rp+inc_ad);
                lyd_ad = midy+rd*cos(inv-rot-inv_rp+inc_ad);
                // 右側漸開線第1點座標
                // 右側輪廓線配合順時針旋轉 inc 角度
                rfx = midx-rd*sin(inv-rot-inv_rp-inc);
                rfy = midy+rd*cos(inv-rot-inv_rp-inc);
                point2 = vector(rfx, rfy);
                rxd = rfx;
                ryd = rfy;
            }
            else
            {
                // 當基圓半徑大於齒根圓時, 漸開線從基圓長起
                //theta = sqrt((rb*rb)/(rb*rb)-1.);
                theta = 0;
                inv = theta*radian-atan(theta);
                // 左側漸開線第1點座標
                lfx = midx+rb*sin(inv-rot-inv_rp+inc);
                lfy = midy+rb*cos(inv-rot-inv_rp+inc);
                point1 = vector(lfx, lfy);
                lxd = midx+rd*sin(inv-rot-inv_rp+inc);
                lyd = midy+rd*cos(inv-rot-inv_rp+inc);
                lxd_ad = midx+rd*sin(inv-rot-inv_rp+inc_ad);
                lyd_ad = midy+rd*cos(inv-rot-inv_rp+inc_ad);
                // 左側從基圓點到齒根圓點, 畫直線 left from base point to dedendum point
                skLineSegment(gearSketch, "line_lbd" ~ nameId, {
                "start" : vector(lfx,lfy),
                "end" : vector((lxd),(lyd))
                });
                // 右側漸開線第1點座標
                rfx = midx-rb*sin(inv-rot-inv_rp-inc);
                rfy = midy+rb*cos(inv-rot-inv_rp-inc);
                point2 = vector(rfx, rfy);
                rxd = midx-rd*sin(inv-rot-inv_rp-inc);
                ryd = midy+rd*cos(inv-rot-inv_rp-inc);
                // 右側從基圓點到齒根圓點, 畫直線 right from base point to dedendum point
                skLineSegment(gearSketch, "line_rbd" ~ nameId, {
                "start" : vector(rfx,rfy),
                "end" : vector((rxd),(ryd))
                });
            }
            // 處理齒根的圓弧
            if (!arcDone) // create base arc between involutes once per tooth
            {
                var mid = getArcMidPoint(center2D, vector(lxd_ad,lyd_ad), vector(rxd,ryd)); // sketch arc is arc 3 points so need addtional point on arc

                if (mid != undefined) // if no base cylinder present (due to pressure angle), don't draw it
                {
                    // 齒根圓上的圓弧
                    skArc(gearSketch, "arc-d" ~ nameId, {
                                "start" : vector(lxd_ad,lyd_ad),
                                "mid" : mid,
                                "end" : vector(rxd,ryd)
                            });
                }
                if (rd&amp;gt;rb)
                {   
                    // 只有在齒根圓半徑大於基圓時, 將漸開線起點作為倒圓角的基準點
                    // find points in 3D space where edges need to be filleted later
                    filletEdges = append(filletEdges, toWorldVector(planeToCSys(sketchPlane), point2, definition.gearDepth, definition.flipGear));
                    filletEdges = append(filletEdges, toWorldVector(planeToCSys(sketchPlane), point1, definition.gearDepth, definition.flipGear));
                }
                else
                {
                    // 當小齒數時, 從基圓到齒根圓有一條直線, 因此倒角基準點必須以齒根圓上的點為基準
                    // find points in 3D space where edges need to be filleted later
                    filletEdges = append(filletEdges, toWorldVector(planeToCSys(sketchPlane), vector(rxd, ryd), definition.gearDepth, definition.flipGear));
                    filletEdges = append(filletEdges, toWorldVector(planeToCSys(sketchPlane), vector(lxd, lyd), definition.gearDepth, definition.flipGear));
                }
                // find area to extrude
                regionPoint = vector(point1[0] * 0.95 + center2D[0]*0.05, point1[1] * 0.95+center2D[1]*0.05, 0 * meter);
                arcDone = true;
            }
            // 將漸開線第1點存入 involute1 與 involute2 陣列中
            involute1 = append(involute1, point1);
            involute2 = append(involute2, point2);

            for (var i=1; i&amp;lt;imax+1; i+= 1)
            {
                // 先處理中線左側的漸開線
                // 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if (rd&amp;gt;rb)
                {
                    r = rd+i*dr;
                }
                else
                {
                    r = rb+i*dr;
                }
                theta = sqrt((r*r)/(rb*rb)-1);
                var inv = theta*radian-atan(theta);
                // 漸開線上的點座標
                xpt = midx+r*sin(inv-rot-inv_rp+inc);
                ypt = midy+r*cos(inv-rot-inv_rp+inc);
                point1 = vector(xpt, ypt);
                // 更新漸開線點座標
                lfx = xpt;
                lfy = ypt;
                //nameId += 1;
                involute1 = append(involute1, point1);
            }
            // 紀錄左側漸開線的最後一點, 也就是齒頂圓上的點座標
            var lastlx = xpt;
            var lastly = ypt;
            // another side
            for (var i=1; i&amp;lt;imax+1; i+= 1)
            {
                if (rd&amp;gt;rb)
                {
                    r = rd+i*dr;
                }
                else
                {
                    r = rb+i*dr;
                }
                theta = sqrt((r*r)/(rb*rb)-1);
                var inv = theta*radian-atan(theta);
                // 漸開線上的點座標
                xpt = midx-r*sin(inv-rot-inv_rp-inc);
                ypt = midy+r*cos(inv-rot-inv_rp-inc);
                point2 = vector(xpt, ypt);
                // 更新漸開線點座標
                rfx = xpt;
                rfy = ypt;
                //nameId += 1;
                involute2 = append(involute2, point2);
            }
            var lastrx = xpt;
            var lastry = ypt;

            // create involute sketch splines
            skFitSpline(gearSketch, "spline-a" ~ nameId, {
                        "points" : involute1
                    });
            skFitSpline(gearSketch, "spline-b" ~ nameId, {
                        "points" : involute2
                    });
            // 要注意, 若對調 vector(lastrx, lastry) 與 vector(lastlx, lastly) 則無法求得中點
            var mid_a = getArcMidPoint(center2D, vector(lastrx,lastry), vector(lastlx,lastly));
            if (mid_a != undefined)
            {
                skArc(gearSketch, "arc-a" ~ nameId, {
                            "start" : vector(lastlx,lastly),
                            "mid" : mid_a,
                            "end" : vector(lastrx,lastry)
                        }); 
            }
            nameId += 1;
        }
        if (definition.centerHole)
        {
            if (definition.key)
            {
                var keyVector = vector(0, 1);
                var perpKeyVector = vector(-1, 0);
                var keyHeight = (definition.keyHeight + definition.centerHoleDia) / 2;

                var points = [
                    center2D - (definition.keyWidth / 2) * perpKeyVector,
                    center2D - (definition.keyWidth / 2) * perpKeyVector + keyHeight * keyVector,
                    center2D + (definition.keyWidth / 2) * perpKeyVector + keyHeight * keyVector,
                    center2D + (definition.keyWidth / 2) * perpKeyVector];

                for (var i = 0; i &amp;lt; size(points); i += 1)
                {
                    skLineSegment(gearSketch, "line" ~ nameId,
                            { "start" : points[i],
                                "end" : points[(i + 1) % size(points)]
                            });
                    nameId += 1;
                }
            }

            // center hole circle sketch
            skCircle(gearSketch, "Center", {
                        "center" : center2D,
                        "radius" : definition.centerHoleDia / 2
                    });
        }
    skSolve(gearSketch);

    extrude(context, id + "extrude1", {
                "entities" : qContainsPoint(qCreatedBy(id + "gearSketch", EntityType.FACE), toWorld(planeToCSys(sketchPlane), regionPoint)),
                "endBound" : BoundingType.BLIND,
                "depth" : definition.gearDepth,
                "oppositeDirection" : definition.flipGear
            });


    var filletEdges3D = [];

    for (var i = 0; i &amp;lt; size(filletEdges); i += 1)
    {
        // Find the edges that intersect the points previously collected
        filletEdges3D = append(filletEdges3D, qContainsPoint(qCreatedBy(id + "extrude1", EntityType.EDGE), filletEdges[i]));
    }

    const filletRadius = norm(filletEdges[1] - filletEdges[0]) / 4; // arbitrary fillet size = one fourth the distance between the edges

    if (filletRadius &amp;gt;= 0.2 * millimeter) // arbitrary small size assuming tooling cannot hold a fillet radius smaller than this
    {

        try(opFillet(context, id + "fillet1", {
                        "entities" : qUnion(filletEdges3D),
                        "radius" : filletRadius
                    }));

    }

    // Remove sketch entities - no longer required
    opDeleteBodies(context, id + "delete", { "entities" : qCreatedBy(id + "gearSketch") });

    // created PCD sketch
    const PCDSketch = newSketchOnPlane(context, id + "PCDsketch", { "sketchPlane" : sketchPlane });
    skCircle(PCDSketch, "PCD", {
                "center" : center2D,
                "radius" : definition.pitchCircleDiameter / 2,
                "construction" : true
            });
    skSolve(PCDSketch);
    });

function getArcMidPoint(center is Vector, start is Vector, end is Vector)
{
    // need to convert 2D vectors back to 3D for vector angle calculation
    const center3D = vector(center[0], center[1], 0 * meter);
    const start3D = vector(start[0], start[1], 0 * meter);
    const end3D = vector(end[0], end[1], 0 * meter);

    const angle = vectorAngle(center3D - start3D, center3D - end3D) / 2;
    // if angle is less than zero then arc was flipped
    if (angle &amp;lt;= 0 * radian)
        return;
    start = center - start;

    var ca = cos(angle); // in radians
    var sa = sin(angle);
    return center - vector(ca * start[0] - sa * start[1], sa * start[0] + ca * start[1]);
}

function vectorAngle(vector1 is Vector, vector2 is Vector)
{
    // function assumes vectors are on a 2D plane so Z is always zero and the normal vector is always [0, 0, 1]
    return atan2(dot(vector(0, 0, 1), cross(vector1, vector2)), dot(vector1, vector2));
}

function toWorldVector(csys is CoordSystem, point is Vector, depth is map, direction is boolean) returns Vector
{
    var dir = direction ? -1 : 1;
    var vector3D = vector(point[0], point[1], dir * depth / 2);
    return toWorld(csys, vector3D);
}

export function editGearLogic(context is Context, id is Id, oldDefinition is map, definition is map, isCreating is boolean, specifiedParameters is map, hiddenBodies is Query) returns map
{
    // isCreating is required in the function definition for edit logic to work when editing an existing feature
    if (oldDefinition.numTeeth != definition.numTeeth)
    {
        definition.module = definition.pitchCircleDiameter / definition.numTeeth;
        definition.circularPitch = definition.module * PI;
        definition.diametralPitch = 1 * inch / definition.module;
        definition.teeth = toString(definition.numTeeth); //to name the feature
        return definition;
    }

    if (oldDefinition.circularPitch != definition.circularPitch)
    {
        definition.module = definition.circularPitch / PI;
        definition.pitchCircleDiameter = (definition.circularPitch * definition.numTeeth) / PI;
        definition.diametralPitch = 1 * inch / definition.module;
        return definition;
    }

    if (oldDefinition.pitchCircleDiameter != definition.pitchCircleDiameter)
    {
        definition.module = definition.pitchCircleDiameter / definition.numTeeth;
        definition.circularPitch = (PI * definition.pitchCircleDiameter) / definition.numTeeth;
        definition.diametralPitch = 1 * inch / definition.module;
        return definition;
    }

    if (oldDefinition.module != definition.module)
    {
        definition.circularPitch = definition.module * PI;
        definition.pitchCircleDiameter = definition.numTeeth * definition.module;
        definition.diametralPitch = 1 * inch / definition.module;
        return definition;
    }

    if (oldDefinition.diametralPitch != definition.diametralPitch)
    {
        definition.circularPitch = PI / (definition.diametralPitch / inch);
        definition.module = definition.circularPitch / PI;
        definition.pitchCircleDiameter = (definition.circularPitch * definition.numTeeth) / PI;
        return definition;
    }

    return definition;
}

const TEETH_BOUNDS =
{
            "min" : 4,
            "max" : 250,
            (unitless) : [4, 25, 250]
        } as IntegerBoundSpec;

const PRESSURE_ANGLE_BOUNDS =
{
            "min" : 12 * degree,
            "max" : 35 * degree,
            (degree) : [12, 20, 35]
        } as AngleBoundSpec;

const MODULE_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.001, 500],
            (centimeter) : 0.1,
            (millimeter) : 1.0,
            (inch) : 0.04
        } as LengthBoundSpec;

const CENTERHOLE_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.01, 500],
            (centimeter) : 1.0,
            (millimeter) : 10.0,
            (inch) : 0.375
        } as LengthBoundSpec;

const KEY_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.003, 500],
            (centimeter) : 0.3,
            (millimeter) : 3.0,
            (inch) : 0.125
        } as LengthBoundSpec;

export enum GearInputType
{
    annotation { "Name" : "Module" }
    module,
    annotation { "Name" : "Diametral pitch" }
    diametralPitch,
    annotation { "Name" : "Circular pitch" }
    circularPitch
}
&lt;/pre&gt;</summary><category term="Onshape"></category><category term="FeatureScript"></category></entry><entry><title>Onshape Featurescript Spur Gear 輪廓繪圖</title><link href="http://cadlab.mde.tw/post/onshape-featurescript-spur-gear-lun-kuo-hui-tu.html" rel="alternate"></link><updated>2016-06-15T01:38:02+08:00</updated><author><name>Cad Lab</name></author><id>tag:cadlab.mde.tw,2016-06-15:post/onshape-featurescript-spur-gear-lun-kuo-hui-tu.html</id><summary type="html">&lt;p&gt;學習 Onshape 可以從 614 頁的 pdf 格式導引手冊: &lt;a href="https://cad.onshape.com/help/PDF/Onshape.pdf"&gt;https://cad.onshape.com/help/PDF/Onshape.pdf&lt;/a&gt; 下手, 在手動操作逐漸熟悉之後, 就可以透過下列的 FeatureScript 程式客製化理想中的各種零件, 這裡先來看看漸開線正齒輪輪廓繪圖, 有關齒輪的參考資料, 請參閱 &lt;a href="http://khkgears.net/gear-knowledge/"&gt;http://khkgears.net/gear-knowledge/&lt;/a&gt;.&lt;/p&gt;


&lt;p&gt;從 &lt;a href="http://chiamingyen.github.io/kmolab/blog/ji-jie-she-ji-gong-cheng-shi-de-she-ji-mo-ni-yu-shi-zuo.html"&gt;機械設計工程師的設計模擬與實作&lt;/a&gt; 文章中, 可以看到利用 Brython 直接在網際畫布上以小段直線繪製漸開線正齒輪輪廓的程式原始碼. 類似的正齒輪繪圖可以參考 &lt;a href="http://web.mit.edu/harishm/www/papers/involuteEWC.pdf"&gt;Approximation of Involute Curves for CAD-System Processing&lt;/a&gt; 論文中的說明, 完成 &lt;a href="http://www.arc.id.au/GearDrawing.html"&gt;靜態與動態的漸開線正齒輪繪圖與模擬&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;以下主要以教導 FeatureScript 為目的, 依據下列圖示作為參考:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/spur_gear_dimension_4.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;假設齒數為 n, 模數為 m, 壓力角為 pa, 則正齒輪的節圓半徑為 &lt;span class="math"&gt;\(rp = m*n/2\)&lt;/span&gt;, 且基圓半徑 &lt;span class="math"&gt;\(rb = rp*cos(pa)\)&lt;/span&gt;, 假設齒根 &lt;span class="math"&gt;\(d = 2.5*rp/n\)&lt;/span&gt;, 齒頂圓半徑 &lt;span class="math"&gt;\(ra = rp + m\)&lt;/span&gt;, 齒根圓半徑 &lt;span class="math"&gt;\(rd = rp - d\)&lt;/span&gt;, 接著當齒數 n 小於 &lt;span class="math"&gt;\(2.5/(1-cos(pa))\)&lt;/span&gt; 時就能夠從基圓開始繪製漸開線到齒頂圓, 若 n 大於 &lt;span class="math"&gt;\(2.5/(1-cos(pa))\)&lt;/span&gt;, 則漸開線必須從齒根圓畫起, 而不是從基圓畫起 (因為基圓半徑已經小於齒根圓半徑). 有關這一點, Onshape 官方釋出的漸開線&lt;a href="https://cad.onshape.com/documents/57494152e4b05f50e871a72c/w/a4a3f09939bf1f43a8e4f133/e/2b865798923d6f648f7196f9"&gt;正齒輪繪圖 FeatureScript 程式第1版&lt;/a&gt;也未能納入考量, 因此當選擇壓力角 20 度時, 若齒數超過 43 齒, 或者選擇壓力角 15.5 度, 當齒數超過 70 齒, 正齒輪的輪廓就會出錯. 之後當以下的練習完成後, 就可以將漸開線納入 spline 中, 並且加上齒輪底部的導倒圓角後, 就能夠修正上述的錯誤.&lt;/p&gt;
&lt;p&gt;以下為 17 齒, 模數 20 mm, 壓力角 20 度的漸開線正齒輪輪廓繪圖:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/onshape_spur_gear1.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;以下為 170 齒, 模數 20 mm, 壓力角 20 度的漸開線正齒輪輪廓繪圖:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/onshape_spur_gear2.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;以下為對應的 FeatureScript 正齒輪輪廓繪圖程式碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 355;
import(path : "onshape/std/geometry.fs", version : "355.0");

annotation { "Feature Type Name" : "Spur2" }
export const spur = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        // 正齒輪齒數, 由使用者輸入, 型別為整數
        annotation { "Name" : "Number of Gear Tooth" }
        isInteger(definition.n, POSITIVE_COUNT_BOUNDS);
        // 正齒輪模數, 由使用者輸入, 型別為長度, 為內建尺寸單位
        annotation { "Name" : "Module" }
        isLength(definition.module, LENGTH_BOUNDS);
        // 正齒輪壓力角, 由使用者輸入, 型別為角度, 為內建角度單位
        annotation { "Name" : "Pressure Angle" }
        isAngle(definition.pa, ANGLE_360_BOUNDS);
        // 正齒輪圓心座標點, 由使用者選擇
        annotation { "Name" : "Select a point", "Filter" : EntityType.VERTEX, "MaxNumberOfPicks" : 1 }
        definition.point is Query;
    }
    {
        // Precondition 中的查詢, 需要 evalue 才能傳回對應的 entity
        var location = evaluateQuery(context, definition.point)[0];
        // location 變數為點座標對應的 entity, 必須透過 evVetexPoint 的評量才能傳回對應的點座標
        var center3D = evVertexPoint(context, {
                "vertex" : location
        });

        // 作圖平面利用 evOwnerSketch 評量, 與 location entity 同一個平面
        var sketchPlane = evOwnerSketchPlane(context, {
                "entity" : location
        });
        // 作圖畫
        const gearSketch = newSketchOnPlane(context, id + "gearSketch", {
                "sketchPlane" : sketchPlane
        });
        // 利用 worldToPlane, 將 center3D 轉換為 sketchPlane 上的平面點座標
        const center2D = worldToPlane(sketchPlane, center3D);
        //print(center2D);
        // 漸開線近似點數
        var imax = 5;
        // 使用者所選的齒輪圓心 x 座標
        var midx = center2D[0];
        // 使用者所選的齒輪圓心 y 座標
        var midy = center2D[1];
        // 齒數
        var n = definition.n;
        // 模數
        var m = definition.module;
        // 壓力角, 單位為角度
        var pa = definition.pa;
        // 齒輪的節圓半徑
        var rp = m*n/2;
        skLineSegment(gearSketch, "line", {
        "start" : vector(midx,midy),
        "end" : vector(midx,midy+rp)
        });
        // 齒根
        var d = 2.5*rp/n;
        // 齒頂圓半徑
        var ra = rp + m;
        // 基圓半徑
        var rb = rp*cos(pa);
        //print(rb);
        // 齒根圓半徑
        var rd = rp - d;
        // 分段後齒頂與齒根半徑差增量
        var dr = 0*meter;
        // 若 rb &amp;gt; rd 時從基圓開始繪製漸開線, 但是若 rd &amp;gt; rb, 則漸開線從 rd 畫到齒頂圓
        if (rd &amp;gt; rb)
        {
            // 半徑差的分段, 由齒根圓到齒頂圓
            dr = (ra-rd)/imax;
        }
        else
        {
            // 半徑差的分段, 由基圓到齒頂圓
            dr = (ra-rb)/imax;
        }
        // PI 為實數值沒有單位, tan(pa)也沒有單位, pa 已經設定單位為 degree, 這裡為了與 radian 運算
        // 系統會自動轉為 radian
        var rot = PI/(2*n)*radian;
        //print(sigma);
        // 分別用來設定 entity id 用的增量變數
        var nameId = 1;
        var nameId2 = 1;
        var r = 0*meter;
        // theta 為浮點數字
        var theta = 0;
        var inv = 0*radian;
        var inc = 0*radian;
        // 當 r=rp 時 ,計算 inv_rp 用來旋轉漸開線用
        // theta 為沒有單位的實數
        theta = sqrt((rp*rp)/(rb*rb)-1);
        // atan(theta) 為 radian
        var inv_rp = theta*radian-atan(theta);
        // 漸開線上點的 x 座標
        var xpt = 0*meter;
        // 漸開線上點的 y 座標
        var ypt = 0*meter;
        // 左側漸開線第1點座標 left first x and y
        var lfx = 0*meter;
        var lfy = 0*meter;
        // 右側漸開線第1點座標 right first x and y
        var rfx = 0*meter;
        var rfy = 0*meter;
        // 左側齒根圓上點座標 left x of dedendum point
        var lxd = 0*meter;
        var lyd = 0*meter;
        // 右側齒根圓上點座標 right x of dedendum point
        var rxd = 0*meter;
        var ryd = 0*meter;
        // 左側齒根圓上點座標 right x of dedendum point (advanced)
        var lxd_ad = 0*meter;
        var lyd_ad = 0*meter;
        var inc_ad = 0*radian;
        for (var j=0;j&amp;lt;n;j+=1)
        {
            // 當 j 增量時, 按照齒數輪廓繞行旋轉增量角度
            inc = (2.*j*PI/n)*radian;
            inc_ad = (2.*(j+1)*PI/n)*radian;
            if (rd&amp;gt;rb)
            {
                // 當齒根半徑因為齒數增多後大於基圓半徑時, 漸開線從齒根圓長起
                theta = sqrt((rd*rd)/(rb*rb)-1.);
                inv = theta*radian-atan(theta);
                // 左側漸開線第1點座標
                // 左側輪廓線配合逆時針旋轉 inc 角度
                lfx = midx+rd*sin(inv-rot-inv_rp+inc);
                lfy = midy+rd*cos(inv-rot-inv_rp+inc);
                lxd = lfx;
                lyd = lfy;
                lxd_ad = midx+rd*sin(inv-rot-inv_rp+inc_ad);
                lyd_ad = midy+rd*cos(inv-rot-inv_rp+inc_ad);
                // 右側漸開線第1點座標
                // 右側輪廓線配合順時針旋轉 inc 角度
                rfx = midx-rd*sin(inv-rot-inv_rp-inc);
                rfy = midy+rd*cos(inv-rot-inv_rp-inc);
                rxd = rfx;
                ryd = rfy;
                // 齒根圓上的直線 on dedendum points
                skLineSegment(gearSketch, "line_dd" ~ nameId, {
                "start" : vector(rxd,ryd),
                "end" : vector((lxd_ad),(lyd_ad))
                });
            }
            else
            {
                // 當基圓半徑大於齒根圓時, 漸開線從基圓長起
                theta = sqrt((rb*rb)/(rb*rb)-1.);
                inv = theta*radian-atan(theta);
                // 左側漸開線第1點座標
                lfx = midx+rb*sin(inv-rot-inv_rp+inc);
                lfy = midy+rb*cos(inv-rot-inv_rp+inc);
                lxd = midx+rd*sin(inv-rot-inv_rp+inc);
                lyd = midy+rd*cos(inv-rot-inv_rp+inc);
                lxd_ad = midx+rd*sin(inv-rot-inv_rp+inc_ad);
                lyd_ad = midy+rd*cos(inv-rot-inv_rp+inc_ad);
                // 從基圓點到齒根圓點, 畫直線 left from base point to dedendum point
                skLineSegment(gearSketch, "line_lbd" ~ nameId, {
                "start" : vector(lfx,lfy),
                "end" : vector((lxd),(lyd))
                });
                // 右側漸開線第1點座標
                rfx = midx-rb*sin(inv-rot-inv_rp-inc);
                rfy = midy+rb*cos(inv-rot-inv_rp-inc);
                rxd = midx-rd*sin(inv-rot-inv_rp-inc);
                ryd = midy+rd*cos(inv-rot-inv_rp-inc);
                // 從基圓點到齒根圓點, 畫直線 right from base point to dedendum point
                skLineSegment(gearSketch, "line_rbd" ~ nameId, {
                "start" : vector(rfx,rfy),
                "end" : vector((rxd),(ryd))
                });
                // 齒根圓上的直線 on dedendum points
                skLineSegment(gearSketch, "line_dd" ~ nameId, {
                "start" : vector(rxd,ryd),
                "end" : vector((lxd_ad),(lyd_ad))
                });
            }

            for (var i=1; i&amp;lt;imax+1; i+= 1)
            {
                // 先處理中線左側的漸開線
                // 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if (rd&amp;gt;rb)
                {
                    r = rd+i*dr;
                }
                else
                {
                    r = rb+i*dr;
                }
                theta = sqrt((r*r)/(rb*rb)-1);
                var inv = theta*radian-atan(theta);
                // 漸開線上的點座標
                xpt = midx+r*sin(inv-rot-inv_rp+inc);
                ypt = midy+r*cos(inv-rot-inv_rp+inc);
                // lxd, lyd 為漸開線上的繪線起點座標
                skLineSegment(gearSketch, "lineb" ~ nameId, {
                "start" : vector(lfx,lfy),
                "end" : vector((xpt),(ypt))
                });
                // 更新漸開線點座標
                lfx = xpt;
                lfy = ypt;
                nameId += 1;
            }
            // 紀錄左側漸開線的最後一點, 也就是齒頂圓上的點座標
            var lastlx = xpt;
            var lastly = ypt;
            // another side
            for (var i=1; i&amp;lt;imax+1; i+= 1)
            {
                if (rd&amp;gt;rb)
                {
                    r = rd+i*dr;
                }
                else
                {
                    r = rb+i*dr;
                }
                theta = sqrt((r*r)/(rb*rb)-1);
                var inv = theta*radian-atan(theta);
                // 漸開線上的點座標
                xpt = midx-r*sin(inv-rot-inv_rp-inc);
                ypt = midy+r*cos(inv-rot-inv_rp-inc);
                // rxd, ryd 為漸開線上的繪線起點座標
                skLineSegment(gearSketch, "linec" ~ nameId, {
                "start" : vector(rfx,rfy),
                "end" : vector((xpt),(ypt))
                });
                // 更新漸開線點座標
                rfx = xpt;
                rfy = ypt;
                nameId += 1;
            }
            var lastrx = xpt;
            var lastry = ypt;
            // 齒頂連線
            skLineSegment(gearSketch, "lined" ~ nameId2, {
            "start" : vector(lastlx,lastly),
            "end" : vector(lastrx,lastry)
            });
            nameId2 += 1;
        }
    skSolve(gearSketch);
    });
&lt;/pre&gt;

&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="Onshape"></category><category term="FeatureScript"></category></entry><entry><title>電腦輔助設計室相關區域網路設定</title><link href="http://cadlab.mde.tw/post/dian-nao-fu-zhu-she-ji-shi-xiang-guan-qu-yu-wang-lu-she-ding.html" rel="alternate"></link><updated>2016-06-14T22:36:38+08:00</updated><author><name>Cad Lab</name></author><id>tag:cadlab.mde.tw,2016-06-14:post/dian-nao-fu-zhu-she-ji-shi-xiang-guan-qu-yu-wang-lu-she-ding.html</id><summary type="html">&lt;p&gt;今天早上發現一台 Asus 電腦, 裝了 IIS 8 的伺服器佔用了 17.9 的 IPV4 網路位址, 導致原先配置的 Ubuntu 16.04 代理主機無法正常連線.&lt;/p&gt;


&lt;p&gt;其實自從 2012 年起台灣就已經逐步完善 IPV6 的網路環境, 而且各種最新的操作系統也都已經提供 IPV6 相關協定的支援, 但是許多用戶仍然只用 IPV4 協定, 而且無論是客戶端或伺服器端, 一律搶佔已經不敷分配的 IPV4 網路位址.&lt;/p&gt;
&lt;p&gt;當然, 電腦輔助設計室周遭相關的區域網路, 目前只有兩種伺服器非採用 IPV4 協定不可, 一種是各式 CAD/CAE/CAM/PLM 軟體的網路認証主機, 一種則是同時支援 IPV4/IPV6 的 Proxy Servers.&lt;/p&gt;
&lt;p&gt;各式 CAD/CAE/CAM/PLM 軟體的網路認証主機, 早就已經支援 IPV6, 因此採用 IPV6 協定設置的認証主機, 可以服務純 IPV6 的客戶端, 但是仍然有許多的客戶端仍然使用純 IPV4 協定上網, 因此這些客戶端除非採用內部虛擬主機的自我認証, 否則仍然必須採用 IPV4 協定, 連接到區域或廣域網路上的認証伺服器.&lt;/p&gt;
&lt;p&gt;在台灣教育界有一個非常有趣的現象, 假如用戶堅持要使用合法購買的各式 CAD/CAE/CAM/PLM 軟體, 負責管理的團隊就必須花錢買罪受, 肩負多元合法軟體的認証伺服器的管理, 而且大部份負責代理這些軟體套件的公司, 都希望將網路認証授權綁在特定的封閉區域網路上, 一來, 可以多賣些套數, 二來也能避開紛擾較多的廣域網路認証主機的管理工作.&lt;/p&gt;
&lt;p&gt;上面提到佔用合法 IP 位址的電腦, 網卡的硬體位址以 9c:5c:8e 開頭, 這個網卡從 &lt;a href="http://aruljohn.com/mac/9C5C8E"&gt;http://aruljohn.com/mac/9C5C8E&lt;/a&gt; 就可以得知來自 Asus, 因此合理的推論, 是一台 Asus 的伺服器, 並且從 http 連線可以看到 IIS 8, 因此應該是安裝 MS 2012 Server 以上的伺服操作系統. 並且從已經開啟的 3389 埠號, 也可以確定 Remote Desktop 已經啟用, 並且允許廣域網路上的任何主機連線. 比較特殊的是沒有任何的 https 埠號啟用, 因此假如這台伺服器提供任何需要使用者輸入帳號密碼的應用, 這些帳號密碼已經透過明碼傳遞曝露在區域網路的封包中.&lt;/p&gt;
&lt;p&gt;其實, 上述合法 IPV4 位址被搶佔的問題, 早就可以透過 MAC 綁定 IPV4 的方案解決, 但是因為電腦輔助設計室中的伺服器數量超過 30 台, 許多伺服器的任務多元, 且經常更換, 因此自 2015 年秋季開始, 已經透過校方建置的雲端虛擬主機逐步取代實體主機, 而且部份上課的網路連線也將採純 IPV6 設定上網, 一旦各 Proxy Server 的任務確定, 就可以將伺服器 MAC 位址與 IPV4 位址綁定, 上述的網址佔用問題就不會存在.&lt;/p&gt;
&lt;p&gt;接下來, 看一下有關電腦輔助設計室相關區域網路的 IPV6 網路設定, 虎尾科技大學機械設計工程系的 IPV6 網址區段為 2001:288:6004:17, 路由器的通道為 2001:288:6004:17::254, 而校方的 DNS 為 2001:288:6004:1::2, 中華電信的 DNS 則為 2001:b000:168::1, 因此使用者要設定 IPV6 網路連線, 只需要知道自己電腦所配置的網段即可.&lt;/p&gt;
&lt;p&gt;從 IPV6 的網路定址格式, 機械設計工程系可用網段為 2001:288:6004:17:0000:0000:0000:0000 ~ 2001:288:6004:17:FFFF:FFFF:FFFF:FFFF, 總共可配置 IPV6 總數為 16^16 = 1.8446744e+19, 可以透過教師編號 (例如為 3001), 將則其所屬的學生與實習研究室 IPV6 分配網段為 2001:288:6004:17:3001:0000:0000:0000 ~ 2001:288:6004:17:3001:FFFF:FFFF:FFFF (可配置位址總數為 16^12 = 2.8147498e+14), 且將 2001:288:6004:17:0000:0000:0000:0000 ~ 2001:288:6004:17:0000:0000:0000:FFFF 保留給電腦輔助設計室與工作站室相關主機使用 (可配置 IPV6 位址總數為 16^4 = 65536), 而行政管理相關的 IPV6 網段則使用 2001:288:6004:17:168:0000:0000:0000 ~ 2001:288:6004:17:168:FFFF:FFFF:FFFF (可配置位址總數為 16^12 = 2.8147498e+14).&lt;/p&gt;
&lt;p&gt;之後, 將要利用回收的 20 個 IPV4 網址來配置同時支援 IPV4/IPV6 的 Proxy Server, 並且利用雙協定支援的 DNS 來配置這些伺服器, 遙望 IPV6 的世界, 應該再沒有 IPV6 網址短缺的機會了!&lt;/p&gt;</summary><category term="電腦輔助設計室"></category><category term="IPV6"></category><category term="IPV4"></category></entry><entry><title>Onshape Featurescript Tutorial 導引</title><link href="http://cadlab.mde.tw/post/onshape-featurescript-tutorial-dao-yin.html" rel="alternate"></link><updated>2016-06-14T22:36:38+08:00</updated><author><name>Cad Lab</name></author><id>tag:cadlab.mde.tw,2016-06-14:post/onshape-featurescript-tutorial-dao-yin.html</id><summary type="html">&lt;p&gt;Onshape 配合公開 FeatureScript 特徵程式語言的過程, 特別製作了一個詳細的教學導引:&lt;a href="https://cad.onshape.com/FsDoc/tutorials/create-a-slot-feature.html"&gt;https://cad.onshape.com/FsDoc/tutorials/create-a-slot-feature.html&lt;/a&gt;, 從這個導引中, 可以一窺 FeatureScript 的基本用法.&lt;/p&gt;


&lt;p&gt;左下角所謂的頁面創建功能 (也就是 + 號所在), 增加了創建 Feature Studio (特徵工房) 的選項, 可以讓使用者利用特徵工房中的 IDE (Integrated Development Environment) 環境, 開發獨特的客製化特徵程式.&lt;/p&gt;
&lt;p&gt;所以 Feature Studio 是 Onshape 的一種特殊頁面 (Tab), 其中提供編修 FeatureScript 程式的各種工具.&lt;/p&gt;
&lt;p&gt;進入 Feature Studio 後, 通常第一件事就是按下 New Feature 按鈕, 可以在特徵程式編輯區 (採用 &lt;a href="https://github.com/ajaxorg/ace"&gt;Ace.js&lt;/a&gt;) 中帶出 FeatureScript 程式的 Template codes (程式模版). 程式模版中包含所導入的 FeatureScript 程式庫版本, 以及即將讓使用者定義的客製化特徵函式區, 模版程式如下:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
// 宣告所使用的 FeatureScript 版次
FeatureScript 355;
// 配合所使用的 FeatureScript 版次, 導入 geometry 標準程式庫
import(path : "onshape/std/geometry.fs", version : "355.0");

// 利用 New Feature 所產生的程式模版, 包含 annotation 與 myFeature 常數的 export
// 其中使用了匿名函式的立即實例化, 使用者負責填入此一匿名函式的 precondition 與函式內容
// precondition 區主要在設定 FeatureScript 的 GUI 介面, 而函式內容則可實際產生各式特徵操作
annotation { "Feature Type Name" : "My Feature" }
export const myFeature = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        // 特徵程式的使用者介面對話設計, 包括輸入表單, 各式選單以及使用者動態選擇的各種幾何特徵
    }
    {
        // 定義函式的幾何操作內容
    });
&lt;/pre&gt;

&lt;p&gt;在 precondition 的大括號中間, 以鍵盤輸入 qu, FeatureScript Studio 就會啟動 Autocompletion 功能, 列出可以選用的 Query 設定, 並且列出詳細的使用說明, 其中的 Query parameter 是 snippet 小程式段外, 其餘都是查詢函式.&lt;/p&gt;
&lt;p&gt;Query parameter 的程式段如下:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
annotation { "Name" : "My Query", "Filter" : EntityType.FACE, "MaxNumberOfPicks" : 1 }
definition.myQuery is Query;
&lt;/pre&gt;

&lt;p&gt;當使用者在 precondition 對話區建立兩個查詢變數後, 就可以提交 (commit) 所增加的 FeatureScript 程式, 提交程式的目的在讓其他的頁面 (Tabs) 可以使用此一特徵程式. 另外假如 Feature Studio 中有新增資料尚未提交, 頁面上的特徵程式名稱前面會多一個 * 號, 一旦提交後, 此一 * 符號就會消失, 表示所有新增或編修的 FeatureScript 程式都已經提交到 Document 的模型本體.&lt;/p&gt;
&lt;p&gt;FeatureScript 語法中的 annotation 資料型別為 map, 類似 Python 的 Dictionary 資料型別, 且 map 的 key 一律為字串, 以 slot 程式範例而言, annotation { "Feature Type Name" : "Slot" } 中的 "Feature Type Name" 為每一個特徵函式的必要字串鍵值, 這裡的對應名稱為 "slot".&lt;/p&gt;
&lt;p&gt;從導引影片的操作, 也可以看到當使用者利用某一個平面草圖執行擠出後, 原先的草圖將會內定隱藏, 但隨後將需要選擇此一草圖上的其他線段, 因此必須在特徵瀏覽視窗中, 將此草圖顯示出來.&lt;/p&gt;
&lt;p&gt;另外, 當使用者在設計 FeatureScript 程式的 Query 對話區表單時, 可以透過 "Filter" 字串鍵進行控制可選的幾何元素, 例如, "Slot path" 對應的 "Filter" 為 EntityType.EDGE, 表示只能選擇 EDGE 幾何元件, 且透過 "MaxNumberOfPicks", 限定只能選擇一個 EDGE.
"Part to cut" 的 Query 則以 EntityType.BODY &amp;amp;&amp;amp; BodyType.SOLID 界定, 表示只能選擇 SOLID BODY.&lt;/p&gt;
&lt;p&gt;其次, FeatureScript 的所有尺寸, 角度與重量變數, 都隨使用者所選擇的單位而自動換算, 而且支援不同單位的&lt;a href="https://cad.onshape.com/FsDoc/intro.html"&gt;混合運算&lt;/a&gt;, 因此除了在互動區設定的 definition.variable_name 會根據 Onshape Document 中的單位為準外, 其他在函式定義過程中新增的其他變數, 必須自行加註單位, 否則會產生具單位尺寸與無單位設定的變數運算的錯誤.&lt;/p&gt;
&lt;p&gt;接下來, 當使用者開始進入函式內容的幾何模型操作時, 就必須對 id 型別有些認識. 模型主體 (Context) 中的所有特徵, 子特徵與操作, 都配置獨特的 id 加以辨識. 獨特的 id 可以在查詢, 錯誤回報或者取用特徵或操作時有所依據. id 的標示依照模型本體中各特徵與操作的關係, 以從屬架構表示. 也就是說 ,每一個操作項目的 id 都有其上層對應項目的 id. 過程中可以利用 newId() 函式來產生根項目 id, 隨後的子 id 則利用 + 運算子進行附加.&lt;/p&gt;
&lt;p&gt;在 Onshape FeatureScript 手冊中舉例, id + "foo" 中的 "foo" 就是子項目的 id 名稱, 而其父項目就是 id 變數. 依此類推, id + "foo" + "bar" 的就是以 "bar" 作為子項目的 id, 而其父項目的 id 就是 id + "foo". 而且在 FeatureScript 中 id 的資料型別為陣列, 其算元素為字串, 可以經過陣列元素表示各項目的路徑. &lt;/p&gt;
&lt;p&gt;例如, newId() + "foo" + "bar" 等同 id 值為 ["foo", "bar"], 但是實際操作仍以前面的用法為主.&lt;/p&gt;
&lt;p&gt;slot 教學導引的後段操作, 接續在互動介面區所設定的兩個 Query 與一個 Parameter 輸入, Query1 是選擇 "Slot path", 並將選擇與 definition.slotPath 變數對應, Query2 則選擇 "Part to cut", 以 definition.partToCut 表示, 而切槽的寬度則由使用者在欄位中輸入, 以 definition.width 變數表示.&lt;/p&gt;
&lt;p&gt;接下來, 則以 definition.slotPath 透過 opExtrude 操作長出橫貫 "Part to cut" 本體的平面, 接著利用 opThicken 操作, 對用來切槽的平面增加厚度, 而且一旦平面加厚成為實體之後, 就利用 opDeleteBodies 操作, 將此平面刪除, 最後的操作則是利用 opBoolean 操作, 以增厚的平面實體對 "Part to cut" 進行除料, 就完成 slot 客製 FeatureScript 程式的製作.&lt;/p&gt;
&lt;p&gt;slot FeatureScript 程式碼如下:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 355;
import(path : "onshape/std/geometry.fs", version : "355.0");

annotation { "Feature Type Name" : "Slot" }
export const slot = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        // Query for EDGE entity
        annotation { "Name" : "Slot path", "Filter" : EntityType.EDGE, "MaxNumberOfPicks" : 1 }
        definition.slotPath is Query;
        // Query for Body entity
        annotation { "Name" : "Part to cut", "Filter" : EntityType.BODY &amp;&amp; BodyType.SOLID, "MaxNumberOfPicks" : 1 }
        definition.partToCut is Query;
        // parameter input field for width
        annotation { "Name" : "Width" }
        isLength(definition.width, LENGTH_BOUNDS);
    }
    {
        // Extrude operation, id is extrude1
        opExtrude(context, id + "extrude1", {
               "entities" : definition.slotPath,
               "direction" : evOwnerSketchPlane(context, {"entity" : definition.slotPath}).normal,
               "endBound" : BoundingType.THROUGH_ALL,
               "startBound" : BoundingType.THROUGH_ALL
        });

        // Thicken operation for extrude1 entity
        opThicken(context, id + "thicken1", {
               "entities" : qCreatedBy(id + "extrude1", EntityType.BODY),
               "thickness1" : definition.width / 2,
               "thickness2" : definition.width / 2
        });

        // DeleteBodies operation to delete extrude1
        opDeleteBodies(context, id + "delete1", {
               "entities" : qCreatedBy(id + "extrude1", EntityType.BODY)
        });

        // Boolean operation to subtract the thicken1 from partToCut part
        opBoolean(context, id + "boolean1", {
               "tools" : qCreatedBy(id + "thicken1", EntityType.BODY),
               "targets" : definition.partToCut,
               "operationType" : BooleanOperationType.SUBTRACTION
        });

    });
&lt;/pre&gt;

&lt;p&gt;有了 slot 操作基礎後, 就可以進一步完成繪製齒輪與鏈輪輪廓的程式模版:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 355;
import(path : "onshape/std/geometry.fs", version : "355.0");

annotation { "Feature Type Name" : "Gear test" }
export const gearTest = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        // 圓半徑直接輸入表單為 radius 的欄位中
        annotation { "Name" : "radius" }
        isLength(definition.radius, LENGTH_BOUNDS);
        // 在 Select a point 輸入區為查詢, 只能選擇既有的 VERTEX, 且只選一個點
        annotation { "Name" : "Select a point", "Filter" : EntityType.VERTEX, "MaxNumberOfPicks" : 1 }
        definition.point is Query;
    }
    {
        // Precondition 中的查詢, 需要 evalue 才能傳回對應的 entity
        var location = evaluateQuery(context, definition.point)[0];
        // location 變數為點座標對應的 entity, 必須透過 evVetexPoint 的評量才能傳回對應的點座標
        var center3D = evVertexPoint(context, {
                "vertex" : location
        });

        // 作圖面利用 evOwnerSketch 評量, 與 location entity 同一個平面
        var sketchPlane = evOwnerSketchPlane(context, {
                "entity" : location
        });
        // 利用 worldToPlane, 將 center3D 轉換為 sketchPlane 上的平面點座標
        const center2D = worldToPlane(sketchPlane, center3D);
        // 接下來利用 sketchPlane 建立一個草圖畫布元件
        const gearSketch = newSketchOnPlane(context, id + "gearSketch", {
                "sketchPlane" : sketchPlane
        });

        // 有了草圖畫布元件, 就可以在其上進行各式平面繪圖, 這裡利用 center2D 點作為圓心, definition.radius 作為半徑畫圓
        skCircle(gearSketch, "circle1", {
                "center" : center2D,
                "radius" : definition.radius
        });

        // 接著從圓心, 沿 x 軸方向畫一條長度為半徑的直線
        skLineSegment(gearSketch, "line1", {
                "start" : center2D,
                "end" : center2D + vector(1, 0) * definition.radius
        });

        // 這裡使用固定點在畫布上繪製平滑曲線, 之後可以直接用來繪製各種齒輪或鏈輪輪廓
        skFitSpline(gearSketch, "spline1", {
                "points" : [
                    vector( 0,  0) * inch,
                    vector( 0, -1) * inch,
                    vector( 1,  1) * inch,
                    vector(-1,  0) * inch,
                    vector( 0,  0) * inch
                ]
        });

        // 利用 skSolve 解出畫布上的所有繪圖內容, 並顯示出來
        skSolve(gearSketch);
    });
&lt;/pre&gt;</summary><category term="Onshape"></category><category term="FeatureScript"></category></entry><entry><title>電腦輔助設計室電腦磁區規劃</title><link href="http://cadlab.mde.tw/post/dian-nao-fu-zhu-she-ji-shi-dian-nao-ci-qu-gui-hua.html" rel="alternate"></link><updated>2016-06-14T22:36:38+08:00</updated><author><name>Cad Lab</name></author><id>tag:cadlab.mde.tw,2016-06-14:post/dian-nao-fu-zhu-she-ji-shi-dian-nao-ci-qu-gui-hua.html</id><summary type="html">&lt;div&gt;希望能根據不同性質課程, 將軟體分為 3 個開機磁區:&lt;/div&gt;

&lt;ol&gt;
    &lt;li&gt;安裝所有老師提出的上課套件, 集中在第 1 磁區, 其中包括 CAD, CAE, CAM, 數值分析與自動控制相關所有套件.&lt;/li&gt;
    &lt;li&gt;只安裝 Solidworks, PTC Creo, AutoDesk Inventor, AutoCAD, A360, Ansys, Comsol, Matlab 與 Mathematica, 等 CAD, CAE 與數值分析相關套件.&lt;/li&gt;
    &lt;li&gt;只安裝操作系統, 加上無需安裝的綠色套件 (PTC, Creo, Comsol, Matlab 等).&lt;/li&gt;
&lt;/ol&gt;

&lt;div&gt;



&lt;/div&gt;

&lt;div&gt;至於以上 3 個開機磁區則傾向將新購買的 Windows 10 Pro 操作系統降為 Windows 7 Pro, 以提升使用效能. 但是仍然在第 2 磁區利用 Virtualbox 建立安裝 Windows 10 Pro 的兩台虛擬機器, 其中一台虛擬機配合安裝 Solidworks, PTC Creo, AutoDesk Inventor 與 Matlab , 而另一台虛擬機也採用 Windows 10 Pro 開機, 但只配置各軟體的原始 DVD, 可以讓老師教導學生執行各套件安裝與設定的教學.&lt;/div&gt;

&lt;div&gt;至於第 3 磁區則將利用 Virtualbox 建立一台配置&lt;a href="http://www.squid-cache.org/"&gt;網路代理功能&lt;/a&gt; (IPV4/IPV6 雙支援) 的 Ubuntu Server 虛擬伺服器, 以及一台空白的 Windows 10 Pro 虛擬機, 以便在純 IPV6 環境下進行課程教學.&lt;/div&gt;

&lt;div&gt;註解:&lt;/div&gt;

&lt;p&gt;根據 &lt;a href="https://en.wikipedia.org/wiki/X86_virtualization#Intel-VT-x"&gt;https://en.wikipedia.org/wiki/X86_virtualization#Intel-VT-x&lt;/a&gt; 與 &lt;a href="https://en.wikipedia.org/wiki/List_of_Intel_Core_i7_microprocessors"&gt;https://en.wikipedia.org/wiki/List_of_Intel_Core_i7_microprocessors&lt;/a&gt; 的說明, 幾乎所有的 Intel CPU 都已經支援 VT-x 虛擬技術, 只要電腦的其他軟硬體配合啟動 VT-x, 就可以在 64 位元的操作系統主體, 模擬 64 位元的虛擬機, 假如再配合 Oracle 的新聞稿: &lt;a href="http://www.oracle.com/us/corporate/press/1842885"&gt;http://www.oracle.com/us/corporate/press/1842885&lt;/a&gt; 說明, Virtualbox 中的一台虛擬機 (Virtual Machine) 最多可以啟用 36 片虛擬網路卡, 因此只要電腦主體的硬體支援許可, 利用虛擬機就能有效模擬出相當複雜的網路伺服器架構.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/virtualbox5_upto_36_NIC.png" width="800" /&gt;&lt;/p&gt;</summary><category term="電腦輔助設計室"></category><category term="電腦硬體"></category></entry><entry><title>CADLab 新電腦系統</title><link href="http://cadlab.mde.tw/post/cadlab-xin-dian-nao-xi-tong.html" rel="alternate"></link><updated>2016-06-14T22:36:38+08:00</updated><author><name>Cad Lab</name></author><id>tag:cadlab.mde.tw,2016-06-14:post/cadlab-xin-dian-nao-xi-tong.html</id><summary type="html">&lt;p&gt;CPU 選擇: &lt;span style="background-color: #ffff00;"&gt;Intel i7-6700&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Ram  選擇: &lt;span style="background-color: #ffff00;"&gt;16GB (8GBx2) DDR4-3000 (至少還可再升級 8GBx2)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;HD: &lt;span style="background-color: #ffff00;"&gt;2TB (64MB) SATA III&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Video Card: &lt;span style="background-color: #ffff00;"&gt;NVIDIA GEFORCE GTX950 2GB GDDR5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;NIC: &lt;span style="background-color: #ffff00;"&gt;1Gbits/s*5 (除了主機板上的兩片網路卡之外 ,再加上 3 片外接式網路卡, 以便與各開機磁區中的虛擬機橋接出虛擬的多台連外伺服器)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;參考:&lt;/p&gt;
&lt;p&gt;i7: &lt;a href="https://en.wikipedia.org/wiki/List_of_Intel_Core_i7_microprocessors"&gt;https://en.wikipedia.org/wiki/List_of_Intel_Core_i7_microprocessors&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;i7-6700: &lt;a href="http://ark.intel.com/products/88196"&gt;http://ark.intel.com/products/88196&lt;/a&gt;&lt;/p&gt;</summary><category term="電腦輔助設計室"></category><category term="電腦硬體"></category></entry><entry><title>Onshape FeatureScript 程式語言 (一)</title><link href="http://cadlab.mde.tw/post/onshape-featurescript-cheng-shi-yu-yan-yi.html" rel="alternate"></link><updated>2016-06-14T22:36:38+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-06-14:post/onshape-featurescript-cheng-shi-yu-yan-yi.html</id><summary type="html">&lt;p&gt;接續上一篇文章, 整理目前 Onshape 已經釋出的 FeatureScript 相關應用範例.&lt;/p&gt;


&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/574941a2e4b05f50e871a75a/w/1c096ba7cb6b4bb6d74f8ffa/e/8c83ef9b92095a980e185cf8"&gt;Curve Pattern FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494139e4b04aa3f56f8243/w/cad51c78bef702f93d689668/e/0cfa9d7c4606e1f2ae32be16"&gt;Helix in Fill FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494120e4b04aa3f56f8206/w/d17e3ff3f757fabdb9084368/e/ab4048d5790d64d16e68e02d"&gt;3D Spline Fill FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494101e4b04aa3f56f81ed/w/b2ffdc215aff14ea3817b535/e/1626934c31793c1d4d18eb6f"&gt;Brick FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494096e4b05f50e871a70e/w/165ebc7b4103e5b6c91e3f5b/e/bfd58761a0e39c157f11bd42"&gt;Measure Distance FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/5749420ae4b04aa3f56f8288/w/ed9f79b9809ffe7610f9c537/e/aa01cfec5e04037e7ca611b7"&gt;Lighten FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Snap Hook FeatureScript 程式原始碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
/*    
    Snap Hook

    This custom feature creates a common fastening feature in plastic part design.

    The Snap Hook is just one version of this type of fastening feature 
    and could be easily extended to include many other types. This was built
    to show that you can create complex, compound features easily.

    Version 1 - April 26, 2016 - Neil Cooke, Onshape Inc.
*/ 

FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

annotation { "Feature Type Name" : "Snap Hook" }
export const SnapHook = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Sketch point locations", "Filter" : EntityType.VERTEX &amp;&amp; SketchObject.YES &amp;&amp; ConstructionObject.NO }
        definition.locations is Query;

        annotation { "Name" : "Height type" }
        definition.style is HookStyle;

        if (definition.style == HookStyle.BLIND)
        {
            annotation { "Name" : "Height", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.height, HOOK_HEIGHT);
        }
        else
        {
            annotation { "Name" : "Parallel face or plane", "Filter" : EntityType.FACE, "MaxNumberOfPicks" : 1 }
            definition.parallelFace is Query;
        }

        annotation { "Name" : "Width", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.hookWidth, HOOK_WIDTH);

        annotation { "Name" : "Flip direction", "UIHint" : "OPPOSITE_DIRECTION" }
        definition.hookFlipDirection is boolean;

        annotation { "Name" : "Edge to define direction", "Filter" : EntityType.EDGE, "MaxNumberOfPicks" : 1 }
        definition.hookDirection is Query;

        annotation { "Name" : "Thickness", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.hookThickness, HOOK_THK);

        annotation { "Name" : "Undercut depth", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.hookDepth, HOOK_THK);

        annotation { "Name" : "Lip height", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.flatHeight, HOOK_LIP);

        annotation { "Name" : "Insertion angle", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isAngle(definition.deflectionAngle, HOOK_ANGLE);

        annotation { "Name" : "Draft", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"], "Default" : true }
        definition.hasDraft is boolean;

        if (definition.hasDraft == true)
        {
            annotation { "Name" : "Draft angle", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
            isAngle(definition.draftAngle, ANGLE_STRICT_90_BOUNDS);

            annotation { "Name" : "Back face draft angle", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isAngle(definition.backDraftAngle, ANGLE_STRICT_90_BOUNDS);
        }
        annotation { "Name" : "Cutout", "Default" : true }
        definition.hasCutout is boolean;

        annotation { "Name" : "Merge scope", "Filter" : EntityType.BODY &amp;&amp; BodyType.SOLID }
        definition.booleanScope is Query;
    }

    {
        // get all the user selected locations
        const locations = evaluateQuery(context, definition.locations);

        // if a solid body intersects the first point in the list, automatically use that in the merge scope
        const targetBody = evaluateQuery(context, qContainsPoint(qBodyType(qEverything(EntityType.BODY), BodyType.SOLID), evVertexPoint(context, { "vertex" : locations[0] })));

        if (size(targetBody) == 0 &amp;&amp; definition.booleanScope != undefined)
            definition.targetBody = definition.booleanScope; // if not, get user to select merge scope
        else
            definition.targetBody = targetBody[0];

        var sketchPlane is Plane = evOwnerSketchPlane(context, { "entity" : locations[0] });
        var topPlane;

        var hookVector = vector(1, 0); // by default pointing across in x

        // if user has defined hook direction, work out the vector
        if (definition.hookDirection != undefined)
        {
            const directionResult = try(evAxis(context, { "axis" : definition.hookDirection }));

            if (directionResult != undefined)
                hookVector = normalize(vector(directionResult.direction[0], directionResult.direction[1]));
        }

        if (definition.hookFlipDirection)
            hookVector = hookVector * -1;

        // get vector perpendicular to hook direction
        var perpHookVector = vector(hookVector[1] * -1, hookVector[0]);

        // define the plane for the top of the boss
        if (definition.style == HookStyle.PLANE &amp;&amp; definition.parallelFace != undefined)
            topPlane = evPlane(context, { "face" : definition.parallelFace });
        else
            topPlane = plane(sketchPlane.origin + definition.height * sketchPlane.normal, sketchPlane.normal);

        var nameId = 1;
        var chamferPoints = [];
        var frontFacePoints = [];
        var backFacePoints = [];

        const sketch1 = newSketchOnPlane(context, id + "sketch1", { "sketchPlane" : topPlane });
        const sketch2 = newSketchOnPlane(context, id + "sketch2", { "sketchPlane" : topPlane });
        const sketch3 = newSketchOnPlane(context, id + "sketch3", { "sketchPlane" : topPlane });

        definition.depth = definition.hookDepth / tan(definition.deflectionAngle) + definition.flatHeight;

        // Build 3 sketches each with a rectangle
        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skRectangle(sketch1, "rectangleHook" ~ nameId, {
                        "firstCorner" : vector(point[0], point[1]) + (definition.hookWidth / 2) * hookVector,
                        "secondCorner" : vector(point[0], point[1]) - (definition.hookWidth / 2) * hookVector - definition.hookDepth * perpHookVector
                    });

            skRectangle(sketch2, "rectangleThickness" ~ nameId, {
                        "firstCorner" : vector(point[0], point[1]) - (definition.hookWidth / 2) * hookVector,
                        "secondCorner" : vector(point[0], point[1]) + (definition.hookWidth / 2) * hookVector + definition.hookThickness * perpHookVector
                    });

            skRectangle(sketch3, "completeRectangle" ~ nameId, {
                        "firstCorner" : vector(point[0], point[1]) - (definition.hookWidth / 2) * hookVector - definition.hookDepth * perpHookVector,
                        "secondCorner" : vector(point[0], point[1]) + (definition.hookWidth / 2) * hookVector + definition.hookThickness * perpHookVector
                    });

            // Keep a list of the centerpoints of the edges where the chamfers may go
            var chamferPoint2d = vector(point[0], point[1]) - definition.hookDepth * perpHookVector;
            if (definition.hasDraft)
            {
                chamferPoint2d = vector(point[0], point[1]) - (definition.hookDepth - definition.depth * tan(definition.draftAngle)) * perpHookVector;
            }
            chamferPoints = append(chamferPoints, toWorld(planeToCSys(topPlane), vector(chamferPoint2d[0], chamferPoint2d[1], definition.depth)));

            var backFacePoint2d = vector(point[0], point[1]) + definition.hookThickness * perpHookVector;
            backFacePoints = append(backFacePoints, toWorld(planeToCSys(topPlane), vector(backFacePoint2d[0], backFacePoint2d[1], 0 * meter)));
            frontFacePoints = append(frontFacePoints, toWorld(planeToCSys(topPlane), vector(point[0], point[1], 0 * meter)));

            nameId += 1;
        }
        skSolve(sketch1);
        skSolve(sketch2);
        skSolve(sketch3);

        extrude(context, id + ("extrude1"), {
                    "entities" : qSketchRegion(id + "sketch2"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "depth" : definition.depth,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.ADD,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        extrude(context, id + ("extrude2"), {
                    "entities" : qSketchRegion(id + "sketch3"),
                    "endBound" : BoundingType.BLIND,
                    "depth" : definition.depth,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : false,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : true,
                    "operationType" : NewBodyOperationType.ADD,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        var chamferEdges = [];

        for (var i = 0; i &lt; size(chamferPoints); i += 1)
        {
            // Find the edges that intersect the points previously collected
            chamferEdges = append(chamferEdges, qContainsPoint(qCreatedBy(id + "extrude2", EntityType.EDGE), chamferPoints[i]));
        }

        try(opChamfer(context, id + "chamfer1", {
                        "entities" : qUnion(chamferEdges),
                        "chamferType" : ChamferType.OFFSET_ANGLE,
                        "width" : definition.depth - definition.flatHeight,
                        "angle" : definition.deflectionAngle,
                        "oppositeDirection" : true
                    }));

        if (definition.hasDraft)
        {
            var backFaces = [];
            var frontFaces = [];

            for (var i = 0; i &lt; size(backFacePoints); i += 1)
            {
                // Find the edges that intersect the points previously collected
                backFaces = append(backFaces, qContainsPoint(qCreatedBy(id + "extrude1", EntityType.FACE), backFacePoints[i]));
                frontFaces = append(frontFaces, qContainsPoint(qCreatedBy(id + "extrude1", EntityType.FACE), frontFacePoints[i]));
            }

            opPlane(context, id + "plane1", {
                        "plane" : topPlane,
                        "size" : 0.1 * meter
                    });

            opDraft(context, id + "draft1", {
                        "neutralPlane" : qCreatedBy(id + "plane1", EntityType.FACE),
                        "pullVec" : topPlane.normal,
                        "draftFaces" : qUnion(frontFaces),
                        "angle" : 0 * degree
                    });

            opDraft(context, id + "draft2", {
                        "neutralPlane" : qCreatedBy(id + "plane1", EntityType.FACE),
                        "pullVec" : topPlane.normal,
                        "draftFaces" : qUnion(backFaces),
                        "angle" : definition.backDraftAngle + definition.draftAngle
                    });
        }

        if (definition.hasCutout)
        {
            extrude(context, id + ("extrude3"), {
                        "entities" : qSketchRegion(id + "sketch1"),
                        "endBound" : BoundingType.THROUGH_ALL,
                        "depth" : definition.depth,
                        "endBoundEntityBody" : definition.targetBody,
                        "oppositeDirection" : true,
                        "hasDraft" : definition.hasDraft,
                        "draftAngle" : definition.draftAngle,
                        "draftPullDirection" : false,
                        "operationType" : NewBodyOperationType.REMOVE,
                        "defaultScope" : false,
                        "booleanScope" : definition.targetBody
                    });
        }

        // Remove sketch entities and plane - no longer required
        var sketches = [qCreatedBy(id + "sketch1"), qCreatedBy(id + "sketch2"), qCreatedBy(id + "sketch3"), qCreatedBy(id + "plane1")];
        opDeleteBodies(context, id + "delete", { "entities" : qUnion(sketches) });

    }, {});

const HOOK_ANGLE =
{
            "min" : -TOLERANCE.zeroAngle * radian,
            "max" : (2 * PI + TOLERANCE.zeroAngle) * radian,
            (degree) : [15, 30, 60]
        } as AngleBoundSpec;

const HOOK_HEIGHT =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.015, 500],
            (centimeter) : 1.5,
            (millimeter) : 15.0,
            (inch) : 0.6
        } as LengthBoundSpec;

const HOOK_WIDTH =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.005, 500],
            (centimeter) : 0.5,
            (millimeter) : 5.0,
            (inch) : 0.2
        } as LengthBoundSpec;

const HOOK_THK =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.002, 500],
            (centimeter) : 0.2,
            (millimeter) : 2.0,
            (inch) : 0.08
        } as LengthBoundSpec;

const HOOK_LIP =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.001, 500],
            (centimeter) : 0.1,
            (millimeter) : 1.0,
            (inch) : 0.04
        } as LengthBoundSpec;

export enum HookStyle
{
    annotation { "Name" : "Blind" }
    BLIND,
    annotation { "Name" : "Up to face" }
    PLANE
}
&lt;/pre&gt;

&lt;p&gt;Fill Pattern FeatureScript 程式碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");
import(path : "onshape/std/transform.fs", version : "336.0");

/**
 * Performs a pattern of faces within a face. The instances are placed in a hexagonal pattern and no instances will be 
 * created that cross the boundary of the face. If a border is set then no instances are created within a border of that size
 * @param definition {{
 *      @field entities A collection of faces that will be patterned
 *      @field target A planar face that contains the 'entities' faces and that will contain the pattern
 *      @field direction Specifies the alignment of the pattern in the face
 *      @field distance The distance between the center of the instances
 *      @field border The width of the "exclusion zone" at the edge of the target face     
 * }}
 */
annotation { "Feature Type Name" : "Fill pattern", "Filter Selector" : "allparts" }
export const fillPattern = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Faces to pattern",
                     "Filter" : EntityType.FACE &amp;&amp; ConstructionObject.NO &amp;&amp; SketchObject.NO }
        definition.entities is Query;
        annotation { "Name" : "Target face", "Filter" : GeometryType.PLANE, "MaxNumberOfPicks" : 1 }
        definition.target is Query;
        annotation { "Name" : "Direction", "Filter" : QueryFilterCompound.ALLOWS_AXIS, "MaxNumberOfPicks" : 1 }
        definition.direction is Query;        
        annotation { "Name" : "Distance" }
        isLength(definition.distance, LENGTH_BOUNDS);
        annotation { "Name" : "Border" }
        isLength(definition.border, NONNEGATIVE_ZERO_DEFAULT_LENGTH_BOUNDS);
    }
    {
        var transforms = [];
        var instanceNames = [];

        var direction = try(evAxis(context, { "axis" : definition.direction })).direction;
        println(direction);
        var normal = try(evPlane(context, {
            "face" : definition.target
        })).normal;

        // For a hexagonal pattern we have two directions, with one being at an angle of 60 degrees from the other.
        // If we pattern in both those directions then we get a hexagonal pattern with equal spacing
        var vertical = cross(normal, direction);
        var angled = (direction * cos(60 * degree)) + (vertical * sin(60 * degree));

        // We want to get the edges of the target face so that we can get the distance from the face boundary
        // However, because the tool faces ought to be "in" the target face we don't want to count those
        // We can use booleans on the queries, which is pretty nice. We can also take the opportunity to ensure
        // that at least some edges are shared
        var allTargetEdges = qEdgeAdjacent(definition.target, EntityType.EDGE);
        var toolEdges = qEdgeAdjacent(definition.entities, EntityType.EDGE);
        var targetEdges = qSubtraction(allTargetEdges, toolEdges);
        var edgesInFace = qIntersection([allTargetEdges, toolEdges]);
        if (size(evaluateQuery(context, edgesInFace)) == 0) {
            throw regenError("The entities must share edges with the target face");
        }

        // To prevent excessive calculation we do a quick exclusion of faces based on bounding boxes
        // It doesn't need to be perfect. Get the box of the target face and of the shared edges
        var faceBox = try(evBox3d(context, {
            "topology" : definition.target
        }));
        var toolBox = try(evBox3d(context, {
            "topology" : edgesInFace
        }));

        // Again, to prevent excessive computation we will estimate the maximum number of instances and
        // fail early if we exceed some limit.
        var diagonal = faceBox.maxCorner - faceBox.minCorner;    
        var maximumIndex = round((norm(diagonal) - (definition.border * 2)) / definition.distance);
        var toolSize = norm(toolBox.maxCorner - toolBox.minCorner);
        var estimatedIndexCount = maximumIndex * maximumIndex;
        if (estimatedIndexCount &gt; 2500)
        {
            throw regenError("Too many instances in the pattern (estimate: " ~ 
                estimatedIndexCount ~ " ). Try a larger spacing.");
        }

        // Now we loop and look to see if the instance should be included
        for (var i = -maximumIndex; i &lt;= maximumIndex; i += 1)
        {
            for (var j = -maximumIndex; j &lt;= maximumIndex; j += 1)
            {
                if (abs(i) &lt; 0.5 &amp;&amp; abs(j) &lt; 0.5)
                {
                    // Zero transform = initial position =&gt; Skip
                    continue;
                }
                var translation = ((direction * i) + (angled * j)) * definition.distance;
                var instanceTransform = transform(translation);
                // Now that we have the transform we transform the tool box and see if it is within the face
                // but not too close to the edges of the face
                // Note: this isn't exact, it uses the center of the face and the size of the face box 
                // rather than transforming the geometry every time.
                var xformed = box3d(toolBox.minCorner + translation, toolBox.maxCorner + translation);
                if (clash(xformed, faceBox))
                {
                    var minDistance = evDistance(context, {
                            "side0" : targetEdges,
                            "side1" : (xformed.minCorner + xformed.maxCorner) * 0.5
                    });
                    // Note: if border is zero this still results in a border that is half the size of the tool,
                    // the border is additional on top of that
                    if (minDistance.distance &gt; (toolSize + definition.border))
                    {
                        transforms = append(transforms, instanceTransform);
                        instanceNames = append(instanceNames, "" ~ i ~ "." ~ j);
                    }
                }                
            }
        }

        // Now we set the data as needed by the applyPattern function before calling it.
        definition.patternType = PatternType.FACE;
        definition.transforms = transforms;
        definition.instanceNames = instanceNames;
        definition.seed = definition.entities;

        var remainingTransform = getRemainderPatternTransform(context, { "references" : definition.entities });
        applyPattern(context, id, definition, remainingTransform);
    }, { });

/**
 * Utility function to do a quick clash of boxes
 */
function clash(box1 is Box3d, box2 is Box3d) returns boolean
{
    for (var index = 0; index &lt; 3; index += 1)
    {
        var min1 = box1.minCorner[index];
        var max1 = box1.maxCorner[index];
        var min2 = box2.minCorner[index];
        var max2 = box2.maxCorner[index];
        // Comparisons to zero are never a good idea because values that are calculated separately are
        // rarely the same to machine precision. FeatureScript provides tolerant equality methods
        // but not tolerant inequalities. No matter, we can fashion one ourselves by checking the
        // inequality and excluding approximate equality
        if ((max1 &lt; min2 &amp;&amp; !tolerantEquals(max1, min2)) || (max2 &lt; min1 &amp;&amp; !tolerantEquals(max2, min1)))
        {
            return false;
        }
    }
    return true;
}
&lt;/pre&gt;

&lt;p&gt;Rib FeatureScript 程式碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

const RIB_THICKEN_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [0.0, 0.005, 500],
            (centimeter) : 0.5,
            (millimeter) : 5.0,
            (inch) : 0.25,
            (foot) : 0.025,
            (yard) : 0.01
        } as LengthBoundSpec;

/**
 * Specifies the direction of the rib extrusion starting from the profile
 * going up to the part.
 *
 * @value NORMAL_TO_SKETCH_PLANE : The direction of the rib extrusion goes normal to the profile sketch plane.
 * @value PARALLEL_TO_SKETCH_PLANE : The direction of the rib extrusion goes parallel to the profile sketch plane.
 */
export enum RibExtrusionDirection
{
    annotation { "Name" : "Normal to sketch plane" }
    NORMAL_TO_SKETCH_PLANE,
    annotation { "Name" : "Parallel to sketch plane" }
    PARALLEL_TO_SKETCH_PLANE
}

function isClosed(context is Context, edge is Query) returns boolean
{
    return size(evaluateQuery(context, qVertexAdjacent(edge, EntityType.VERTEX))) &lt; 2;
}

annotation { "Feature Type Name" : "Rib" }
export const rib = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Sketch profiles", "Filter" : EntityType.EDGE &amp;&amp; SketchObject.YES &amp;&amp; ConstructionObject.NO }
        definition.profiles is Query;

        annotation { "Name" : "Parts", "Filter" : EntityType.BODY }
        definition.parts is Query;

        annotation { "Name" : "Thickness" }
        isLength(definition.thickness, RIB_THICKEN_BOUNDS);

        annotation { "Name" : "Rib extrusion direction" }
        definition.ribExtrusionDirection is RibExtrusionDirection;

        annotation { "Name" : "Opposite direction", "UIHint" : "OPPOSITE_DIRECTION", "Default" : true }
        definition.oppositeDirection is boolean;

        annotation { "Name" : "Extend profiles up to part" }
        definition.extendProfilesUpToPart is boolean;

        annotation { "Name" : "Merge ribs", "Default" : true }
        definition.mergeRibs is boolean;
    }
    {
        const profiles = evaluateQuery(context, definition.profiles);
        const numberOfRibs = size(profiles);
        if (profiles == [])
        {
            throw regenError("Select sketch profiles for the rib contours");
        }

        if (evaluateQuery(context, definition.parts) == [])
        {
            throw regenError("Select parts where the rib will be fitted into");
        }

        // Create a transform for making the feature patternable via feature pattern.
        var remainingTransform = getRemainderPatternTransform(context,
                {"references" : qUnion([definition.profiles, definition.parts])});

        // Before evaluating the profiles to create the ribs, we find out how big the parts are
        // so if any extending is necessary for any rib end, we know how far we need to extend.
        // To ensure the extended profile will always go past the part(s), we use the
        // diagonal of the bounding box of the part(s) and profile(s) as the extend length.
        const partBoundingBox = evBox3d(context, {
                    "topology" : qUnion([definition.parts, definition.profiles])
                });
        const extendLength = norm(partBoundingBox.maxCorner - partBoundingBox.minCorner);

        // Create each rib (one rib per profile) as its own body.

        for (var i = 0; i &lt; numberOfRibs; i += 1)
        {
            const profile = profiles[i];
            const thickenId = id + (i ~ "thickenRib");

            try
            {
                // Keep track of the entities we will extrude as a surface which will later
                // be thickened to create the rib.  The profile and any
                // profile extensions will need to be included in the extrude operation.
                var entitiesToExtrude = [profile];

                // Get the endpoints of the profile and the normal direction at those endpoints
                // so we can determine what needs to be extended and what direction to extend.
                const profileEndTangentLines = evEdgeTangentLines(context, {
                            "edge" : profile,
                            "parameters" : [0, 1],
                            "arcLengthParameterization" : false
                        });

                // There  are 2 reasons we might need to extend the given profiles:
                // 1.  If the profile touches the part(s), make an extension of the profile past the part to ensure
                //     that there are no gaps when we thicken the profile (this can happen if the profile is not normal
                //     to the part where they intersect).
                // 2.  The extend profiles up to part checkbox has been selected.
                const partsContainPoint = function(point is Vector) returns boolean
                    {
                        return evaluateQuery(context, qContainsPoint(definition.parts, remainingTransform * point)) != [];
                    };

                var extendProfiles = makeArray(2);
                var extendedEndPoints = makeArray(2);
                const extendDirections = [-profileEndTangentLines[0].direction, profileEndTangentLines[1].direction];

                // If the profile is closed, then there is nothing to extend.
                const isProfileClosed = isClosed(context, profile);

                for (var end in [0, 1]) // Potentially extend both endpoints of the profile curve
                {
                    extendProfiles[end] = !isProfileClosed &amp;&amp; definition.extendProfilesUpToPart || partsContainPoint(profileEndTangentLines[end].origin);
                    if (extendProfiles[end])
                    {
                        extendedEndPoints[end] = profileEndTangentLines[end].origin + (extendDirections[end] * extendLength);
                        // This is actually a quick way to create a line in 3D
                        opFitSpline(context, id + (i ~ "extendProfile" ~ end), {
                                    "points" : [
                                            profileEndTangentLines[end].origin,
                                            extendedEndPoints[end]
                                        ]
                                });
                        entitiesToExtrude = append(entitiesToExtrude, qCreatedBy(id + (i ~ "extendProfile" ~ end), EntityType.EDGE));
                    }
                }

                // Find the direction to extrude a surface that will later be thickened to produce the rib.
                // First determine the normal or parallel direction, then, if specified,
                // choose the opposite of the normal or parallel direction.
                const profilePlane = evOwnerSketchPlane(context, { "entity" : profile });
                var ribDirection;
                if (definition.ribExtrusionDirection == RibExtrusionDirection.PARALLEL_TO_SKETCH_PLANE)
                {
                    // To get the parallel direction with the sketch plane, find the direction perpendicular
                    // to the sketch plane normal and the line that connects the start and end point of the profile.
                    const profileDirection = normalize(profileEndTangentLines[1].origin - profileEndTangentLines[0].origin);
                    ribDirection = cross(profilePlane.normal, profileDirection);
                }
                else
                {
                    ribDirection = profilePlane.normal;
                }

                if (definition.oppositeDirection)
                {
                    ribDirection = ribDirection * -1;
                }

                // Extrude a surface from the extended profile into the part(s), using the extend length
                // as the extrude depth to make sure the surface goes through the part(s).
                opExtrude(context, id + (i ~ "surfaceExtrude"), {
                            "entities" : qUnion(entitiesToExtrude),
                            "direction" : ribDirection,
                            "endDepth" : extendLength,
                            "endBound" : BoundingType.BLIND
                        });

                // Transform the extruded surface if needed to support feature pattern.
                transformResultIfNecessary(context, id + (i ~ "surfaceExtrude"), remainingTransform);

                // Thicken the surface to make the rib plus some excess material around the part(s).
                const halfThickness = definition.thickness / 2;
                opThicken(context, thickenId, {
                            "entities" : qCreatedBy(id + (i ~ "surfaceExtrude"), EntityType.FACE),
                            "thickness1" : halfThickness,
                            "thickness2" : halfThickness
                        });

                // Split the rib with the part(s) to separate the rib body from the thicken excess.
                var ribPartsQuery = qCreatedBy(thickenId, EntityType.BODY);
                opBoolean(context, id + (i ~ "splitOffRibExcess"), {
                            "tools" : definition.parts,
                            "targets" : ribPartsQuery,
                            "operationType" : BooleanOperationType.SUBTRACTION,
                            "keepTools" : true
                        });

                // Apply the remaining transform to the profile before doing collision testing.
                patternTransform(context, id + (i ~ "tr1"), profile, remainingTransform);
                // Do collision testing to help determine which parts of the thicken are excess.
                var clashes = evCollision(context, {
                        "tools" : ribPartsQuery,
                        "targets" : profile
                    });

                // Since we don't want the profile to actually move
                // move it back to it's original location after checking for collisions.
                patternTransform(context, id + (i ~ "tr2"), profile, inverse(remainingTransform));
                var clashBodies = mapArray(clashes, function(clash)
                {
                    return clash.toolBody;
                });

                // Specify a point at the end of the surface extrude.
                // Any thicken body that intersects with this point is excess.
                const surfaceExtrudeEndPoint = profileEndTangentLines[0].origin + (extendLength * ribDirection);

                // Collect up all the thicken excess and any other entities we've created leading
                // up to the thicken operation, because all of these need to be deleted.
                var entitiesToDelete = [
                    // Remove rib thicken excess sections that don't intersect the original profile.
                    qSubtraction(ribPartsQuery, qUnion(clashBodies)),

                    // Remove rib thicken excess sections that extend all the way to the end of
                    // the surface extrude (which we deliberately had extend well past the part,
                    // i.e. well past where a rib should be created).
                    qContainsPoint(ribPartsQuery, remainingTransform * surfaceExtrudeEndPoint),

                    // Remove the surface extrude, now that the thicken is completed and we don't need it anymore.
                    qCreatedBy(id + (i ~ "surfaceExtrude"), EntityType.BODY)
                ];

                // Delete any profile extensions created now that we don't need them anymore.
                // Also, any thicken section that intersects with the far end of an extension
                // (i.e. not the end that intersects with the profile) is thicken excess and should be deleted.
                for (var end in [0, 1])
                {
                    if (extendProfiles[end])
                    {
                        entitiesToDelete = append(entitiesToDelete, qCreatedBy(id + (i ~ "extendProfile" ~ end), EntityType.BODY));
                        entitiesToDelete = append(entitiesToDelete, qContainsPoint(ribPartsQuery, extendedEndPoints[end]));
                    }
                }

                opDeleteBodies(context, id + (i ~ "deleteRibExcess"), {
                            "entities" : qUnion(entitiesToDelete)
                        });
            }
            catch
            {
                throw regenError('Failed to create a rib from a selected profile.',
                        profile);
            }

            // Fail early if the rib body can't be created.
            if (evaluateQuery(context, qCreatedBy(thickenId, EntityType.BODY)) == [])
            {
                throw regenError('Selected profile did not produce a rib body.  Make sure the rib direction and alignment are correct.',
                        profile);
            }
        }

        // Optionally, merge the new ribs with the original parts.
        if (definition.mergeRibs)
        {
            // The original parts are first in the tools query so that they
            // will maintain their names.
            var toMerge = [definition.parts];
            for (var i = 0; i &lt; numberOfRibs; i += 1)
            {
                toMerge = append(toMerge, qCreatedBy(id, EntityType.BODY));
            }

            try
            {
                opBoolean(context, id + "mergeRibsWithParts", {
                            "tools" : qUnion(toMerge),
                            "operationType" : BooleanOperationType.UNION
                        });
            }
            catch
            {
                throw regenError('Failed to merge ribs into parts.');
            }
        }
    },
        {
            oppositeDirection : true,
            ribExtrusionDirection : RibExtrusionDirection.NORMAL_TO_SKETCH_PLANE,
            extendProfilesUpToPart : false,
            mergeRibs : true
        });

function patternTransform(context, id, query, transform)
{
    if (transform == identityTransform())
        return;
    opTransform(context, id, {
            "bodies" : qOwnerBody(query),
            "transform" : transform
    });
}
&lt;/pre&gt;</summary><category term="CADLab"></category><category term="MCAD"></category><category term="Onshape"></category><category term="FeatureScript"></category></entry><entry><title>Onshape FeatureScript 程式語言</title><link href="http://cadlab.mde.tw/post/onshape-featurescript-cheng-shi-yu-yan.html" rel="alternate"></link><updated>2016-06-14T22:36:38+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-06-14:post/onshape-featurescript-cheng-shi-yu-yan.html</id><summary type="html">&lt;p&gt;在 &lt;a href="https://embedwistia-a.akamaihd.net/deliveries/02d2dfd77d4c465c42fa30e66e3bb53f26467cbc/file.mp4"&gt;FeatureScript 簡介&lt;/a&gt;的影片中, 可以看到 Onshape 打造了一個客製化特徵功能的程式語言與社群分享機制, 任何人利用 FeatureScript 建立的延伸功能, 都能夠透過 Add custom features 指令與其他使用者分享.&lt;/p&gt;


&lt;p&gt;FeatureScript 是 Onshape 發明, 一種可用來定義客製化參數特徵用的程式語言, 具有下列特點:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;各 Document 中用戶所建立的 FeatureScript 程式碼, 位於 Feature Studio (特徵工房) 分頁中.&lt;/li&gt;
&lt;li&gt;FeatureScript 的整合開發環境 (Integrated Development Environment) 內建於 Onshape 中.&lt;/li&gt;
&lt;li&gt;Onshape 原本系統中使用的特徵功能, 其對應的 FeatureScript 程式碼, 已經採&lt;a href="https://cad.onshape.com/documents/5749364ce4b0f60f1b7940fe/w/925a5467b6e725168eb9c993/e/ff3b765aacc32576f893ed23"&gt;開放源&lt;/a&gt; (Open Source) 模式釋出.&lt;/li&gt;
&lt;li&gt;Onshape 同時提供 &lt;a href="https://cad.onshape.com/FsDoc/"&gt;FeatureScript 參考手冊&lt;/a&gt; 與 &lt;a href="https://forum.onshape.com/categories/featurescript"&gt;FeatureScript 論壇&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;登入 Onshape, 建立一個 Document 之後, 就可以透過左下角的 + 號中的 Create Feature Studio, 進入 FeatureScript 的整合開發環境, 開始編寫客製化的特徵程式碼, IDE 則提供下列相關功能:&lt;/p&gt;
&lt;p&gt;Parameter (參數)&lt;/p&gt;
&lt;p&gt;Length, Angle, Count, Query, Enum, Boolean and String&lt;/p&gt;
&lt;p&gt;Query (查詢)&lt;/p&gt;
&lt;p&gt;Everything, Nth element, Entity filter, Created by, Intersection, Subtraction, Symetric difference, Own by body, Own by body filter, Owner body, Entities adjacent to edge, Geometry type filter, Contains point, Intersects plane and Query evaluation&lt;/p&gt;
&lt;p&gt;Evaluation (評量)&lt;/p&gt;
&lt;p&gt;Tangent plane, Tangent line, Vertex point, Length measurement, Area measurement, Volume measurement, Query evaluation&lt;/p&gt;
&lt;p&gt;Sketch, Line segment, Circle, Arc, Ellipse, Rectangle, Line segment chain&lt;/p&gt;
&lt;p&gt;Cuboid, Cylinder, Extrude, Revolute, Fillet, Boolean, Transform, Import&lt;/p&gt;
&lt;p&gt;Import (導入)&lt;/p&gt;
&lt;p&gt;Format feature studio (整理特徵工房編輯格式)&lt;/p&gt;
&lt;p&gt;Commit (提交)&lt;/p&gt;
&lt;p&gt;FeatureScript 程式基本架構如下:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 355;
import(path : "onshape/std/geometry.fs", version : "355.0");
annotation { "Feature Type Name" : "My Feature" }
export const myFeature = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        // Define the parameters of the feature type
    }
    {
        // Define the function's action
    });
&lt;/pre&gt;

&lt;p&gt;上層宣告, 列舉值與指令敘述都可以加上 annotations (註解). FeatureScript 的註解使用格式類似 Python 的 Dictionary, 但是 annotation 的索引值型別必須為字串, 而且索引值為 "Feature Type Name" 的 annotation 為每一個特徵指令的必要註解.&lt;/p&gt;
&lt;p&gt;export 則可視為上述的程式碼中, 使用者所宣告的 myFeature 對應特徵物件會被優先置入 FeatureScript Template 中.&lt;/p&gt;
&lt;p&gt;此外 Onshape 任一頁面送出時, 都帶有以下標頭設置, 除了利用 X-Frame-Options:SAMEORIGIN, 不允許使用者將頁面納入 iframe 或 object 標註中外, 也避免遭受可能的網路攻擊:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
Cache-Control:must-revalidate,no-cache,no-store
Strict-Transport-Security:max-age=31536000; includeSubDomains
X-Content-Type-Options:nosniff
X-Frame-Options:SAMEORIGIN
X-XSS-Protection:1; mode=block
&lt;/pre&gt;

&lt;p&gt;以下則為目前 Onshape 官方釋出的參考應用範例:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494220e4b04aa3f56f82c2/w/888534aeb52c4daa68bbfd05/e/4a55fd2861eaa83fae0221d9"&gt;Point Pattern FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494152e4b05f50e871a72c/w/a4a3f09939bf1f43a8e4f133/e/2b865798923d6f648f7196f9"&gt;Spur Gear FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494187e4b0f60f1b7941c8/w/b98b4de33c1d47713be20e7f/e/c1f8d65fc6196f728620b857"&gt;Wave Spring FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Port feature 程式碼 (建立 SAE J1926 螺孔):&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

export enum PortSize
{
    annotation { "Name" : "5/16-24" }
    fiveSixteen,
    annotation { "Name" : "3/8-24" }
    threeEights,
    annotation { "Name" : "7/16-20" }
    sevenSixteen,
    annotation { "Name" : "1/2-20" }
    half,
    annotation { "Name" : "9/16-18" }
    nineSixteen,
    annotation { "Name" : "3/4-16" }
    threeFour,
    annotation { "Name" : "7/8-14" }
    sevenEights,
    annotation { "Name" : "1 1/16-12" }
    oneSixteen
}

annotation { "Feature Type Name" : "Port Feature" }
export const portFeature = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Port Size" }
        definition.portSize is PortSize;

        annotation { "Name" : "Points", "Filter" : EntityType.VERTEX }
        definition.points is Query;

        annotation { "Name" : "Depth" }
        isLength(definition.depth, DEPTH_BOUNDS);
    }
    {
        var ports;
        var depth = definition.depth;
        //here the vector points for each port are added to an array depending on size chosen
        if (definition.portSize == PortSize.fiveSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .019 * inch, -.031 * inch),
                    vector(-.631, -.031) * inch,
                    vector(-.53, -.132) * inch,
                    vector(-.167, -.132) * inch,
                    vector(-.136, -.163) * inch,
                    vector(-.062, -.179) * inch,
                    vector(-.062, -.336) * inch,
                    vector(0, -.336) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.threeEights)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .038 * inch, -.063 * inch),
                    vector(-.629, -.063) * inch,
                    vector(-.53, -.162) * inch,
                    vector(-.169, -.162) * inch,
                    vector(-.136, -.195) * inch,
                    vector(-.062, -.211) * inch,
                    vector(-.062, -.375) * inch,
                    vector(0, -.375) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.sevenSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .052 * inch, -.086 * inch),
                    vector(-.663, -.086) * inch,
                    vector(-.547, -.202) * inch,
                    vector(-.176, -.202) * inch,
                    vector(-.155, -.224) * inch,
                    vector(-.062, -.243) * inch,
                    vector(-.062, -.414) * inch,
                    vector(0, -.414) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.half)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .07 * inch, -.117 * inch),
                    vector(-.71, -.117) * inch,
                    vector(-.607, -.22) * inch,
                    vector(-.188, -.22) * inch,
                    vector(-.153, -.255) * inch,
                    vector(-.062, -.275) * inch,
                    vector(-.062, -.453) * inch,
                    vector(0, -.453) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.nineSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .089 * inch, -.149 * inch),
                    vector(-.773, -.149) * inch,
                    vector(-.671, -.251) * inch,
                    vector(-.195, -.251) * inch,
                    vector(-.159, -.287) * inch,
                    vector(-.062, -.308) * inch,
                    vector(-.062, -.485) * inch,
                    vector(0, -.485) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.threeFour)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .117 * inch, -.196 * inch),
                    vector(-.928, -.196) * inch,
                    vector(-.782, -.341) * inch,
                    vector(-.237, -.341) * inch,
                    vector(-.194, -.384) * inch,
                    vector(-.094, -.406) * inch,
                    vector(-.094, -.594) * inch,
                    vector(0, -.594) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.sevenEights)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .145 * inch, -.242 * inch),
                    vector(-1.032, -.242) * inch,
                    vector(-.875, -.399) * inch,
                    vector(-.245, -.399) * inch,
                    vector(-.194, -.45) * inch,
                    vector(-.094, -.471) * inch,
                    vector(-.094, -.672) * inch,
                    vector(0, -.672) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.oneSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .183 * inch, -.304 * inch),
                    vector(-1.22, -.304) * inch,
                    vector(-1, -.525) * inch,
                    vector(-.246, -.525) * inch,
                    vector(-.224, -.546) * inch,
                    vector(-.094, -.574) * inch,
                    vector(-.094, -.813) * inch,
                    vector(0, -.813) * inch,
                    vector(0, 0) * inch];
        }
        const checkLength = (ports[3] - ports[2]); 
        if (checkLength[0] &lt; 0) // check the depth entered and throw error if depth causes feature to invert
        {
            throw regenError(ErrorStringEnum.SKETCH_DIMENSION_FAILED, ["depth"]);
        }
        var points = evaluateQuery(context, definition.points);
        var numberOfPoints = size(points);
        var sketchId = id + "sketch";
        var portId = "port1";
        for (var i = 0; i &lt; numberOfPoints; i += 1) //for each point selected create a sketch using port vertices and revolve cut
        {
            sketchId = sketchId + i;
            var point = points[i];
            var sketchPlane = evOwnerSketchPlane(context, { "entity" : point });
            var cSys = planeToCSys(sketchPlane);
            var pointVertex = evVertexPoint(context, { "vertex" : point });
            var sketchPlane2 = plane(pointVertex, cSys.xAxis, cSys.zAxis);
            var sketch = newSketchOnPlane(context, sketchId, { "sketchPlane" : sketchPlane2 });
            skPolyline(sketch, portId, { "points" : ports, "constrained" : false });
            skSolve(sketch);
            var axisQuery = sketchEntityQuery(sketchId, EntityType.EDGE, portId ~ ".line0");
            revolveCut(context, id, sketch, sketchId, axisQuery);
        }
        opDeleteBodies(context, id + "delete_sketch", { "entities" : qCreatedBy(id + "sketch", EntityType.BODY) });
        // delete the sketch
    }, { /* default parameters */ });

function revolveCut(context is Context, id is Id, sketch is Sketch, sketchId is Id, axisQuery is Query)
{
    var sketchQuery = qSketchRegion(sketchId, false);
    //revolve cut
    revolve(context, sketchId + "revolve", {
                "operationType" : NewBodyOperationType.REMOVE,
                "entities" : qUnion([sketchQuery]),
                "axis" : qUnion([axisQuery]),
                "revolveType" : RevolveType.FULL,
                "defaultScope" : true });
}

const DEPTH_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.0381, 500],
            (centimeter) : 3.81,
            (millimeter) : 38.1,
            (inch) : 1.5 // set the default depth to 1.5 inch
        } as LengthBoundSpec;
&lt;/pre&gt;

&lt;p&gt;Screw Boss FeatureScript 原始碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
/*    
    Screw Boss

    This custom feature creates a common fastening feature in plastic part design.

    The Screw Boss is just one version of this type of fastening feature 
    and could be easily extended to include many other types. This was built
    to show that you can create complex, compound features easily.

    Version 1 - April 26, 2016 - Neil Cooke, Onshape Inc.
*/ 

FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

annotation { "Feature Type Name" : "Screw Boss" }
export const ScrewBoss = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Sketch points to place bosses", "Filter" : EntityType.VERTEX &amp;&amp; SketchObject.YES &amp;&amp; ConstructionObject.NO }
        definition.locations is Query;

        annotation { "Name" : "Boss style" }
        definition.style is BossStyle;

        if (definition.style == BossStyle.BLIND)
        {
            annotation { "Name" : "Boss height", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.height, BOSS_HEIGHT);
        }
        else
        {
            annotation { "Name" : "Parallel face or plane", "Filter" : EntityType.FACE, "MaxNumberOfPicks" : 1 }
            definition.parallelFace is Query;
        }

        annotation { "Name" : "Boss diameter", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.diameter, BOSS_DIA);

        annotation { "Name" : "Ribs", "Default" : true, "UIHint" : "DISPLAY_SHORT" }
        definition.hasRibs is boolean;

        if (definition.hasRibs == true)
        {
            annotation { "Name" : "Number of ribs (max 6)", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
            isInteger(definition.ribCount, RIB_COUNT_BOUNDS);

            annotation { "Name" : "Flip rib direction", "UIHint" : "OPPOSITE_DIRECTION" }
            definition.ribFlipDirection is boolean;

            annotation { "Name" : "Edge to define rib direction", "Filter" : EntityType.EDGE, "MaxNumberOfPicks" : 1 }
            definition.ribDirection is Query;

            annotation { "Name" : "Rib diameter at top", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.ribDiameter, RIB_DIA);

            annotation { "Name" : "Rib distance from top", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.ribHeight, RIB_HEIGHT);

            annotation { "Name" : "Rib thickness", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.ribThickness, RIB_THK);

            annotation { "Name" : "Chamfer", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"], "Default" : true }
            definition.hasChamfer is boolean;

            if (definition.hasChamfer == true)
            {
                annotation { "Name" : "Chamfer size", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
                isLength(definition.chamferSize, CHAMFER_SIZE);
            }
        }

        annotation { "Name" : "Hole diameter", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.holeDiam, HOLE_DIA);

        annotation { "Name" : "Wall thickness", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.wallThickness, WALL_THK);

        annotation { "Name" : "Draft", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"], "Default" : true }
        definition.hasDraft is boolean;

        if (definition.hasDraft == true)
        {
            annotation { "Name" : "Draft angle", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
            isAngle(definition.draftAngle, DRAFT_ANGLE);
        }

        annotation { "Name" : "Merge scope", "Filter" : EntityType.BODY &amp;&amp; BodyType.SOLID }
        definition.booleanScope is Query;
    }

    {
        // get all the user selected locations
        const locations = evaluateQuery(context, definition.locations);

        // if a solid body intersects the first point in the list, automatically use that in the merge scope
        const targetBody = evaluateQuery(context, qContainsPoint(qBodyType(qEverything(EntityType.BODY), BodyType.SOLID), evVertexPoint(context, { "vertex" : locations[0] })));

        if (size(targetBody) == 0 &amp;&amp; definition.booleanScope != undefined)
            definition.targetBody = definition.booleanScope; // if not, get user to select merge scope
        else
            definition.targetBody = targetBody[0];

        var sketchPlane is Plane = evOwnerSketchPlane(context, { "entity" : locations[0] });
        var topPlane;
        var ribPlane;

        // define the plane for the top of the boss
        if (definition.style == BossStyle.PLANE &amp;&amp; definition.parallelFace != undefined)
            topPlane = evPlane(context, { "face" : definition.parallelFace });
        else
            topPlane = plane(sketchPlane.origin + definition.height * sketchPlane.normal, sketchPlane.normal);

        var nameId = 1;

        definition.sketch = newSketchOnPlane(context, id + "sketch1", { "sketchPlane" : topPlane });

        // Build first feature - extruded circle
        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skCircle(definition.sketch, "circle" ~ nameId, {
                        "center" : vector(point[0], point[1]),
                        "radius" : definition.diameter / 2
                    });
            nameId += 1;
        }
        skSolve(definition.sketch);

        extrude(context, id + ("extrude1"), {
                    "entities" : qSketchRegion(id + "sketch1"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.ADD,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        // Build second feature - extruded ribs
        if (definition.hasRibs)
        {
            // define top of ribs
            ribPlane = plane(topPlane.origin - definition.ribHeight * topPlane.normal, topPlane.normal);

            var ribVector = vector(0, 1); // by default pointing up in Y

            // if user has defined rib direction, work out the vector
            if (definition.ribDirection != undefined)
            {
                const directionResult = try(evAxis(context, { "axis" : definition.ribDirection }));

                if (directionResult != undefined)
                    ribVector = normalize(vector(directionResult.direction[0], directionResult.direction[1]));
            }

            if (definition.ribFlipDirection)
                ribVector = ribVector * -1;

            definition.sketch = newSketchOnPlane(context, id + "sketch2", { "sketchPlane" : ribPlane });

            const ribPlaneCSys = planeToCSys(ribPlane);
            var chamferPoints = [];

            nameId = 1;

            for (var location in locations)
            {
                var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

                const center = vector(point[0], point[1]);

                // Build a closed "star" shaped sketch to represent the ribs
                for (var j = 0; j &lt; definition.ribCount; j += 1)
                {
                    var angle = (360 / definition.ribCount) * j * degree;

                    // The angle for each rib
                    var angledRibVector = vector(ribVector[0] * cos(angle) - ribVector[1] * sin(angle),
                        ribVector[0] * sin(angle) + ribVector[1] * cos(angle));

                    var perpRibVector = vector(angledRibVector[1] * -1, angledRibVector[0]);

                    var ribOffset = definition.ribThickness / 2 / tan(180 / definition.ribCount * degree);

                    if (definition.ribCount == 1)
                        ribOffset = 0 * meter;

                    var points = [
                        center - (definition.ribThickness / 2) * perpRibVector + (ribOffset) * angledRibVector,
                        center - (definition.ribThickness / 2) * perpRibVector + (definition.ribDiameter / 2) * angledRibVector,
                        center + (definition.ribThickness / 2) * perpRibVector + (definition.ribDiameter / 2) * angledRibVector,
                        center + (definition.ribThickness / 2) * perpRibVector + (ribOffset) * angledRibVector];

                    for (var i = 0; i &lt; size(points); i += 1)
                    {
                        skLineSegment(definition.sketch, "line" ~ nameId,
                                { "start" : points[i],
                                    "end" : points[(i + 1) % size(points)]
                                });
                        nameId += 1;
                    }

                    // Keep a list of the centerpoints of the edges where the chamfers may go
                    var chamferPoint2d = center + (definition.ribDiameter / 2) * angledRibVector;
                    chamferPoints = append(chamferPoints, toWorld(ribPlaneCSys, vector(chamferPoint2d[0], chamferPoint2d[1], 0 * meter)));
                }
                nameId += 1;
            }
            skSolve(definition.sketch);

            extrude(context, id + ("extrude2"), {
                        "entities" : qSketchRegion(id + "sketch2"),
                        "endBound" : BoundingType.UP_TO_BODY,
                        "endBoundEntityBody" : definition.targetBody,
                        "oppositeDirection" : true,
                        "hasDraft" : definition.hasDraft,
                        "draftAngle" : definition.draftAngle,
                        "draftPullDirection" : false,
                        "operationType" : NewBodyOperationType.ADD,
                        "defaultScope" : false,
                        "booleanScope" : definition.targetBody
                    });

            // Build third feature - chamfers
            if (definition.hasChamfer)
            {
                var chamferEdges = [];

                for (var i = 0; i &lt; size(chamferPoints); i += 1)
                {
                    // Find the edges that intersect the points previously collected
                    chamferEdges = append(chamferEdges, qContainsPoint(qCreatedBy(id + "extrude2", EntityType.EDGE), chamferPoints[i]));
                }

                try(opChamfer(context, id + "chamfer1", {
                                "entities" : qUnion(chamferEdges),
                                "chamferType" : ChamferType.EQUAL_OFFSETS,
                                "width" : definition.chamferSize
                            }));
            }
        }

        nameId = 1;

        // Build fourth feature - through hole to outside of part
        var holePlane = plane(topPlane.origin - definition.wallThickness * topPlane.normal, topPlane.normal);

        definition.sketch = newSketchOnPlane(context, id + "sketch3", { "sketchPlane" : holePlane });

        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skCircle(definition.sketch, "circle" ~ nameId, {
                        "center" : vector(point[0], point[1]),
                        "radius" : definition.diameter / 2 - definition.wallThickness
                    });
            nameId += 1;
        }
        skSolve(definition.sketch);

        extrude(context, id + ("extrude3"), {
                    "entities" : qSketchRegion(id + "sketch3"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.REMOVE,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        nameId = 1;

        // Build fifth feature - screw hole
        definition.sketch = newSketchOnPlane(context, id + "sketch4", { "sketchPlane" : topPlane });

        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skCircle(definition.sketch, "circle" ~ nameId, {
                        "center" : vector(point[0], point[1]),
                        "radius" : definition.holeDiam / 2
                    });
            nameId += 1;
        }
        skSolve(definition.sketch);

        extrude(context, id + ("extrude4"), {
                    "entities" : qSketchRegion(id + "sketch4"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.REMOVE,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        // Remove sketch entities - no longer required
        var sketches = [qCreatedBy(id + "sketch1"), qCreatedBy(id + "sketch2"), qCreatedBy(id + "sketch3"), qCreatedBy(id + "sketch4")];
        opDeleteBodies(context, id + "delete", { "entities" : qUnion(sketches) });

    }, {});

const BOSS_HEIGHT =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.02, 500],
            (centimeter) : 2.0,
            (millimeter) : 20.0,
            (inch) : 0.8
        } as LengthBoundSpec;

const BOSS_DIA =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.008, 500],
            (centimeter) : 0.8,
            (millimeter) : 8.0,
            (inch) : 0.3125
        } as LengthBoundSpec;

const RIB_COUNT_BOUNDS =
{
            "min" : 1,
            "max" : 6,
            (unitless) : [1, 4, 6]
        } as IntegerBoundSpec;

const RIB_DIA =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.015, 500],
            (centimeter) : 1.5,
            (millimeter) : 15.0,
            (inch) : 0.6
        } as LengthBoundSpec;

const RIB_HEIGHT =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [0, 0.005, 500],
            (centimeter) : 0.5,
            (millimeter) : 5.0,
            (inch) : 0.2
        } as LengthBoundSpec;

const RIB_THK =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.001, 500],
            (centimeter) : 0.1,
            (millimeter) : 1.0,
            (inch) : 0.04
        } as LengthBoundSpec;

const CHAMFER_SIZE =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.002, 500],
            (centimeter) : 0.2,
            (millimeter) : 2.0,
            (inch) : 0.08
        } as LengthBoundSpec;

const HOLE_DIA =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.003, 500],
            (centimeter) : 0.3,
            (millimeter) : 3.0,
            (inch) : 0.12
        } as LengthBoundSpec;

const WALL_THK =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.0015, 500],
            (centimeter) : 0.15,
            (millimeter) : 1.5,
            (inch) : 0.06
        } as LengthBoundSpec;

const DRAFT_ANGLE =
{
            "min" : -TOLERANCE.zeroAngle * radian,
            "max" : (2 * PI + TOLERANCE.zeroAngle) * radian,
            (degree) : [0, 2, 360],
            (radian) : 0.035
        } as AngleBoundSpec;

export enum BossStyle
{
    annotation { "Name" : "Blind" }
    BLIND,
    annotation { "Name" : "Up to face" }
    PLANE
}
&lt;/pre&gt;</summary><category term="CADLab"></category><category term="MCAD"></category><category term="Onshape"></category><category term="FeatureScript"></category></entry><entry><title>Virtualbox 的應用與網路設定</title><link href="http://cadlab.mde.tw/post/virtualbox-de-ying-yong-yu-wang-lu-she-ding.html" rel="alternate"></link><updated>2016-06-05T12:03:55+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-06-05:post/virtualbox-de-ying-yong-yu-wang-lu-she-ding.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.virtualbox.org/"&gt;Virtualbox&lt;/a&gt; 是一套能在 Windows, Linux, Mac 與 Solaris 操作系統上使用的虛擬器 (Virtualizer).&lt;/p&gt;


&lt;h2&gt;Virtualbox 功能&lt;/h2&gt;
&lt;p&gt;虛擬器的功能有下列幾點:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在任一操作系統開機後, 可以同時啟動多種虛擬的操作系統平台, 並且透過虛擬硬體的配置與設定, 執行各種老舊的操作系統應用程式 , 畢竟老應用程式不死, 只是慢慢凋零!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以檔案的架構保留各種電腦軟硬體的配置, 可提升軟體開發效能外, 並可在軟體推銷過程避開多次煩雜的設定 (當然 Docker based 的虛擬技術, 已經逐漸超越這種整套操作系統虛擬的應用).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程式開發者可以在虛擬機器中廣泛透過虛擬的硬體配置, 大膽進行各項操作與測試, 無需擔心損毀電腦週邊實體.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在開機的一台電腦實體中, 可同時模擬多台電腦的運作, 省下操作可能消耗的電力, 降低實體運作與硬體維護成本.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Virtualbox 的參考手冊: &lt;a href="https://www.virtualbox.org/manual/"&gt;https://www.virtualbox.org/manual/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下將針對 Virtualbox 的網路設定與應用加以說明:&lt;/p&gt;
&lt;p&gt;Virtualbox 的網路設定模式分為 NAT, Bridged, Internal, Host-only, UDP tunnel 與 VDE 等.&lt;/p&gt;
&lt;p&gt;NAT 使用情境為啟動虛擬機器後, 當作一般客戶端電腦使用, 虛擬機的連網是透過 NAT 轉址, 以 Host 電腦的網路 IP 對外抓取資料.&lt;/p&gt;
&lt;p&gt;Bridged 使用情境為啟動虛擬機器後, 當作一般伺服器電腦使用, 在 Host 操作系統中模擬出的虛擬網卡, 可以與 Host 電腦的實體網路卡進行橋接與設定外部 IP 後, 視為網路幹線上的一台伺服器.&lt;/p&gt;
&lt;p&gt;Interal 使用情境主要關注在虛擬機器之間的網路彼此相連, 但卻自外於與 Host 連接的區域或廣域網路, Internal networking 的特性通常用來當作資料庫伺服器, 可以透過 internal 網路, 提供對外連線的全球資訊網伺服器資料, 但是外部電腦無法跨越 internal 網路架構直接連線.&lt;/p&gt;
&lt;p&gt;Host-only 使用情境則將網路服務的範圍界定在 Host 主機範圍內, 在虛擬機器所啟動的各種服務, 可以讓 Host 連線, 但是因為沒有像 Bridged 網路設置, 與 Host 的實體網路卡進行橋接, 因此 Host-only 的網路環境通常讓操作 Host 的程式設計師將 Host-only 的電腦當作跨網路的虛擬伺服器使用.&lt;/p&gt;
&lt;p&gt;UDP tunnel 網路用來串接位於不同 Hosts 的虛擬機器, 而 VDE 則是 Virtual Distributed Ethernet 則是一種虛擬網路基礎架構.&lt;/p&gt;
&lt;p&gt;以機械設計的電腦輔助設計應用而言, Virtualbox 網路中的 NAT 與 Host-only 模式最為常用, 而 NAT 網路的設定非常直覺, 只要在所新增的虛擬機器中的網路設定, 選擇 NAT, 然後開機之後, 就可以直接在虛擬機器中使用轉址的網路服務.&lt;/p&gt;
&lt;h2&gt;Host-only 虛擬網路設定&lt;/h2&gt;
&lt;p&gt;Host-only 的網路設置則稍微複雜, 其中牽涉到 Virtualbox 應用程式的網路偏好設定, 以及虛擬機器本身的網路設定搭配, 才能讓 Host 中的應用程式透過 Host 操作系統中的 Host-only 虛擬網路卡, 與位於同一網段的虛擬機器設置連線.&lt;/p&gt;
&lt;h3&gt;Virtualbox 網路偏好設定&lt;/h3&gt;
&lt;p&gt;Virtualbox 的網路相關設定分為兩個層次, 有關整個 Virtualbox 的設定位於 File-&amp;gt;Preferences-&amp;gt;Network, 而第二個層次為各虛擬機器的個別設定. 若以 File-&amp;gt;Preferences-&amp;gt;Network 中, 有關 Host-only 網路設定的目的, 在讓 Virtualbox 的 Host 本體, 可以透過虛擬的網路卡與 Virtualbox 中的虛擬機器網路卡處於同一個區域網路中.&lt;/p&gt;
&lt;p&gt;換言之, 如 Host-only 這個名稱本身的所謂 Host only, 就是虛擬機器的網路能見度, 僅止於 Host only, 外部電腦無法與這些虛擬機器連線, 甚至若虛擬機器沒有透過 Host 電腦中的代理主機, 虛擬機器中的瀏覽器也無法連線上網.&lt;/p&gt;
&lt;p&gt;至於 File-&amp;gt;Preferences-&amp;gt;Network 中的 Host-only 設定, 總共決定兩件虛擬功能, 其一為位於 Host 中的虛擬網路卡, 要採用的網路協定與網址, 所謂的網路協定就是可以使用 IPV4 或 IPV6 網路協定, 至於虛擬網卡的網址, 就會決定這個所謂的 Host-only 網路, 位於那一個內部網段, 例如, 可以使用 IPV4 協定, 並將虛擬網路卡的網址設為 192.168.56.1, 也就是將 Host-only 的網段設為 192.168.56.0.&lt;/p&gt;
&lt;p&gt;File-&amp;gt;Preferences-&amp;gt;Network 中的 Host-only 第 2 個設定, 就是在這個上述設定的虛擬網段中, 是否要再虛擬出一台 DHCP 伺服器, 例如, 選擇要在這個虛擬 Host-only 網段中啟用虛擬的 DHCP 伺服器, 就可以決定這個虛擬的 DHCP 伺服器的 IP (當然要與第 1 項設定的網段相同, 也就是必須位於 192.168.56.0 網段中), 例如, 將虛擬的 DHCP server IP 設為 192.168.56.100, 並且將 DHCP IP 範圍設為 192.168.56.101-200.&lt;/p&gt;
&lt;p&gt;儘管 Virtualbox 中的 File-&amp;gt;Preferences-&amp;gt;Network 中的 Host-only 第 2 個設定, 可以啟用 DHCP, 但是通常使用 Host-only 虛擬網路模式的目的, 大多要在 Host 中連接虛擬機器中的伺服器, 使用特定的服務內容, 因此一般都停用 Host-only 網路設定中的虛擬 DHCP server 服務, 而採手動設定虛擬機器中的 IP 與 Gateway.&lt;/p&gt;
&lt;h3&gt;虛擬機器的網路設定&lt;/h3&gt;
&lt;p&gt;例如, 可以將其中第一台使用 Host-only 網路模式的虛擬機器網路 IP 設為 192.168.56.101, 並將 Gateway 設為 192.168.56.1 (也就是 Host 中對應虛擬網卡的 IP 位址), 第 2 台則設可為 192.168.56.102, 依此類推採用固定的 IP 位址來界定虛擬機器所提供的不同服務.&lt;/p&gt;
&lt;p&gt;Host-only 虛擬網路相關設定的參考畫面如下:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/virtualbox_host_only_1.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/virtualbox_host_only_2.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/virtualbox_host_only_3.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/virtualbox_host_only_4.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/201606/virtualbox_host_only_5.png" width="800" /&gt;&lt;/p&gt;</summary><category term="CADLab"></category><category term="虛擬機器"></category></entry><entry><title>雲端平台上的電腦輔助機械設計</title><link href="http://cadlab.mde.tw/post/yun-duan-ping-tai-shang-de-dian-nao-fu-zhu-ji-jie-she-ji.html" rel="alternate"></link><updated>2016-05-28T07:05:43+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-28:post/yun-duan-ping-tai-shang-de-dian-nao-fu-zhu-ji-jie-she-ji.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.onshape.com/"&gt;Onshape&lt;/a&gt; 在 &lt;a href="http://wordpress-2015course.rhcloud.com/?p=4514"&gt;2015年12月&lt;/a&gt;正式全面對外公開之後, 已經啟動電腦輔助機械設計的雲端世代, 為了追求高效能的全球協同產品設計流程, 利用跨硬體裝置, 免安裝, 具備設計特徵版次管理, 而且提供類似 &lt;a href="https://cad.onshape.com/FsDoc/"&gt;Featurescript&lt;/a&gt; 客製化功能建構環境 (i.e. Feature Studio) 的全雲端電腦輔助機械設計工具, 將會日漸完備.&lt;/p&gt;


&lt;p&gt;面對 Onshape 的破壞性創新產品挑戰, SolidWorks 也以採用 &lt;a href="http://www.3ds.com/about-3ds/3dexperience-platform/"&gt;3dexperience platform&lt;/a&gt; 核心技術為主體, 推出全新的全雲端產品: &lt;a href="http://xdesign.solidworks.com/"&gt;Xdesign&lt;/a&gt; 回應.&lt;/p&gt;
&lt;p&gt;目前, SolidWorks 單機版約佔全球市場&lt;a href="http://blog.cnccookbook.com/2015/01/20/results-2015-cad-survey/"&gt;超過五分之一&lt;/a&gt;, 未來將與自家的 Xdesign 與 Onshape 免安裝全雲端產品, 競逐全球電腦輔助機械設計軟體市場. &lt;/p&gt;
&lt;p&gt;因此, 2016 年可以說是電腦輔助機械設計的雲端元年, 正好比 2006 年推出的 &lt;a href="https://en.wikipedia.org/wiki/Google_Docs,_Sheets,_and_Slides"&gt;Google Doc&lt;/a&gt;, 晚了十年.&lt;/p&gt;</summary><category term="CADLab"></category><category term="MCAD"></category></entry><entry><title>電腦輔助設計室的電腦開機磁區設置</title><link href="http://cadlab.mde.tw/post/dian-nao-fu-zhu-she-ji-shi-de-dian-nao-kai-ji-ci-qu-she-zhi.html" rel="alternate"></link><updated>2016-05-27T21:00:27+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-27:post/dian-nao-fu-zhu-she-ji-shi-de-dian-nao-kai-ji-ci-qu-she-zhi.html</id><summary type="html">&lt;p&gt;第1磁區: Windows 10 Pro + &lt;a href="https://msdn.microsoft.com/zh-tw/virtualization/hyperv_on_windows/quick_start/walkthrough_install"&gt;Hyper-V&lt;/a&gt; 安裝 Windows 7 Professional&lt;/p&gt;
&lt;p&gt;第2磁區: Windows 10 Pro + 可攜免安裝程式套件&lt;/p&gt;
&lt;p&gt;第3磁區: &lt;a href="http://releases.ubuntu.com/16.04/"&gt;Ubuntu 16.04&lt;/a&gt; Server + ubuntu-desktop&lt;/p&gt;


&lt;p&gt;第1磁區擬舀採 Windows 10 Pro 開機, 並安裝常用的 CAD/CAE/CAM 相關軟體套件的安裝為主, 針對無法在 Windows 10 Pro 執行的套件, 則建議安裝在 Hyper-V 模式下的 Windows 7 Professional 開機磁區中.&lt;/p&gt;
&lt;p&gt;第1磁區的網路設置以純 IPV4 為主, 並將最後一排的 9 台電腦, 以 IPV4/IPV6 雙支援的固定 IP 啟動 Ubuntu + &lt;a href="http://www.squid-cache.org/"&gt;Squid&lt;/a&gt; (選擇第3磁區開機), 讓上課師生自行選擇開機後透過 &lt;a href="https://en.wikipedia.org/wiki/Round-robin_DNS"&gt;Round Robin DNS&lt;/a&gt; 配置域名的代理主機增速上網.&lt;/p&gt;
&lt;p&gt;第2磁區擬採 Windows 10 Pro 開機, 並全數使用無需安裝的程式套件, 以提升套件使用效能, 網路配置則彈性配置純 IPV4 或純 IPV6 位址上網, 當採用純 IPV6 上網時, 必須啟動電腦輔助設計室中的 9 台 IPV4/IPV6 雙支援代理主機 (以 Ubuntu 磁區開機).&lt;/p&gt;</summary><category term="CADLab"></category><category term="Windows 10"></category></entry><entry><title>大學教育政策白皮書讀後心得報告</title><link href="http://cadlab.mde.tw/post/da-xue-jiao-yu-zheng-ce-bai-pi-shu-du-hou-xin-de-bao-gao.html" rel="alternate"></link><updated>2016-05-21T23:52:49+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-21:post/da-xue-jiao-yu-zheng-ce-bai-pi-shu-du-hou-xin-de-bao-gao.html</id><summary type="html">&lt;p&gt;15 年前寫的&lt;a href="http://cad-lab.github.io/cadlab_data/files/90.07_taiwan_univ_white_paperpdf"&gt;大學教育政策白皮書&lt;/a&gt;讀後心得報告&lt;/p&gt;


&lt;p&gt;科技大學的本質在教導學生獲得知識的能力，二十一世紀知識經濟最大的特色，在於必須將知識迅速化為商品，由於市場全球化的影響，未能即時將本身所擁有的知識，快速轉化為商品，並被市場接受的企業，終將難逃被時代淘汰的命運，企業如此，教育界也正面臨同樣的挑戰。&lt;/p&gt;
&lt;p&gt;教育部將大學的競爭力，視為國家競爭力的重要指標，全國各大學面對社會多元化的需求與全民終身學習的發展趨勢，如何在「大學教育政策白皮書」的基本方針下，強化各校的競爭力，建立各校的重點特色，便成為各大學今後所賴以生存的重要關鍵。&lt;/p&gt;
&lt;p&gt;事實上，「大學教育政策白皮書」中所提到的觀點，或許是台灣一般大學與科技大學所共同面臨的問題，但，就基本體制上，仍然要有所區分，方能貫徹彼此的教育目標，為社會的現在與未來，提供充足的人力資源。吾人以為，一般大學的最高目標在追求學術的卓越，而科技大學則必須掌握技術的領先，學術強調的是其具備未來的主導性，卓越的學術指的是高瞻遠矚，是未來有用的技術；而技術的領先是要培養能馬上為企業所用的科技尖兵，是能馬上將知識轉化為商品的創新發明家。也許，隨著科技進化的速度日益增快，學術與技術的區隔，也就變得越來越小，但一般大學與科技大學應有的角色與定位，仍不失為各大學爭取重點特色時，所應強調的重點。&lt;/p&gt;
&lt;p&gt;最後，談到本校在通過改名為科技大學後，如何在「大學教育政策白皮書」的指導方針下，爭取市場定位，並積極發展出屬於自己的特色，吾人以為，必須要先從小處做起，慢慢往大處做；必須要先由內做起，然後再漸漸往外落實。小處在哪裡，必須先用科學化與合理化來管理學校的每一個角落，然後才能談替企業診斷，為財團解憂。必須要先在校內建立起知識經濟的體系，然後才有可能與社會上全民學習的脈動相結合。未來，全球化經濟發展的趨勢或許很難臆測，但本校單類多科的包袱，如何逐步轉化為本校的重點特色，將是一項嚴酷的考驗，成敗的關鍵，就看現在。&lt;/p&gt;</summary><category term="大學教育"></category></entry><entry><title>Onshape 即將釋出 Featurescript 程式語言</title><link href="http://cadlab.mde.tw/post/onshape-ji-jiang-shi-chu-featurescript-cheng-shi-yu-yan.html" rel="alternate"></link><updated>2016-05-18T22:07:03+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-18:post/onshape-ji-jiang-shi-chu-featurescript-cheng-shi-yu-yan.html</id><summary type="html">&lt;p&gt;今天早上參加 Onshape 在台灣所舉行的首次實體論壇，除了持續感受到 Onshape 團隊滿滿的誠意外，最大的收穫就是得知 Featurescript 特徵程式語言，即將開放各界使用。&lt;/p&gt;


&lt;p&gt;所謂的 Featurescript， 根據了解，是一種可以透過 Feature Studio， 讓使用者修改或延伸 Onshape 特徵指令的新程式語言，據悉，目前 Onshape 所指供的特徵指令功能，也是透過 Featurescript 打造。&lt;/p&gt;
&lt;p&gt;並且，未來使用者所打造的各式客製化 Featurescript 程式，可以在 Onshape App store 中免費公開或販售。&lt;/p&gt;</summary><category term="Onshape"></category><category term="Featurescript"></category></entry></feed>