<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>CADLab (虎尾科大MDE)</title><link href="http://cadlab.mde.tw/post/" rel="alternate"></link><link href="http://cadlab.mde.tw/post/feeds/all.atom.xml" rel="self"></link><id>http://cadlab.mde.tw/post/</id><updated>2016-05-30T09:23:54+08:00</updated><entry><title>Onshape FeatureScript 程式語言</title><link href="http://cadlab.mde.tw/post/onshape-featurescript-cheng-shi-yu-yan.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/onshape-featurescript-cheng-shi-yu-yan.html</id><summary type="html">&lt;p&gt;在 &lt;a href="https://embedwistia-a.akamaihd.net/deliveries/02d2dfd77d4c465c42fa30e66e3bb53f26467cbc/file.mp4"&gt;FeatureScript 簡介&lt;/a&gt;的影片中, 可以看到 Onshape 打造了一個客製化特徵功能的程式語言與社群分享機制, 任何人利用 FeatureScript 建立的延伸功能, 都能夠透過 Add custom features 指令與其他使用者分享.&lt;/p&gt;


&lt;p&gt;FeatureScript 是 Onshape 發明, 一種可用來定義客製化參數特徵用的程式語言, 具有下列特點:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;各 Document 中用戶所建立的 FeatureScript 程式碼, 位於 Feature Studio (特徵工房) 分頁中.&lt;/li&gt;
&lt;li&gt;FeatureScript 的整合開發環境 (Integrated Development Environment) 內建於 Onshape 中.&lt;/li&gt;
&lt;li&gt;Onshape 原本系統中使用的特徵功能, 其對應的 FeatureScript 程式碼, 已經採&lt;a href="https://cad.onshape.com/documents/5749364ce4b0f60f1b7940fe/w/925a5467b6e725168eb9c993/e/ff3b765aacc32576f893ed23"&gt;開放源&lt;/a&gt; (Open Source) 模式釋出.&lt;/li&gt;
&lt;li&gt;Onshape 同時提供 &lt;a href="https://cad.onshape.com/FsDoc/"&gt;FeatureScript 參考手冊&lt;/a&gt; 與 &lt;a href="https://forum.onshape.com/categories/featurescript"&gt;FeatureScript 論壇&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;登入 Onshape, 建立一個 Document 之後, 就可以透過左下角的 + 號中的 Create Feature Studio, 進入 FeatureScript 的整合開發環境, 開始編寫客製化的特徵程式碼, IDE 則提供下列相關功能:&lt;/p&gt;
&lt;p&gt;Parameter (參數)&lt;/p&gt;
&lt;p&gt;Length, Angle, Count, Query, Enum, Boolean and String&lt;/p&gt;
&lt;p&gt;Query (查詢)&lt;/p&gt;
&lt;p&gt;Everything, Nth element, Entity filter, Created by, Intersection, Subtraction, Symetric difference, Own by body, Own by body filter, Owner body, Entities adjacent to edge, Geometry type filter, Contains point, Intersects plane and Query evaluation&lt;/p&gt;
&lt;p&gt;Evaluation (評量)&lt;/p&gt;
&lt;p&gt;Tangent plane, Tangent line, Vertex point, Length measurement, Area measurement, Volume measurement, Query evaluation&lt;/p&gt;
&lt;p&gt;Sketch, Line segment, Circle, Arc, Ellipse, Rectangle, Line segment chain&lt;/p&gt;
&lt;p&gt;Cuboid, Cylinder, Extrude, Revolute, Fillet, Boolean, Transform, Import&lt;/p&gt;
&lt;p&gt;Import (導入)&lt;/p&gt;
&lt;p&gt;Format feature studio (整理特徵工房編輯格式)&lt;/p&gt;
&lt;p&gt;Commit (提交)&lt;/p&gt;
&lt;p&gt;FeatureScript 程式基本架構如下:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 355;
import(path : "onshape/std/geometry.fs", version : "355.0");
annotation { "Feature Type Name" : "My Feature" }
export const myFeature = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        // Define the parameters of the feature type
    }
    {
        // Define the function's action
    });
&lt;/pre&gt;

&lt;p&gt;上層宣告, 列舉值與指令敘述都可以加上 annotations (註解). FeatureScript 的註解使用格式類似 Python 的 Dictionary, 但是 annotation 的索引值型別必須為字串, 而且索引值為 "Feature Type Name" 的 annotation 為每一個特徵指令的必要註解.&lt;/p&gt;
&lt;p&gt;export 則可視為上述的程式碼中, 使用者所宣告的 myFeature 對應特徵物件會被優先置入 FeatureScript Template 中.&lt;/p&gt;
&lt;p&gt;此外 Onshape 任一頁面送出時, 都帶有以下標頭設置, 除了利用 X-Frame-Options:SAMEORIGIN, 不允許使用者將頁面納入 iframe 或 object 標註中外, 也避免遭受可能的網路攻擊:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
Cache-Control:must-revalidate,no-cache,no-store
Strict-Transport-Security:max-age=31536000; includeSubDomains
X-Content-Type-Options:nosniff
X-Frame-Options:SAMEORIGIN
X-XSS-Protection:1; mode=block
&lt;/pre&gt;

&lt;p&gt;以下則為目前 Onshape 官方釋出的參考應用範例:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494220e4b04aa3f56f82c2/w/888534aeb52c4daa68bbfd05/e/4a55fd2861eaa83fae0221d9"&gt;Point Pattern FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494152e4b05f50e871a72c/w/a4a3f09939bf1f43a8e4f133/e/2b865798923d6f648f7196f9"&gt;Spur Gear FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494187e4b0f60f1b7941c8/w/b98b4de33c1d47713be20e7f/e/c1f8d65fc6196f728620b857"&gt;Wave Spring FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Port feature 程式碼 (建立 SAE J1926 螺孔):&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

export enum PortSize
{
    annotation { "Name" : "5/16-24" }
    fiveSixteen,
    annotation { "Name" : "3/8-24" }
    threeEights,
    annotation { "Name" : "7/16-20" }
    sevenSixteen,
    annotation { "Name" : "1/2-20" }
    half,
    annotation { "Name" : "9/16-18" }
    nineSixteen,
    annotation { "Name" : "3/4-16" }
    threeFour,
    annotation { "Name" : "7/8-14" }
    sevenEights,
    annotation { "Name" : "1 1/16-12" }
    oneSixteen
}

annotation { "Feature Type Name" : "Port Feature" }
export const portFeature = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Port Size" }
        definition.portSize is PortSize;

        annotation { "Name" : "Points", "Filter" : EntityType.VERTEX }
        definition.points is Query;

        annotation { "Name" : "Depth" }
        isLength(definition.depth, DEPTH_BOUNDS);
    }
    {
        var ports;
        var depth = definition.depth;
        //here the vector points for each port are added to an array depending on size chosen
        if (definition.portSize == PortSize.fiveSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .019 * inch, -.031 * inch),
                    vector(-.631, -.031) * inch,
                    vector(-.53, -.132) * inch,
                    vector(-.167, -.132) * inch,
                    vector(-.136, -.163) * inch,
                    vector(-.062, -.179) * inch,
                    vector(-.062, -.336) * inch,
                    vector(0, -.336) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.threeEights)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .038 * inch, -.063 * inch),
                    vector(-.629, -.063) * inch,
                    vector(-.53, -.162) * inch,
                    vector(-.169, -.162) * inch,
                    vector(-.136, -.195) * inch,
                    vector(-.062, -.211) * inch,
                    vector(-.062, -.375) * inch,
                    vector(0, -.375) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.sevenSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .052 * inch, -.086 * inch),
                    vector(-.663, -.086) * inch,
                    vector(-.547, -.202) * inch,
                    vector(-.176, -.202) * inch,
                    vector(-.155, -.224) * inch,
                    vector(-.062, -.243) * inch,
                    vector(-.062, -.414) * inch,
                    vector(0, -.414) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.half)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .07 * inch, -.117 * inch),
                    vector(-.71, -.117) * inch,
                    vector(-.607, -.22) * inch,
                    vector(-.188, -.22) * inch,
                    vector(-.153, -.255) * inch,
                    vector(-.062, -.275) * inch,
                    vector(-.062, -.453) * inch,
                    vector(0, -.453) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.nineSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .089 * inch, -.149 * inch),
                    vector(-.773, -.149) * inch,
                    vector(-.671, -.251) * inch,
                    vector(-.195, -.251) * inch,
                    vector(-.159, -.287) * inch,
                    vector(-.062, -.308) * inch,
                    vector(-.062, -.485) * inch,
                    vector(0, -.485) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.threeFour)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .117 * inch, -.196 * inch),
                    vector(-.928, -.196) * inch,
                    vector(-.782, -.341) * inch,
                    vector(-.237, -.341) * inch,
                    vector(-.194, -.384) * inch,
                    vector(-.094, -.406) * inch,
                    vector(-.094, -.594) * inch,
                    vector(0, -.594) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.sevenEights)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .145 * inch, -.242 * inch),
                    vector(-1.032, -.242) * inch,
                    vector(-.875, -.399) * inch,
                    vector(-.245, -.399) * inch,
                    vector(-.194, -.45) * inch,
                    vector(-.094, -.471) * inch,
                    vector(-.094, -.672) * inch,
                    vector(0, -.672) * inch,
                    vector(0, 0) * inch];
        }
        if (definition.portSize == PortSize.oneSixteen)
        {
            ports = [vector(0, 0) * inch,
                    vector(-depth, 0 * inch),
                    vector(-depth + .183 * inch, -.304 * inch),
                    vector(-1.22, -.304) * inch,
                    vector(-1, -.525) * inch,
                    vector(-.246, -.525) * inch,
                    vector(-.224, -.546) * inch,
                    vector(-.094, -.574) * inch,
                    vector(-.094, -.813) * inch,
                    vector(0, -.813) * inch,
                    vector(0, 0) * inch];
        }
        const checkLength = (ports[3] - ports[2]); 
        if (checkLength[0] &lt; 0) // check the depth entered and throw error if depth causes feature to invert
        {
            throw regenError(ErrorStringEnum.SKETCH_DIMENSION_FAILED, ["depth"]);
        }
        var points = evaluateQuery(context, definition.points);
        var numberOfPoints = size(points);
        var sketchId = id + "sketch";
        var portId = "port1";
        for (var i = 0; i &lt; numberOfPoints; i += 1) //for each point selected create a sketch using port vertices and revolve cut
        {
            sketchId = sketchId + i;
            var point = points[i];
            var sketchPlane = evOwnerSketchPlane(context, { "entity" : point });
            var cSys = planeToCSys(sketchPlane);
            var pointVertex = evVertexPoint(context, { "vertex" : point });
            var sketchPlane2 = plane(pointVertex, cSys.xAxis, cSys.zAxis);
            var sketch = newSketchOnPlane(context, sketchId, { "sketchPlane" : sketchPlane2 });
            skPolyline(sketch, portId, { "points" : ports, "constrained" : false });
            skSolve(sketch);
            var axisQuery = sketchEntityQuery(sketchId, EntityType.EDGE, portId ~ ".line0");
            revolveCut(context, id, sketch, sketchId, axisQuery);
        }
        opDeleteBodies(context, id + "delete_sketch", { "entities" : qCreatedBy(id + "sketch", EntityType.BODY) });
        // delete the sketch
    }, { /* default parameters */ });

function revolveCut(context is Context, id is Id, sketch is Sketch, sketchId is Id, axisQuery is Query)
{
    var sketchQuery = qSketchRegion(sketchId, false);
    //revolve cut
    revolve(context, sketchId + "revolve", {
                "operationType" : NewBodyOperationType.REMOVE,
                "entities" : qUnion([sketchQuery]),
                "axis" : qUnion([axisQuery]),
                "revolveType" : RevolveType.FULL,
                "defaultScope" : true });
}

const DEPTH_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.0381, 500],
            (centimeter) : 3.81,
            (millimeter) : 38.1,
            (inch) : 1.5 // set the default depth to 1.5 inch
        } as LengthBoundSpec;
&lt;/pre&gt;

&lt;p&gt;Screw Boss FeatureScript 原始碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
/*    
    Screw Boss

    This custom feature creates a common fastening feature in plastic part design.

    The Screw Boss is just one version of this type of fastening feature 
    and could be easily extended to include many other types. This was built
    to show that you can create complex, compound features easily.

    Version 1 - April 26, 2016 - Neil Cooke, Onshape Inc.
*/ 

FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

annotation { "Feature Type Name" : "Screw Boss" }
export const ScrewBoss = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Sketch points to place bosses", "Filter" : EntityType.VERTEX &amp;&amp; SketchObject.YES &amp;&amp; ConstructionObject.NO }
        definition.locations is Query;

        annotation { "Name" : "Boss style" }
        definition.style is BossStyle;

        if (definition.style == BossStyle.BLIND)
        {
            annotation { "Name" : "Boss height", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.height, BOSS_HEIGHT);
        }
        else
        {
            annotation { "Name" : "Parallel face or plane", "Filter" : EntityType.FACE, "MaxNumberOfPicks" : 1 }
            definition.parallelFace is Query;
        }

        annotation { "Name" : "Boss diameter", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.diameter, BOSS_DIA);

        annotation { "Name" : "Ribs", "Default" : true, "UIHint" : "DISPLAY_SHORT" }
        definition.hasRibs is boolean;

        if (definition.hasRibs == true)
        {
            annotation { "Name" : "Number of ribs (max 6)", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
            isInteger(definition.ribCount, RIB_COUNT_BOUNDS);

            annotation { "Name" : "Flip rib direction", "UIHint" : "OPPOSITE_DIRECTION" }
            definition.ribFlipDirection is boolean;

            annotation { "Name" : "Edge to define rib direction", "Filter" : EntityType.EDGE, "MaxNumberOfPicks" : 1 }
            definition.ribDirection is Query;

            annotation { "Name" : "Rib diameter at top", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.ribDiameter, RIB_DIA);

            annotation { "Name" : "Rib distance from top", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.ribHeight, RIB_HEIGHT);

            annotation { "Name" : "Rib thickness", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.ribThickness, RIB_THK);

            annotation { "Name" : "Chamfer", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"], "Default" : true }
            definition.hasChamfer is boolean;

            if (definition.hasChamfer == true)
            {
                annotation { "Name" : "Chamfer size", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
                isLength(definition.chamferSize, CHAMFER_SIZE);
            }
        }

        annotation { "Name" : "Hole diameter", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.holeDiam, HOLE_DIA);

        annotation { "Name" : "Wall thickness", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.wallThickness, WALL_THK);

        annotation { "Name" : "Draft", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"], "Default" : true }
        definition.hasDraft is boolean;

        if (definition.hasDraft == true)
        {
            annotation { "Name" : "Draft angle", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
            isAngle(definition.draftAngle, DRAFT_ANGLE);
        }

        annotation { "Name" : "Merge scope", "Filter" : EntityType.BODY &amp;&amp; BodyType.SOLID }
        definition.booleanScope is Query;
    }

    {
        // get all the user selected locations
        const locations = evaluateQuery(context, definition.locations);

        // if a solid body intersects the first point in the list, automatically use that in the merge scope
        const targetBody = evaluateQuery(context, qContainsPoint(qBodyType(qEverything(EntityType.BODY), BodyType.SOLID), evVertexPoint(context, { "vertex" : locations[0] })));

        if (size(targetBody) == 0 &amp;&amp; definition.booleanScope != undefined)
            definition.targetBody = definition.booleanScope; // if not, get user to select merge scope
        else
            definition.targetBody = targetBody[0];

        var sketchPlane is Plane = evOwnerSketchPlane(context, { "entity" : locations[0] });
        var topPlane;
        var ribPlane;

        // define the plane for the top of the boss
        if (definition.style == BossStyle.PLANE &amp;&amp; definition.parallelFace != undefined)
            topPlane = evPlane(context, { "face" : definition.parallelFace });
        else
            topPlane = plane(sketchPlane.origin + definition.height * sketchPlane.normal, sketchPlane.normal);

        var nameId = 1;

        definition.sketch = newSketchOnPlane(context, id + "sketch1", { "sketchPlane" : topPlane });

        // Build first feature - extruded circle
        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skCircle(definition.sketch, "circle" ~ nameId, {
                        "center" : vector(point[0], point[1]),
                        "radius" : definition.diameter / 2
                    });
            nameId += 1;
        }
        skSolve(definition.sketch);

        extrude(context, id + ("extrude1"), {
                    "entities" : qSketchRegion(id + "sketch1"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.ADD,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        // Build second feature - extruded ribs
        if (definition.hasRibs)
        {
            // define top of ribs
            ribPlane = plane(topPlane.origin - definition.ribHeight * topPlane.normal, topPlane.normal);

            var ribVector = vector(0, 1); // by default pointing up in Y

            // if user has defined rib direction, work out the vector
            if (definition.ribDirection != undefined)
            {
                const directionResult = try(evAxis(context, { "axis" : definition.ribDirection }));

                if (directionResult != undefined)
                    ribVector = normalize(vector(directionResult.direction[0], directionResult.direction[1]));
            }

            if (definition.ribFlipDirection)
                ribVector = ribVector * -1;

            definition.sketch = newSketchOnPlane(context, id + "sketch2", { "sketchPlane" : ribPlane });

            const ribPlaneCSys = planeToCSys(ribPlane);
            var chamferPoints = [];

            nameId = 1;

            for (var location in locations)
            {
                var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

                const center = vector(point[0], point[1]);

                // Build a closed "star" shaped sketch to represent the ribs
                for (var j = 0; j &lt; definition.ribCount; j += 1)
                {
                    var angle = (360 / definition.ribCount) * j * degree;

                    // The angle for each rib
                    var angledRibVector = vector(ribVector[0] * cos(angle) - ribVector[1] * sin(angle),
                        ribVector[0] * sin(angle) + ribVector[1] * cos(angle));

                    var perpRibVector = vector(angledRibVector[1] * -1, angledRibVector[0]);

                    var ribOffset = definition.ribThickness / 2 / tan(180 / definition.ribCount * degree);

                    if (definition.ribCount == 1)
                        ribOffset = 0 * meter;

                    var points = [
                        center - (definition.ribThickness / 2) * perpRibVector + (ribOffset) * angledRibVector,
                        center - (definition.ribThickness / 2) * perpRibVector + (definition.ribDiameter / 2) * angledRibVector,
                        center + (definition.ribThickness / 2) * perpRibVector + (definition.ribDiameter / 2) * angledRibVector,
                        center + (definition.ribThickness / 2) * perpRibVector + (ribOffset) * angledRibVector];

                    for (var i = 0; i &lt; size(points); i += 1)
                    {
                        skLineSegment(definition.sketch, "line" ~ nameId,
                                { "start" : points[i],
                                    "end" : points[(i + 1) % size(points)]
                                });
                        nameId += 1;
                    }

                    // Keep a list of the centerpoints of the edges where the chamfers may go
                    var chamferPoint2d = center + (definition.ribDiameter / 2) * angledRibVector;
                    chamferPoints = append(chamferPoints, toWorld(ribPlaneCSys, vector(chamferPoint2d[0], chamferPoint2d[1], 0 * meter)));
                }
                nameId += 1;
            }
            skSolve(definition.sketch);

            extrude(context, id + ("extrude2"), {
                        "entities" : qSketchRegion(id + "sketch2"),
                        "endBound" : BoundingType.UP_TO_BODY,
                        "endBoundEntityBody" : definition.targetBody,
                        "oppositeDirection" : true,
                        "hasDraft" : definition.hasDraft,
                        "draftAngle" : definition.draftAngle,
                        "draftPullDirection" : false,
                        "operationType" : NewBodyOperationType.ADD,
                        "defaultScope" : false,
                        "booleanScope" : definition.targetBody
                    });

            // Build third feature - chamfers
            if (definition.hasChamfer)
            {
                var chamferEdges = [];

                for (var i = 0; i &lt; size(chamferPoints); i += 1)
                {
                    // Find the edges that intersect the points previously collected
                    chamferEdges = append(chamferEdges, qContainsPoint(qCreatedBy(id + "extrude2", EntityType.EDGE), chamferPoints[i]));
                }

                try(opChamfer(context, id + "chamfer1", {
                                "entities" : qUnion(chamferEdges),
                                "chamferType" : ChamferType.EQUAL_OFFSETS,
                                "width" : definition.chamferSize
                            }));
            }
        }

        nameId = 1;

        // Build fourth feature - through hole to outside of part
        var holePlane = plane(topPlane.origin - definition.wallThickness * topPlane.normal, topPlane.normal);

        definition.sketch = newSketchOnPlane(context, id + "sketch3", { "sketchPlane" : holePlane });

        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skCircle(definition.sketch, "circle" ~ nameId, {
                        "center" : vector(point[0], point[1]),
                        "radius" : definition.diameter / 2 - definition.wallThickness
                    });
            nameId += 1;
        }
        skSolve(definition.sketch);

        extrude(context, id + ("extrude3"), {
                    "entities" : qSketchRegion(id + "sketch3"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.REMOVE,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        nameId = 1;

        // Build fifth feature - screw hole
        definition.sketch = newSketchOnPlane(context, id + "sketch4", { "sketchPlane" : topPlane });

        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skCircle(definition.sketch, "circle" ~ nameId, {
                        "center" : vector(point[0], point[1]),
                        "radius" : definition.holeDiam / 2
                    });
            nameId += 1;
        }
        skSolve(definition.sketch);

        extrude(context, id + ("extrude4"), {
                    "entities" : qSketchRegion(id + "sketch4"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.REMOVE,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        // Remove sketch entities - no longer required
        var sketches = [qCreatedBy(id + "sketch1"), qCreatedBy(id + "sketch2"), qCreatedBy(id + "sketch3"), qCreatedBy(id + "sketch4")];
        opDeleteBodies(context, id + "delete", { "entities" : qUnion(sketches) });

    }, {});

const BOSS_HEIGHT =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.02, 500],
            (centimeter) : 2.0,
            (millimeter) : 20.0,
            (inch) : 0.8
        } as LengthBoundSpec;

const BOSS_DIA =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.008, 500],
            (centimeter) : 0.8,
            (millimeter) : 8.0,
            (inch) : 0.3125
        } as LengthBoundSpec;

const RIB_COUNT_BOUNDS =
{
            "min" : 1,
            "max" : 6,
            (unitless) : [1, 4, 6]
        } as IntegerBoundSpec;

const RIB_DIA =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.015, 500],
            (centimeter) : 1.5,
            (millimeter) : 15.0,
            (inch) : 0.6
        } as LengthBoundSpec;

const RIB_HEIGHT =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [0, 0.005, 500],
            (centimeter) : 0.5,
            (millimeter) : 5.0,
            (inch) : 0.2
        } as LengthBoundSpec;

const RIB_THK =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.001, 500],
            (centimeter) : 0.1,
            (millimeter) : 1.0,
            (inch) : 0.04
        } as LengthBoundSpec;

const CHAMFER_SIZE =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.002, 500],
            (centimeter) : 0.2,
            (millimeter) : 2.0,
            (inch) : 0.08
        } as LengthBoundSpec;

const HOLE_DIA =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.003, 500],
            (centimeter) : 0.3,
            (millimeter) : 3.0,
            (inch) : 0.12
        } as LengthBoundSpec;

const WALL_THK =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.0015, 500],
            (centimeter) : 0.15,
            (millimeter) : 1.5,
            (inch) : 0.06
        } as LengthBoundSpec;

const DRAFT_ANGLE =
{
            "min" : -TOLERANCE.zeroAngle * radian,
            "max" : (2 * PI + TOLERANCE.zeroAngle) * radian,
            (degree) : [0, 2, 360],
            (radian) : 0.035
        } as AngleBoundSpec;

export enum BossStyle
{
    annotation { "Name" : "Blind" }
    BLIND,
    annotation { "Name" : "Up to face" }
    PLANE
}
&lt;/pre&gt;</summary><category term="CADLab"></category><category term="MCAD"></category></entry><entry><title>Onshape FeatureScript 程式語言 (一)</title><link href="http://cadlab.mde.tw/post/onshape-featurescript-cheng-shi-yu-yan-yi.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/onshape-featurescript-cheng-shi-yu-yan-yi.html</id><summary type="html">&lt;p&gt;接續上一篇文章, 整理目前 Onshape 已經釋出的 FeatureScript 相關應用範例.&lt;/p&gt;


&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/574941a2e4b05f50e871a75a/w/1c096ba7cb6b4bb6d74f8ffa/e/8c83ef9b92095a980e185cf8"&gt;Curve Pattern FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494139e4b04aa3f56f8243/w/cad51c78bef702f93d689668/e/0cfa9d7c4606e1f2ae32be16"&gt;Helix in Fill FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494120e4b04aa3f56f8206/w/d17e3ff3f757fabdb9084368/e/ab4048d5790d64d16e68e02d"&gt;3D Spline Fill FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494101e4b04aa3f56f81ed/w/b2ffdc215aff14ea3817b535/e/1626934c31793c1d4d18eb6f"&gt;Brick FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/57494096e4b05f50e871a70e/w/165ebc7b4103e5b6c91e3f5b/e/bfd58761a0e39c157f11bd42"&gt;Measure Distance FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/5749420ae4b04aa3f56f8288/w/ed9f79b9809ffe7610f9c537/e/aa01cfec5e04037e7ca611b7"&gt;Lighten FeatureScript 程式 Document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Snap Hook FeatureScript 程式原始碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
/*    
    Snap Hook

    This custom feature creates a common fastening feature in plastic part design.

    The Snap Hook is just one version of this type of fastening feature 
    and could be easily extended to include many other types. This was built
    to show that you can create complex, compound features easily.

    Version 1 - April 26, 2016 - Neil Cooke, Onshape Inc.
*/ 

FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

annotation { "Feature Type Name" : "Snap Hook" }
export const SnapHook = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Sketch point locations", "Filter" : EntityType.VERTEX &amp;&amp; SketchObject.YES &amp;&amp; ConstructionObject.NO }
        definition.locations is Query;

        annotation { "Name" : "Height type" }
        definition.style is HookStyle;

        if (definition.style == HookStyle.BLIND)
        {
            annotation { "Name" : "Height", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isLength(definition.height, HOOK_HEIGHT);
        }
        else
        {
            annotation { "Name" : "Parallel face or plane", "Filter" : EntityType.FACE, "MaxNumberOfPicks" : 1 }
            definition.parallelFace is Query;
        }

        annotation { "Name" : "Width", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.hookWidth, HOOK_WIDTH);

        annotation { "Name" : "Flip direction", "UIHint" : "OPPOSITE_DIRECTION" }
        definition.hookFlipDirection is boolean;

        annotation { "Name" : "Edge to define direction", "Filter" : EntityType.EDGE, "MaxNumberOfPicks" : 1 }
        definition.hookDirection is Query;

        annotation { "Name" : "Thickness", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.hookThickness, HOOK_THK);

        annotation { "Name" : "Undercut depth", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.hookDepth, HOOK_THK);

        annotation { "Name" : "Lip height", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isLength(definition.flatHeight, HOOK_LIP);

        annotation { "Name" : "Insertion angle", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
        isAngle(definition.deflectionAngle, HOOK_ANGLE);

        annotation { "Name" : "Draft", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"], "Default" : true }
        definition.hasDraft is boolean;

        if (definition.hasDraft == true)
        {
            annotation { "Name" : "Draft angle", "UIHint" : ["DISPLAY_SHORT", "REMEMBER_PREVIOUS_VALUE"] }
            isAngle(definition.draftAngle, ANGLE_STRICT_90_BOUNDS);

            annotation { "Name" : "Back face draft angle", "UIHint" : "REMEMBER_PREVIOUS_VALUE" }
            isAngle(definition.backDraftAngle, ANGLE_STRICT_90_BOUNDS);
        }
        annotation { "Name" : "Cutout", "Default" : true }
        definition.hasCutout is boolean;

        annotation { "Name" : "Merge scope", "Filter" : EntityType.BODY &amp;&amp; BodyType.SOLID }
        definition.booleanScope is Query;
    }

    {
        // get all the user selected locations
        const locations = evaluateQuery(context, definition.locations);

        // if a solid body intersects the first point in the list, automatically use that in the merge scope
        const targetBody = evaluateQuery(context, qContainsPoint(qBodyType(qEverything(EntityType.BODY), BodyType.SOLID), evVertexPoint(context, { "vertex" : locations[0] })));

        if (size(targetBody) == 0 &amp;&amp; definition.booleanScope != undefined)
            definition.targetBody = definition.booleanScope; // if not, get user to select merge scope
        else
            definition.targetBody = targetBody[0];

        var sketchPlane is Plane = evOwnerSketchPlane(context, { "entity" : locations[0] });
        var topPlane;

        var hookVector = vector(1, 0); // by default pointing across in x

        // if user has defined hook direction, work out the vector
        if (definition.hookDirection != undefined)
        {
            const directionResult = try(evAxis(context, { "axis" : definition.hookDirection }));

            if (directionResult != undefined)
                hookVector = normalize(vector(directionResult.direction[0], directionResult.direction[1]));
        }

        if (definition.hookFlipDirection)
            hookVector = hookVector * -1;

        // get vector perpendicular to hook direction
        var perpHookVector = vector(hookVector[1] * -1, hookVector[0]);

        // define the plane for the top of the boss
        if (definition.style == HookStyle.PLANE &amp;&amp; definition.parallelFace != undefined)
            topPlane = evPlane(context, { "face" : definition.parallelFace });
        else
            topPlane = plane(sketchPlane.origin + definition.height * sketchPlane.normal, sketchPlane.normal);

        var nameId = 1;
        var chamferPoints = [];
        var frontFacePoints = [];
        var backFacePoints = [];

        const sketch1 = newSketchOnPlane(context, id + "sketch1", { "sketchPlane" : topPlane });
        const sketch2 = newSketchOnPlane(context, id + "sketch2", { "sketchPlane" : topPlane });
        const sketch3 = newSketchOnPlane(context, id + "sketch3", { "sketchPlane" : topPlane });

        definition.depth = definition.hookDepth / tan(definition.deflectionAngle) + definition.flatHeight;

        // Build 3 sketches each with a rectangle
        for (var location in locations)
        {
            var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { "vertex" : location }));

            skRectangle(sketch1, "rectangleHook" ~ nameId, {
                        "firstCorner" : vector(point[0], point[1]) + (definition.hookWidth / 2) * hookVector,
                        "secondCorner" : vector(point[0], point[1]) - (definition.hookWidth / 2) * hookVector - definition.hookDepth * perpHookVector
                    });

            skRectangle(sketch2, "rectangleThickness" ~ nameId, {
                        "firstCorner" : vector(point[0], point[1]) - (definition.hookWidth / 2) * hookVector,
                        "secondCorner" : vector(point[0], point[1]) + (definition.hookWidth / 2) * hookVector + definition.hookThickness * perpHookVector
                    });

            skRectangle(sketch3, "completeRectangle" ~ nameId, {
                        "firstCorner" : vector(point[0], point[1]) - (definition.hookWidth / 2) * hookVector - definition.hookDepth * perpHookVector,
                        "secondCorner" : vector(point[0], point[1]) + (definition.hookWidth / 2) * hookVector + definition.hookThickness * perpHookVector
                    });

            // Keep a list of the centerpoints of the edges where the chamfers may go
            var chamferPoint2d = vector(point[0], point[1]) - definition.hookDepth * perpHookVector;
            if (definition.hasDraft)
            {
                chamferPoint2d = vector(point[0], point[1]) - (definition.hookDepth - definition.depth * tan(definition.draftAngle)) * perpHookVector;
            }
            chamferPoints = append(chamferPoints, toWorld(planeToCSys(topPlane), vector(chamferPoint2d[0], chamferPoint2d[1], definition.depth)));

            var backFacePoint2d = vector(point[0], point[1]) + definition.hookThickness * perpHookVector;
            backFacePoints = append(backFacePoints, toWorld(planeToCSys(topPlane), vector(backFacePoint2d[0], backFacePoint2d[1], 0 * meter)));
            frontFacePoints = append(frontFacePoints, toWorld(planeToCSys(topPlane), vector(point[0], point[1], 0 * meter)));

            nameId += 1;
        }
        skSolve(sketch1);
        skSolve(sketch2);
        skSolve(sketch3);

        extrude(context, id + ("extrude1"), {
                    "entities" : qSketchRegion(id + "sketch2"),
                    "endBound" : BoundingType.UP_TO_BODY,
                    "depth" : definition.depth,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : true,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : false,
                    "operationType" : NewBodyOperationType.ADD,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        extrude(context, id + ("extrude2"), {
                    "entities" : qSketchRegion(id + "sketch3"),
                    "endBound" : BoundingType.BLIND,
                    "depth" : definition.depth,
                    "endBoundEntityBody" : definition.targetBody,
                    "oppositeDirection" : false,
                    "hasDraft" : definition.hasDraft,
                    "draftAngle" : definition.draftAngle,
                    "draftPullDirection" : true,
                    "operationType" : NewBodyOperationType.ADD,
                    "defaultScope" : false,
                    "booleanScope" : definition.targetBody
                });

        var chamferEdges = [];

        for (var i = 0; i &lt; size(chamferPoints); i += 1)
        {
            // Find the edges that intersect the points previously collected
            chamferEdges = append(chamferEdges, qContainsPoint(qCreatedBy(id + "extrude2", EntityType.EDGE), chamferPoints[i]));
        }

        try(opChamfer(context, id + "chamfer1", {
                        "entities" : qUnion(chamferEdges),
                        "chamferType" : ChamferType.OFFSET_ANGLE,
                        "width" : definition.depth - definition.flatHeight,
                        "angle" : definition.deflectionAngle,
                        "oppositeDirection" : true
                    }));

        if (definition.hasDraft)
        {
            var backFaces = [];
            var frontFaces = [];

            for (var i = 0; i &lt; size(backFacePoints); i += 1)
            {
                // Find the edges that intersect the points previously collected
                backFaces = append(backFaces, qContainsPoint(qCreatedBy(id + "extrude1", EntityType.FACE), backFacePoints[i]));
                frontFaces = append(frontFaces, qContainsPoint(qCreatedBy(id + "extrude1", EntityType.FACE), frontFacePoints[i]));
            }

            opPlane(context, id + "plane1", {
                        "plane" : topPlane,
                        "size" : 0.1 * meter
                    });

            opDraft(context, id + "draft1", {
                        "neutralPlane" : qCreatedBy(id + "plane1", EntityType.FACE),
                        "pullVec" : topPlane.normal,
                        "draftFaces" : qUnion(frontFaces),
                        "angle" : 0 * degree
                    });

            opDraft(context, id + "draft2", {
                        "neutralPlane" : qCreatedBy(id + "plane1", EntityType.FACE),
                        "pullVec" : topPlane.normal,
                        "draftFaces" : qUnion(backFaces),
                        "angle" : definition.backDraftAngle + definition.draftAngle
                    });
        }

        if (definition.hasCutout)
        {
            extrude(context, id + ("extrude3"), {
                        "entities" : qSketchRegion(id + "sketch1"),
                        "endBound" : BoundingType.THROUGH_ALL,
                        "depth" : definition.depth,
                        "endBoundEntityBody" : definition.targetBody,
                        "oppositeDirection" : true,
                        "hasDraft" : definition.hasDraft,
                        "draftAngle" : definition.draftAngle,
                        "draftPullDirection" : false,
                        "operationType" : NewBodyOperationType.REMOVE,
                        "defaultScope" : false,
                        "booleanScope" : definition.targetBody
                    });
        }

        // Remove sketch entities and plane - no longer required
        var sketches = [qCreatedBy(id + "sketch1"), qCreatedBy(id + "sketch2"), qCreatedBy(id + "sketch3"), qCreatedBy(id + "plane1")];
        opDeleteBodies(context, id + "delete", { "entities" : qUnion(sketches) });

    }, {});

const HOOK_ANGLE =
{
            "min" : -TOLERANCE.zeroAngle * radian,
            "max" : (2 * PI + TOLERANCE.zeroAngle) * radian,
            (degree) : [15, 30, 60]
        } as AngleBoundSpec;

const HOOK_HEIGHT =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.015, 500],
            (centimeter) : 1.5,
            (millimeter) : 15.0,
            (inch) : 0.6
        } as LengthBoundSpec;

const HOOK_WIDTH =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.005, 500],
            (centimeter) : 0.5,
            (millimeter) : 5.0,
            (inch) : 0.2
        } as LengthBoundSpec;

const HOOK_THK =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.002, 500],
            (centimeter) : 0.2,
            (millimeter) : 2.0,
            (inch) : 0.08
        } as LengthBoundSpec;

const HOOK_LIP =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [1e-5, 0.001, 500],
            (centimeter) : 0.1,
            (millimeter) : 1.0,
            (inch) : 0.04
        } as LengthBoundSpec;

export enum HookStyle
{
    annotation { "Name" : "Blind" }
    BLIND,
    annotation { "Name" : "Up to face" }
    PLANE
}
&lt;/pre&gt;

&lt;p&gt;Fill Pattern FeatureScript 程式碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");
import(path : "onshape/std/transform.fs", version : "336.0");

/**
 * Performs a pattern of faces within a face. The instances are placed in a hexagonal pattern and no instances will be 
 * created that cross the boundary of the face. If a border is set then no instances are created within a border of that size
 * @param definition {{
 *      @field entities A collection of faces that will be patterned
 *      @field target A planar face that contains the 'entities' faces and that will contain the pattern
 *      @field direction Specifies the alignment of the pattern in the face
 *      @field distance The distance between the center of the instances
 *      @field border The width of the "exclusion zone" at the edge of the target face     
 * }}
 */
annotation { "Feature Type Name" : "Fill pattern", "Filter Selector" : "allparts" }
export const fillPattern = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Faces to pattern",
                     "Filter" : EntityType.FACE &amp;&amp; ConstructionObject.NO &amp;&amp; SketchObject.NO }
        definition.entities is Query;
        annotation { "Name" : "Target face", "Filter" : GeometryType.PLANE, "MaxNumberOfPicks" : 1 }
        definition.target is Query;
        annotation { "Name" : "Direction", "Filter" : QueryFilterCompound.ALLOWS_AXIS, "MaxNumberOfPicks" : 1 }
        definition.direction is Query;        
        annotation { "Name" : "Distance" }
        isLength(definition.distance, LENGTH_BOUNDS);
        annotation { "Name" : "Border" }
        isLength(definition.border, NONNEGATIVE_ZERO_DEFAULT_LENGTH_BOUNDS);
    }
    {
        var transforms = [];
        var instanceNames = [];

        var direction = try(evAxis(context, { "axis" : definition.direction })).direction;
        println(direction);
        var normal = try(evPlane(context, {
            "face" : definition.target
        })).normal;

        // For a hexagonal pattern we have two directions, with one being at an angle of 60 degrees from the other.
        // If we pattern in both those directions then we get a hexagonal pattern with equal spacing
        var vertical = cross(normal, direction);
        var angled = (direction * cos(60 * degree)) + (vertical * sin(60 * degree));

        // We want to get the edges of the target face so that we can get the distance from the face boundary
        // However, because the tool faces ought to be "in" the target face we don't want to count those
        // We can use booleans on the queries, which is pretty nice. We can also take the opportunity to ensure
        // that at least some edges are shared
        var allTargetEdges = qEdgeAdjacent(definition.target, EntityType.EDGE);
        var toolEdges = qEdgeAdjacent(definition.entities, EntityType.EDGE);
        var targetEdges = qSubtraction(allTargetEdges, toolEdges);
        var edgesInFace = qIntersection([allTargetEdges, toolEdges]);
        if (size(evaluateQuery(context, edgesInFace)) == 0) {
            throw regenError("The entities must share edges with the target face");
        }

        // To prevent excessive calculation we do a quick exclusion of faces based on bounding boxes
        // It doesn't need to be perfect. Get the box of the target face and of the shared edges
        var faceBox = try(evBox3d(context, {
            "topology" : definition.target
        }));
        var toolBox = try(evBox3d(context, {
            "topology" : edgesInFace
        }));

        // Again, to prevent excessive computation we will estimate the maximum number of instances and
        // fail early if we exceed some limit.
        var diagonal = faceBox.maxCorner - faceBox.minCorner;    
        var maximumIndex = round((norm(diagonal) - (definition.border * 2)) / definition.distance);
        var toolSize = norm(toolBox.maxCorner - toolBox.minCorner);
        var estimatedIndexCount = maximumIndex * maximumIndex;
        if (estimatedIndexCount &gt; 2500)
        {
            throw regenError("Too many instances in the pattern (estimate: " ~ 
                estimatedIndexCount ~ " ). Try a larger spacing.");
        }

        // Now we loop and look to see if the instance should be included
        for (var i = -maximumIndex; i &lt;= maximumIndex; i += 1)
        {
            for (var j = -maximumIndex; j &lt;= maximumIndex; j += 1)
            {
                if (abs(i) &lt; 0.5 &amp;&amp; abs(j) &lt; 0.5)
                {
                    // Zero transform = initial position =&gt; Skip
                    continue;
                }
                var translation = ((direction * i) + (angled * j)) * definition.distance;
                var instanceTransform = transform(translation);
                // Now that we have the transform we transform the tool box and see if it is within the face
                // but not too close to the edges of the face
                // Note: this isn't exact, it uses the center of the face and the size of the face box 
                // rather than transforming the geometry every time.
                var xformed = box3d(toolBox.minCorner + translation, toolBox.maxCorner + translation);
                if (clash(xformed, faceBox))
                {
                    var minDistance = evDistance(context, {
                            "side0" : targetEdges,
                            "side1" : (xformed.minCorner + xformed.maxCorner) * 0.5
                    });
                    // Note: if border is zero this still results in a border that is half the size of the tool,
                    // the border is additional on top of that
                    if (minDistance.distance &gt; (toolSize + definition.border))
                    {
                        transforms = append(transforms, instanceTransform);
                        instanceNames = append(instanceNames, "" ~ i ~ "." ~ j);
                    }
                }                
            }
        }

        // Now we set the data as needed by the applyPattern function before calling it.
        definition.patternType = PatternType.FACE;
        definition.transforms = transforms;
        definition.instanceNames = instanceNames;
        definition.seed = definition.entities;

        var remainingTransform = getRemainderPatternTransform(context, { "references" : definition.entities });
        applyPattern(context, id, definition, remainingTransform);
    }, { });

/**
 * Utility function to do a quick clash of boxes
 */
function clash(box1 is Box3d, box2 is Box3d) returns boolean
{
    for (var index = 0; index &lt; 3; index += 1)
    {
        var min1 = box1.minCorner[index];
        var max1 = box1.maxCorner[index];
        var min2 = box2.minCorner[index];
        var max2 = box2.maxCorner[index];
        // Comparisons to zero are never a good idea because values that are calculated separately are
        // rarely the same to machine precision. FeatureScript provides tolerant equality methods
        // but not tolerant inequalities. No matter, we can fashion one ourselves by checking the
        // inequality and excluding approximate equality
        if ((max1 &lt; min2 &amp;&amp; !tolerantEquals(max1, min2)) || (max2 &lt; min1 &amp;&amp; !tolerantEquals(max2, min1)))
        {
            return false;
        }
    }
    return true;
}
&lt;/pre&gt;

&lt;p&gt;Rib FeatureScript 程式碼:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
FeatureScript 336;
import(path : "onshape/std/geometry.fs", version : "336.0");

const RIB_THICKEN_BOUNDS =
{
            "min" : -TOLERANCE.zeroLength * meter,
            "max" : 500 * meter,
            (meter) : [0.0, 0.005, 500],
            (centimeter) : 0.5,
            (millimeter) : 5.0,
            (inch) : 0.25,
            (foot) : 0.025,
            (yard) : 0.01
        } as LengthBoundSpec;

/**
 * Specifies the direction of the rib extrusion starting from the profile
 * going up to the part.
 *
 * @value NORMAL_TO_SKETCH_PLANE : The direction of the rib extrusion goes normal to the profile sketch plane.
 * @value PARALLEL_TO_SKETCH_PLANE : The direction of the rib extrusion goes parallel to the profile sketch plane.
 */
export enum RibExtrusionDirection
{
    annotation { "Name" : "Normal to sketch plane" }
    NORMAL_TO_SKETCH_PLANE,
    annotation { "Name" : "Parallel to sketch plane" }
    PARALLEL_TO_SKETCH_PLANE
}

function isClosed(context is Context, edge is Query) returns boolean
{
    return size(evaluateQuery(context, qVertexAdjacent(edge, EntityType.VERTEX))) &lt; 2;
}

annotation { "Feature Type Name" : "Rib" }
export const rib = defineFeature(function(context is Context, id is Id, definition is map)
    precondition
    {
        annotation { "Name" : "Sketch profiles", "Filter" : EntityType.EDGE &amp;&amp; SketchObject.YES &amp;&amp; ConstructionObject.NO }
        definition.profiles is Query;

        annotation { "Name" : "Parts", "Filter" : EntityType.BODY }
        definition.parts is Query;

        annotation { "Name" : "Thickness" }
        isLength(definition.thickness, RIB_THICKEN_BOUNDS);

        annotation { "Name" : "Rib extrusion direction" }
        definition.ribExtrusionDirection is RibExtrusionDirection;

        annotation { "Name" : "Opposite direction", "UIHint" : "OPPOSITE_DIRECTION", "Default" : true }
        definition.oppositeDirection is boolean;

        annotation { "Name" : "Extend profiles up to part" }
        definition.extendProfilesUpToPart is boolean;

        annotation { "Name" : "Merge ribs", "Default" : true }
        definition.mergeRibs is boolean;
    }
    {
        const profiles = evaluateQuery(context, definition.profiles);
        const numberOfRibs = size(profiles);
        if (profiles == [])
        {
            throw regenError("Select sketch profiles for the rib contours");
        }

        if (evaluateQuery(context, definition.parts) == [])
        {
            throw regenError("Select parts where the rib will be fitted into");
        }

        // Create a transform for making the feature patternable via feature pattern.
        var remainingTransform = getRemainderPatternTransform(context,
                {"references" : qUnion([definition.profiles, definition.parts])});

        // Before evaluating the profiles to create the ribs, we find out how big the parts are
        // so if any extending is necessary for any rib end, we know how far we need to extend.
        // To ensure the extended profile will always go past the part(s), we use the
        // diagonal of the bounding box of the part(s) and profile(s) as the extend length.
        const partBoundingBox = evBox3d(context, {
                    "topology" : qUnion([definition.parts, definition.profiles])
                });
        const extendLength = norm(partBoundingBox.maxCorner - partBoundingBox.minCorner);

        // Create each rib (one rib per profile) as its own body.

        for (var i = 0; i &lt; numberOfRibs; i += 1)
        {
            const profile = profiles[i];
            const thickenId = id + (i ~ "thickenRib");

            try
            {
                // Keep track of the entities we will extrude as a surface which will later
                // be thickened to create the rib.  The profile and any
                // profile extensions will need to be included in the extrude operation.
                var entitiesToExtrude = [profile];

                // Get the endpoints of the profile and the normal direction at those endpoints
                // so we can determine what needs to be extended and what direction to extend.
                const profileEndTangentLines = evEdgeTangentLines(context, {
                            "edge" : profile,
                            "parameters" : [0, 1],
                            "arcLengthParameterization" : false
                        });

                // There  are 2 reasons we might need to extend the given profiles:
                // 1.  If the profile touches the part(s), make an extension of the profile past the part to ensure
                //     that there are no gaps when we thicken the profile (this can happen if the profile is not normal
                //     to the part where they intersect).
                // 2.  The extend profiles up to part checkbox has been selected.
                const partsContainPoint = function(point is Vector) returns boolean
                    {
                        return evaluateQuery(context, qContainsPoint(definition.parts, remainingTransform * point)) != [];
                    };

                var extendProfiles = makeArray(2);
                var extendedEndPoints = makeArray(2);
                const extendDirections = [-profileEndTangentLines[0].direction, profileEndTangentLines[1].direction];

                // If the profile is closed, then there is nothing to extend.
                const isProfileClosed = isClosed(context, profile);

                for (var end in [0, 1]) // Potentially extend both endpoints of the profile curve
                {
                    extendProfiles[end] = !isProfileClosed &amp;&amp; definition.extendProfilesUpToPart || partsContainPoint(profileEndTangentLines[end].origin);
                    if (extendProfiles[end])
                    {
                        extendedEndPoints[end] = profileEndTangentLines[end].origin + (extendDirections[end] * extendLength);
                        // This is actually a quick way to create a line in 3D
                        opFitSpline(context, id + (i ~ "extendProfile" ~ end), {
                                    "points" : [
                                            profileEndTangentLines[end].origin,
                                            extendedEndPoints[end]
                                        ]
                                });
                        entitiesToExtrude = append(entitiesToExtrude, qCreatedBy(id + (i ~ "extendProfile" ~ end), EntityType.EDGE));
                    }
                }

                // Find the direction to extrude a surface that will later be thickened to produce the rib.
                // First determine the normal or parallel direction, then, if specified,
                // choose the opposite of the normal or parallel direction.
                const profilePlane = evOwnerSketchPlane(context, { "entity" : profile });
                var ribDirection;
                if (definition.ribExtrusionDirection == RibExtrusionDirection.PARALLEL_TO_SKETCH_PLANE)
                {
                    // To get the parallel direction with the sketch plane, find the direction perpendicular
                    // to the sketch plane normal and the line that connects the start and end point of the profile.
                    const profileDirection = normalize(profileEndTangentLines[1].origin - profileEndTangentLines[0].origin);
                    ribDirection = cross(profilePlane.normal, profileDirection);
                }
                else
                {
                    ribDirection = profilePlane.normal;
                }

                if (definition.oppositeDirection)
                {
                    ribDirection = ribDirection * -1;
                }

                // Extrude a surface from the extended profile into the part(s), using the extend length
                // as the extrude depth to make sure the surface goes through the part(s).
                opExtrude(context, id + (i ~ "surfaceExtrude"), {
                            "entities" : qUnion(entitiesToExtrude),
                            "direction" : ribDirection,
                            "endDepth" : extendLength,
                            "endBound" : BoundingType.BLIND
                        });

                // Transform the extruded surface if needed to support feature pattern.
                transformResultIfNecessary(context, id + (i ~ "surfaceExtrude"), remainingTransform);

                // Thicken the surface to make the rib plus some excess material around the part(s).
                const halfThickness = definition.thickness / 2;
                opThicken(context, thickenId, {
                            "entities" : qCreatedBy(id + (i ~ "surfaceExtrude"), EntityType.FACE),
                            "thickness1" : halfThickness,
                            "thickness2" : halfThickness
                        });

                // Split the rib with the part(s) to separate the rib body from the thicken excess.
                var ribPartsQuery = qCreatedBy(thickenId, EntityType.BODY);
                opBoolean(context, id + (i ~ "splitOffRibExcess"), {
                            "tools" : definition.parts,
                            "targets" : ribPartsQuery,
                            "operationType" : BooleanOperationType.SUBTRACTION,
                            "keepTools" : true
                        });

                // Apply the remaining transform to the profile before doing collision testing.
                patternTransform(context, id + (i ~ "tr1"), profile, remainingTransform);
                // Do collision testing to help determine which parts of the thicken are excess.
                var clashes = evCollision(context, {
                        "tools" : ribPartsQuery,
                        "targets" : profile
                    });

                // Since we don't want the profile to actually move
                // move it back to it's original location after checking for collisions.
                patternTransform(context, id + (i ~ "tr2"), profile, inverse(remainingTransform));
                var clashBodies = mapArray(clashes, function(clash)
                {
                    return clash.toolBody;
                });

                // Specify a point at the end of the surface extrude.
                // Any thicken body that intersects with this point is excess.
                const surfaceExtrudeEndPoint = profileEndTangentLines[0].origin + (extendLength * ribDirection);

                // Collect up all the thicken excess and any other entities we've created leading
                // up to the thicken operation, because all of these need to be deleted.
                var entitiesToDelete = [
                    // Remove rib thicken excess sections that don't intersect the original profile.
                    qSubtraction(ribPartsQuery, qUnion(clashBodies)),

                    // Remove rib thicken excess sections that extend all the way to the end of
                    // the surface extrude (which we deliberately had extend well past the part,
                    // i.e. well past where a rib should be created).
                    qContainsPoint(ribPartsQuery, remainingTransform * surfaceExtrudeEndPoint),

                    // Remove the surface extrude, now that the thicken is completed and we don't need it anymore.
                    qCreatedBy(id + (i ~ "surfaceExtrude"), EntityType.BODY)
                ];

                // Delete any profile extensions created now that we don't need them anymore.
                // Also, any thicken section that intersects with the far end of an extension
                // (i.e. not the end that intersects with the profile) is thicken excess and should be deleted.
                for (var end in [0, 1])
                {
                    if (extendProfiles[end])
                    {
                        entitiesToDelete = append(entitiesToDelete, qCreatedBy(id + (i ~ "extendProfile" ~ end), EntityType.BODY));
                        entitiesToDelete = append(entitiesToDelete, qContainsPoint(ribPartsQuery, extendedEndPoints[end]));
                    }
                }

                opDeleteBodies(context, id + (i ~ "deleteRibExcess"), {
                            "entities" : qUnion(entitiesToDelete)
                        });
            }
            catch
            {
                throw regenError('Failed to create a rib from a selected profile.',
                        profile);
            }

            // Fail early if the rib body can't be created.
            if (evaluateQuery(context, qCreatedBy(thickenId, EntityType.BODY)) == [])
            {
                throw regenError('Selected profile did not produce a rib body.  Make sure the rib direction and alignment are correct.',
                        profile);
            }
        }

        // Optionally, merge the new ribs with the original parts.
        if (definition.mergeRibs)
        {
            // The original parts are first in the tools query so that they
            // will maintain their names.
            var toMerge = [definition.parts];
            for (var i = 0; i &lt; numberOfRibs; i += 1)
            {
                toMerge = append(toMerge, qCreatedBy(id, EntityType.BODY));
            }

            try
            {
                opBoolean(context, id + "mergeRibsWithParts", {
                            "tools" : qUnion(toMerge),
                            "operationType" : BooleanOperationType.UNION
                        });
            }
            catch
            {
                throw regenError('Failed to merge ribs into parts.');
            }
        }
    },
        {
            oppositeDirection : true,
            ribExtrusionDirection : RibExtrusionDirection.NORMAL_TO_SKETCH_PLANE,
            extendProfilesUpToPart : false,
            mergeRibs : true
        });

function patternTransform(context, id, query, transform)
{
    if (transform == identityTransform())
        return;
    opTransform(context, id, {
            "bodies" : qOwnerBody(query),
            "transform" : transform
    });
}
&lt;/pre&gt;</summary><category term="CADLab"></category><category term="MCAD"></category></entry><entry><title>電腦輔助設計室的電腦開機磁區設置</title><link href="http://cadlab.mde.tw/post/dian-nao-fu-zhu-she-ji-shi-de-dian-nao-kai-ji-ci-qu-she-zhi.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/dian-nao-fu-zhu-she-ji-shi-de-dian-nao-kai-ji-ci-qu-she-zhi.html</id><summary type="html">&lt;p&gt;第1磁區: Windows 10 Pro + &lt;a href="https://msdn.microsoft.com/zh-tw/virtualization/hyperv_on_windows/quick_start/walkthrough_install"&gt;Hyper-V&lt;/a&gt; 安裝 Windows 7 Professional&lt;/p&gt;
&lt;p&gt;第2磁區: Windows 10 Pro + 可攜免安裝程式套件&lt;/p&gt;
&lt;p&gt;第3磁區: &lt;a href="http://releases.ubuntu.com/16.04/"&gt;Ubuntu 16.04&lt;/a&gt; Server + ubuntu-desktop&lt;/p&gt;


&lt;p&gt;第1磁區擬舀採 Windows 10 Pro 開機, 並安裝常用的 CAD/CAE/CAM 相關軟體套件的安裝為主, 針對無法在 Windows 10 Pro 執行的套件, 則建議安裝在 Hyper-V 模式下的 Windows 7 Professional 開機磁區中.&lt;/p&gt;
&lt;p&gt;第1磁區的網路設置以純 IPV4 為主, 並將最後一排的 9 台電腦, 以 IPV4/IPV6 雙支援的固定 IP 啟動 Ubuntu + &lt;a href="http://www.squid-cache.org/"&gt;Squid&lt;/a&gt; (選擇第3磁區開機), 讓上課師生自行選擇開機後透過 &lt;a href="https://en.wikipedia.org/wiki/Round-robin_DNS"&gt;Round Robin DNS&lt;/a&gt; 配置域名的代理主機增速上網.&lt;/p&gt;
&lt;p&gt;第2磁區擬採 Windows 10 Pro 開機, 並全數使用無需安裝的程式套件, 以提升套件使用效能, 網路配置則彈性配置純 IPV4 或純 IPV6 位址上網, 當採用純 IPV6 上網時, 必須啟動電腦輔助設計室中的 9 台 IPV4/IPV6 雙支援代理主機 (以 Ubuntu 磁區開機).&lt;/p&gt;</summary><category term="CADLab"></category><category term="Windows 10"></category></entry><entry><title>雲端平台上的電腦輔助機械設計</title><link href="http://cadlab.mde.tw/post/yun-duan-ping-tai-shang-de-dian-nao-fu-zhu-ji-jie-she-ji.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/yun-duan-ping-tai-shang-de-dian-nao-fu-zhu-ji-jie-she-ji.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.onshape.com/"&gt;Onshape&lt;/a&gt; 在 &lt;a href="http://wordpress-2015course.rhcloud.com/?p=4514"&gt;2015年12月&lt;/a&gt;正式全面對外公開之後, 已經啟動電腦輔助機械設計的雲端世代, 為了追求高效能的全球協同產品設計流程, 利用跨硬體裝置, 免安裝, 具備設計特徵版次管理, 而且提供類似 &lt;a href="https://cad.onshape.com/FsDoc/"&gt;Featurescript&lt;/a&gt; 客製化功能建構環境 (i.e. Feature Studio) 的全雲端電腦輔助機械設計工具, 將會日漸完備.&lt;/p&gt;


&lt;p&gt;面對 Onshape 的破壞性創新產品挑戰, SolidWorks 也以採用 &lt;a href="http://www.3ds.com/about-3ds/3dexperience-platform/"&gt;3dexperience platform&lt;/a&gt; 核心技術為主體, 推出全新的全雲端產品: &lt;a href="http://xdesign.solidworks.com/"&gt;Xdesign&lt;/a&gt; 回應.&lt;/p&gt;
&lt;p&gt;目前, SolidWorks 單機版約佔全球市場&lt;a href="http://blog.cnccookbook.com/2015/01/20/results-2015-cad-survey/"&gt;超過五分之一&lt;/a&gt;, 未來將與自家的 Xdesign 與 Onshape 免安裝全雲端產品, 競逐全球電腦輔助機械設計軟體市場. &lt;/p&gt;
&lt;p&gt;因此, 2016 年可以說是電腦輔助機械設計的雲端元年, 正好比 2006 年推出的 &lt;a href="https://en.wikipedia.org/wiki/Google_Docs,_Sheets,_and_Slides"&gt;Google Doc&lt;/a&gt;, 晚了十年.&lt;/p&gt;</summary><category term="CADLab"></category><category term="MCAD"></category></entry><entry><title>大學教育政策白皮書讀後心得報告</title><link href="http://cadlab.mde.tw/post/da-xue-jiao-yu-zheng-ce-bai-pi-shu-du-hou-xin-de-bao-gao.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/da-xue-jiao-yu-zheng-ce-bai-pi-shu-du-hou-xin-de-bao-gao.html</id><summary type="html">&lt;p&gt;15 年前寫的&lt;a href="http://cad-lab.github.io/cadlab_data/files/90.07_taiwan_univ_white_paperpdf"&gt;大學教育政策白皮書&lt;/a&gt;讀後心得報告&lt;/p&gt;


&lt;p&gt;科技大學的本質在教導學生獲得知識的能力，二十一世紀知識經濟最大的特色，在於必須將知識迅速化為商品，由於市場全球化的影響，未能即時將本身所擁有的知識，快速轉化為商品，並被市場接受的企業，終將難逃被時代淘汰的命運，企業如此，教育界也正面臨同樣的挑戰。&lt;/p&gt;
&lt;p&gt;教育部將大學的競爭力，視為國家競爭力的重要指標，全國各大學面對社會多元化的需求與全民終身學習的發展趨勢，如何在「大學教育政策白皮書」的基本方針下，強化各校的競爭力，建立各校的重點特色，便成為各大學今後所賴以生存的重要關鍵。&lt;/p&gt;
&lt;p&gt;事實上，「大學教育政策白皮書」中所提到的觀點，或許是台灣一般大學與科技大學所共同面臨的問題，但，就基本體制上，仍然要有所區分，方能貫徹彼此的教育目標，為社會的現在與未來，提供充足的人力資源。吾人以為，一般大學的最高目標在追求學術的卓越，而科技大學則必須掌握技術的領先，學術強調的是其具備未來的主導性，卓越的學術指的是高瞻遠矚，是未來有用的技術；而技術的領先是要培養能馬上為企業所用的科技尖兵，是能馬上將知識轉化為商品的創新發明家。也許，隨著科技進化的速度日益增快，學術與技術的區隔，也就變得越來越小，但一般大學與科技大學應有的角色與定位，仍不失為各大學爭取重點特色時，所應強調的重點。&lt;/p&gt;
&lt;p&gt;最後，談到本校在通過改名為科技大學後，如何在「大學教育政策白皮書」的指導方針下，爭取市場定位，並積極發展出屬於自己的特色，吾人以為，必須要先從小處做起，慢慢往大處做；必須要先由內做起，然後再漸漸往外落實。小處在哪裡，必須先用科學化與合理化來管理學校的每一個角落，然後才能談替企業診斷，為財團解憂。必須要先在校內建立起知識經濟的體系，然後才有可能與社會上全民學習的脈動相結合。未來，全球化經濟發展的趨勢或許很難臆測，但本校單類多科的包袱，如何逐步轉化為本校的重點特色，將是一項嚴酷的考驗，成敗的關鍵，就看現在。&lt;/p&gt;</summary><category term="大學教育"></category></entry><entry><title>Onshape 即將釋出 Featurescript 程式語言</title><link href="http://cadlab.mde.tw/post/onshape-ji-jiang-shi-chu-featurescript-cheng-shi-yu-yan.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/onshape-ji-jiang-shi-chu-featurescript-cheng-shi-yu-yan.html</id><summary type="html">&lt;p&gt;今天早上參加 Onshape 在台灣所舉行的首次實體論壇，除了持續感受到 Onshape 團隊滿滿的誠意外，最大的收穫就是得知 Featurescript 特徵程式語言，即將開放各界使用。&lt;/p&gt;


&lt;p&gt;所謂的 Featurescript， 根據了解，是一種可以透過 Feature Studio， 讓使用者修改或延伸 Onshape 特徵指令的新程式語言，據悉，目前 Onshape 所指供的特徵指令功能，也是透過 Featurescript 打造。&lt;/p&gt;
&lt;p&gt;並且，未來使用者所打造的各式客製化 Featurescript 程式，可以在 Onshape App store 中免費公開或販售。&lt;/p&gt;</summary><category term="Onshape"></category><category term="Featurescript"></category></entry><entry><title>網際機械設計 2D 繪圖</title><link href="http://cadlab.mde.tw/post/wang-ji-ji-jie-she-ji-2d-hui-tu.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/wang-ji-ji-jie-she-ji-2d-hui-tu.html</id><summary type="html">&lt;p&gt;&lt;a href="http://2015fallhw.github.io/arcidau/Flintlock.html"&gt;http://2015fallhw.github.io/arcidau/Flintlock.html&lt;/a&gt; 是一個典型的網際機械設計 2D 繪圖範例, CADLab 希望能夠利用 Brython 重新建立一個直接以 Python3 在網頁中繪圖的類似應用.&lt;/p&gt;


&lt;style type="text/css" media="screen"&gt;

#flintlockImg {
  float: right;
  display: inline;  /* IE6 hack to fix double margin bug */
  width: 24em;
  margin: 1em 2em 1em 1em;
}

#flintlockImg img {
  width: 100%;
  padding: 0.5em;
  border: 1px solid #404040;
}

#cvsUpper, #cvsLower {
  position: relative;
  width: 600px;
  height: 300px;
  text-align: center;  /* this will center console if it has display:inline-block */
  background-color: #aabdd3;
}
&lt;/style&gt;

&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/Cango-8v03.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/Cango2D-7v01-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/CangoAxes-1v33.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/flintlockPartDefs-02.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/CangoAnimation-4v01.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="http://2015fallhw.github.io/cptocadp/static/gearUtils-05.js"&gt;&lt;/script&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;script type="text/javascript"&gt;

    if (typeof addLoadEvent === "undefined")
    {
      var addLoadEvent = function(func)
      {
        var oldonload = window.onload;
        if (typeof window.onload != 'function')
        {
          window.onload = func;
        }
        else
        {
            window.onload = function(){oldonload(); func();}
        }
      }
    }

    if (typeof addEvent === "undefined")
    {
      var addEvent = function(element, eventType, handler)
      {
        if (element.attachEvent)
        {
          return element.attachEvent('on'+eventType, handler);
        }
        return element.addEventListener(eventType, handler, false);
      };
    }

    function cancelBubble(e)
    {
      var evt = e ? e:window.event;
      if (evt.stopPropagation) evt.stopPropagation();
      if (evt.cancelBubble!=null) evt.cancelBubble = true;
    }
&lt;/script&gt;

&lt;script type="text/javascript"&gt;

function enableBtn(btnId)
{
  var btn = document.getElementById(btnId);
  btn.disabled = false;
}

function disableBtn(btnId)
{
  var btn = document.getElementById(btnId);
  btn.disabled = true;
}

function FlintlockDemo(cvsU, cvsL)
{
  "use strict"
  var innerGCL0, innerGCL1,
      outerGC,
      // Lock components (Cango2D groups)
      cockObj,
      fizzenObj,
      plateObj,
      searSpringObj,
      searObj,
      tumblerObj,
      mainSpringObj,
      screwsObj,
      // draw outside in lower canvas
      plateOutside,
      cockOutside,
      fizzenOutside,
      fizzenSpring,
      outScrews;

  this.fire_JS = function()
    {
    innerGCL0.playAnimation(0, 1000);   // play for 1000 then pause
    outerGC.playAnimation(0, 1000);

    disableBtn('cock');
    disableBtn('fire');
    setTimeout("enableBtn('load')", 1000);
  };

  this.load_JS = function()
  {
    innerGCL0.playAnimation(1000, 3500);    // resume from pause play until 3500
    outerGC.playAnimation(1000, 3500);

    disableBtn('load');
    disableBtn('fire');
    setTimeout("enableBtn('cock')", 2500);

  };

  this.cock_JS = function()
  {
    innerGCL0.playAnimation(3500, 5000);      // resume from pause play until 5000
    outerGC.playAnimation(3500, 5000);

    disableBtn('load');
    disableBtn('cock');
    setTimeout("enableBtn('fire')", 1500);
  };

  // Upper display
  innerGCL0 = new Cango(cvsU);                     // layer for the cock and fizzen
  innerGCL0.setWorldCoords(-250, -100, 500);       // square pixels origin in center of canvas
  innerGCL1 = new Cango(innerGCL0.createLayer());  // layer for main spring and sear
  innerGCL1.dupCtx(innerGCL0);

  // construct all the component objects
  cockObj = makeCock(innerGCL0);
  fizzenObj = makeFizzenInside(innerGCL0);
  plateObj = makePlate(innerGCL0);
  searSpringObj = makeSearSpring(innerGCL1);
  searObj = makeSear(innerGCL1);
  tumblerObj = makeTumbler(innerGCL1);
  mainSpringObj = makeMainSpring(innerGCL1);
  screwsObj = makeScrews(innerGCL1);

        var innerTwnr = new Tweener(0, 5000);
  var innerData = {
      cockRot:     [0, 54, 54, 18, 18,  0],
    cockRotTimes:[0, 10, 20, 60, 70, 90],
    fizzenRot:     [0, 0, 73, 73,  0],
    fizzenRotTimes:[0, 4,  8, 60, 70],
    searSpringRot:     [0, -5, -6, -3.5,  0, -2, -3.5, -3.5,  0,  0, -2, -3, -3.5,  0],
    searSpringRotTimes:[0,  5, 10,   15, 20, 30,   40,   50, 60, 70, 75, 80,   85, 90],
    searRot:     [0, 10, 12,  7,  0,  4,   7,   7,  0,  0,  4, 5.5,  7,  0],
    searRotTimes:[0,  5, 10, 15, 20, 30,  40,  50, 60, 70, 75,  80, 85, 90],
      tumblerRot:     [0, 54, 54, 18, 18,  0],
    tumblerRotTimes:[0, 10, 20, 60, 70, 90],
    mainSpringRot:     [0, -7, -7, -2, -2,  0],
    mainSpringRotTimes:[0, 10, 20, 60, 70, 90]
  };

  function initCock(opts)
  {
    this.nextState.x = cockCxOfs;
    this.nextState.y = -cockCyOfs;
  }

  function initFissen(opts)
  {
    this.nextState.x = fizzenCxOfs;
    this.nextState.y = -fizzenCyOfs;
  }

  function initSearSpring(opts)
  {
    this.nextState.x = searSpringCxOfs;
    this.nextState.y = -searSpringCyOfs;
  }

  function initSear(opts)
  {
    this.nextState.x = searCxOfs;
    this.nextState.y = -searCyOfs;
  }

  function initMainSpring(opts)
  {
    this.nextState.x = mainSpringCxOfs;
    this.nextState.y = -mainSpringCyOfs;
  }

  function cockPathFn(time, opts)
  {
    var cockRotVal = innerTwnr.getVal(time, opts.cockRot, opts.cockRotTimes);

    this.nextState.rot = cockRotVal;
  }

  function fizzenPathFn(time, opts)
  {
    var fizzenRotVal = innerTwnr.getVal(time, opts.fizzenRot, opts.fizzenRotTimes);

    this.nextState.rot = fizzenRotVal;
  }

  function searSpringPathFn(time, opts)
  {
    var searSpringRotVal = innerTwnr.getVal(time, opts.searSpringRot, opts.searSpringRotTimes);

    this.nextState.rot = searSpringRotVal;
  }

  function searPathFn(time, opts)
  {
    var searRotVal = innerTwnr.getVal(time, opts.searRot, opts.searRotTimes);

    this.nextState.rot = searRotVal;
  }

  function tumblerPathFn(time, opts)
  {
    var tumblerRotVal = innerTwnr.getVal(time, opts.tumblerRot, opts.tumblerRotTimes);

    this.nextState.rot = tumblerRotVal;
  }

  function mainSpringPathFn(time, opts)
  {
    var mainSpringRotVal = innerTwnr.getVal(time, opts.mainSpringRot, opts.mainSpringRotTimes);

    this.nextState.rot = mainSpringRotVal;
  }

  innerGCL0.animate(cockObj, initCock, cockPathFn, innerData);
  innerGCL0.animate(fizzenObj, initFissen, fizzenPathFn, innerData);
  innerGCL0.animate(plateObj);
  innerGCL1.animate(searSpringObj, initSearSpring, searSpringPathFn, innerData);
  innerGCL1.animate(searObj, initSear, searPathFn, innerData);
  innerGCL1.animate(tumblerObj, initCock, tumblerPathFn, innerData);
  innerGCL1.animate(mainSpringObj, initMainSpring, mainSpringPathFn, innerData);
  innerGCL1.animate(screwsObj);

  // Lower display
  outerGC = new Cango(cvsL);
  outerGC.setWorldCoords(-250, -100, 500);

  // construct all the component objects
  plateOutside = makePlateOutside(outerGC);
  cockOutside = makeCockOutside(outerGC);
  fizzenOutside = makeFizzenOutside(outerGC);
  fizzenSpring = makeFizzenSpring(outerGC);
  outScrews = makeOutScrews(outerGC);

        var outerTwnr = new Tweener(0, 5000);
  var outerData = {
      outerCockRot:     [0, -54, -54, -18, -18,  0],
    outerCockRotTimes:[0,  10,  20,  60,  70, 90],
    outerFizRot:     [0, 0, -73, -73,  0],
    outerFizRotTimes:[0, 4,   8,  60, 70],
    outerFizSpringRot:     [0, 0, 5, 6, 3.5, 0,  0,    3,  4,    3,  0],
    outerFizSpringRotTimes:[0, 4, 5, 6,   7, 8, 60, 62.5, 65, 67.5, 70]
  };

  function initCockOutside(opts)
  {
    this.nextState.x = -cockCxOfs;
    this.nextState.y = -cockCyOfs;
  }

  function initFissenOutside(opts)
  {
    this.nextState.x = -fizzenCxOfs;
    this.nextState.y = -fizzenCyOfs;
  }

  function initFissenSpring(opts)
  {
    this.nextState.x = -fizzenSpringCxOfs;
    this.nextState.y = -fizzenSpringCyOfs;
  }

  function outerCockPathFn(time, opts)
  {
    var cockRotVal = outerTwnr.getVal(time, opts.outerCockRot, opts.outerCockRotTimes);

    this.nextState.rot = cockRotVal;
  }

  function outerFizzenPathFn(time, opts)
  {
    var fizzenRotVal = outerTwnr.getVal(time, opts.outerFizRot, opts.outerFizRotTimes);

    this.nextState.rot = fizzenRotVal;
  }

  function fizzenSpringPathFn(time, opts)
  {
    var fizzenSpringRotVal = outerTwnr.getVal(time, opts.outerFizSpringRot, opts.outerFizSpringRotTimes);

    this.nextState.rot = fizzenSpringRotVal;
  }

  outerGC.animate(plateOutside);
  outerGC.animate(cockOutside, initCockOutside, outerCockPathFn, outerData);
  outerGC.animate(fizzenOutside, initFissenOutside, outerFizzenPathFn, outerData);
  outerGC.animate(fizzenSpring, initFissenSpring, fizzenSpringPathFn, outerData);
  outerGC.animate(outScrews);

  disableBtn('load');
  disableBtn('cock');
  enableBtn('fire');
}

var consoleBtns =
{
  f1:function(){demo.load_JS()},
  f2:function(){demo.cock_JS()},
  f3:function(){demo.fire_JS()},
  f4:function(){}
};

&lt;/script&gt;

&lt;script type="text/javascript"&gt;
addLoadEvent( function(){
  demo = new FlintlockDemo('cvsUpper', 'cvsLower');
  enableStickyNav();
});
&lt;/script&gt;

&lt;div class="consoleHolder"&gt;
&lt;div class="console"&gt;
&lt;div class="bezel"&gt;

    &lt;div class="scrnBevel"&gt;
    &lt;canvas id="cvsUpper" width="600" height="300"&gt;&lt;/canvas&gt;
    &lt;canvas id="cvsLower" width="600" height="300"&gt;&lt;/canvas&gt;
    &lt;/div&gt;  &lt;!-- scrnBevel --&gt;

    &lt;table class="btnHolder" cellspacing="0" cellpadding="0"&gt;
    &lt;tr align="center"&gt;
      &lt;td width="33%"&gt;&lt;button type="button" onclick="consoleBtns.f1()" class="button-link" id="load"&gt;HALF COCK&lt;/button&gt;&lt;/td&gt;
      &lt;td width="33%"&gt;&lt;button type="button" onclick="consoleBtns.f2()" class="button-link" id="cock"&gt;COCK&lt;/button&gt;&lt;/td&gt;
      &lt;td width="33%"&gt;&lt;button type="button" onclick="consoleBtns.f3()" class="button-link" id="fire"&gt;FIRE&lt;/button&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/table&gt;

&lt;/div&gt;

&lt;p&gt;&lt;!-- bezel --&gt;
&lt;div style="clear: both;"&gt;&lt;/div&gt;
&lt;/div&gt; &lt;!-- console --&gt;
&lt;/div&gt;   &lt;!-- consoleHolder --&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;利用 &lt;a href="http://2015fallhw.github.io/cptocadp/static/gearUtils-05.js"&gt;http://2015fallhw.github.io/cptocadp/static/gearUtils-05.js&lt;/a&gt; 程式庫, 繪製正齒輪:&lt;/p&gt;
&lt;!-- 齒輪繪圖 --&gt;

&lt;canvas id='gear1' width='800' height='750'&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
# 針對 Javascript 既有的物件, 則必須透過 JSConstructor 轉換
from javascript import JSConstructor
import math

# 主要用來取得畫布大小
canvas = doc["gear1"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
#ctx = canvas.getContext("2d")
# 針對類別的轉換, 將 Cango.js 中的 Cango 物件轉為 Python cango 物件
cango = JSConstructor(window.Cango)
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
cobj = JSConstructor(window.Cobj)
creategeartooth = JSConstructor(window.createGearTooth)

# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="plotarea" 的 canvas 上
cgo = cango("gear1")

######################################
# 畫正齒輪輪廓
#####################################
# n 為齒數
n = 17
# pa 為壓力角
pa = 25
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
m = 0.8*canvas.width/n
# pr 為節圓半徑
pr = n*m/2 # gear Pitch radius
# generate gear
data = creategeartooth(m, n, pa)
# Brython 程式中的 print 會將資料印在 Browser 的 console 區
#print(data)
gearTooth = cobj(data, "SHAPE", {
        "fillColor":"#ddd0dd",
        "border": True,
        "strokeColor": "#606060" })
gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
# 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
gear = gearTooth.dup()
# gear 為單一齒的輪廓資料
#cgo.render(gearTooth)

# 利用單齒輪廓旋轉, 產生整個正齒輪外形
for i in range(1, n):
    # 將 gearTooth 中的資料複製到 newTooth
    newTooth = gearTooth.dup()
    # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
    newTooth.rotate(360*i/n)
    # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
    gear.appendPath(newTooth, True) # trim move command = True

# 建立軸孔
# add axle hole, hr 為 hole radius
hr = 0.6*pr # diameter of gear shaft
shaft = cobj(shapedefs.circle(hr), "PATH")
shaft.revWinding()
gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path
cx = canvas.width/2
cy = canvas.height/2
gear.translate(cx, cy)
# render 繪出靜態正齒輪輪廓
cgo.render(gear)
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;上述正齒輪繪圖原始碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&amp;lt;canvas id='gear1' width='800' height='750'&amp;gt;&amp;lt;/canvas&amp;gt;

&amp;lt;script type="text/python"&amp;gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
# 針對 Javascript 既有的物件, 則必須透過 JSConstructor 轉換
from javascript import JSConstructor
import math

# 主要用來取得畫布大小
canvas = doc["gear1"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
#ctx = canvas.getContext("2d")
# 針對類別的轉換, 將 Cango.js 中的 Cango 物件轉為 Python cango 物件
cango = JSConstructor(window.Cango)
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
cobj = JSConstructor(window.Cobj)
creategeartooth = JSConstructor(window.createGearTooth)

# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="plotarea" 的 canvas 上
cgo = cango("gear1")

######################################
# 畫正齒輪輪廓
#####################################
# n 為齒數
n = 17
# pa 為壓力角
pa = 25
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
m = 0.8*canvas.width/n
# pr 為節圓半徑
pr = n*m/2 # gear Pitch radius
# generate gear
data = creategeartooth(m, n, pa)
# Brython 程式中的 print 會將資料印在 Browser 的 console 區
#print(data)
gearTooth = cobj(data, "SHAPE", {
        "fillColor":"#ddd0dd",
        "border": True,
        "strokeColor": "#606060" })
gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
# 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
gear = gearTooth.dup()
# gear 為單一齒的輪廓資料
#cgo.render(gearTooth)

# 利用單齒輪廓旋轉, 產生整個正齒輪外形
for i in range(1, n):
    # 將 gearTooth 中的資料複製到 newTooth
    newTooth = gearTooth.dup()
    # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
    newTooth.rotate(360*i/n)
    # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
    gear.appendPath(newTooth, True) # trim move command = True

# 建立軸孔
# add axle hole, hr 為 hole radius
hr = 0.6*pr # diameter of gear shaft
shaft = cobj(shapedefs.circle(hr), "PATH")
shaft.revWinding()
gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path
cx = canvas.width/2
cy = canvas.height/2
gear.translate(cx, cy)
# render 繪出靜態正齒輪輪廓
cgo.render(gear)
&amp;lt;/script&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;直接利用 Canvas 繪製正齒輪:&lt;/p&gt;
&lt;canvas id='gear2' width='800' height='700'&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
# 導入 browser 模組中的 document, 並設為 doc 變數
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

# 準備在 id="gear2" 的 canvas 中繪圖
canvas = doc["gear2"]
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2
r = 0.8*(canvas.width/2)
# 齒數
n = 53
# 壓力角
pa = 20
Spur(ctx).Gear(x, y, r, n, pa, "blue")
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;上述直接利用 Canvas 繪正齒輪的原始碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&amp;lt;canvas id='gear2' width='800' height='700'&amp;gt;&amp;lt;/canvas&amp;gt;

&amp;lt;script type="text/python3"&amp;gt;
# 導入 browser 模組中的 document, 並設為 doc 變數
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&amp;gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&amp;gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&amp;gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

# 準備在 id="gear2" 的 canvas 中繪圖
canvas = doc["gear2"]
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2
r = 0.8*(canvas.width/2)
# 齒數
n = 53
# 壓力角
pa = 20
Spur(ctx).Gear(x, y, r, n, pa, "blue")
&amp;lt;/script&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;正齒輪囓合繪圖:&lt;/p&gt;
&lt;canvas id='gear3' width='800' height='400'&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
# 導入 browser 模組中的 document, 並設為 doc 變數
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)

                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

# 準備在 id="gear3" 的 canvas 中繪圖
canvas = doc["gear3"]
ctx = canvas.getContext("2d")

# 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角
# 壓力角 pa 單位為角度
pa = 20
# 第1齒輪齒數
n_g1 = 17
# 第2齒輪齒數
n_g2 = 11
# 第3齒輪齒數
n_g3 = 13
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
m = (0.8*canvas.width)/(n_g1+n_g2+n_g3)
# 根據模數 m, 計算各齒輪的節圓半徑
rp_g1 = m*n_g1/2
rp_g2 = m*n_g2/2
rp_g3 = m*n_g3/2
#單一正齒輪繪圖呼叫格式 Spur(ctx).Gear(x, y, r, n, pa, "blue")
# 開始繪製囓合齒輪輪廓
# 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 的 80%, 所以兩邊各預留 10% 距離
x_g1 = canvas.width*0.1+rp_g1
# y 方向繪圖區域上方預留 canvas.height 的 20%
y_g1 = canvas.height*0.2+rp_g1
# 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同
x_g2 = x_g1 + rp_g1 + rp_g2
y_g2 = y_g1
# 第3齒輪的圓心座標
x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3
y_g3 = y_g1

# 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2
# 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g1, y_g1)
# rotate to engage
ctx.rotate(math.pi/2)
# put it back
ctx.translate(-x_g1, -y_g1)
# 繪製第一個齒輪輪廓
Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, "blue")
ctx.restore()

# 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g2, y_g2)
# rotate to engage
ctx.rotate(-math.pi/2-math.pi/n_g2)
# put it back
ctx.translate(-x_g2, -y_g2)
Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, "black")
ctx.restore()

# 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g3, y_g3)
# rotate to engage
# math.pi+math.pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度
# 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快
# 第1個 -math.pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度
# -math.pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合
# (math.pi+math.pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, 
# 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, 
# 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3
ctx.rotate(-math.pi/2-math.pi/n_g3+(math.pi+math.pi/n_g2)*n_g2/n_g3)
# put it back
ctx.translate(-x_g3, -y_g3)
Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, "red")
ctx.restore()
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;上述正齒輪囓合繪圖原始碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&amp;lt;canvas id='gear3' width='800' height='400'&amp;gt;&amp;lt;/canvas&amp;gt;

&amp;lt;script type="text/python3"&amp;gt;
# 導入 browser 模組中的 document, 並設為 doc 變數
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&amp;gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&amp;gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)

                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&amp;gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

# 準備在 id="gear3" 的 canvas 中繪圖
canvas = doc["gear3"]
ctx = canvas.getContext("2d")

# 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角
# 壓力角 pa 單位為角度
pa = 20
# 第1齒輪齒數
n_g1 = 17
# 第2齒輪齒數
n_g2 = 11
# 第3齒輪齒數
n_g3 = 13
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
m = (0.8*canvas.width)/(n_g1+n_g2+n_g3)
# 根據模數 m, 計算各齒輪的節圓半徑
rp_g1 = m*n_g1/2
rp_g2 = m*n_g2/2
rp_g3 = m*n_g3/2
#單一正齒輪繪圖呼叫格式 Spur(ctx).Gear(x, y, r, n, pa, "blue")
# 開始繪製囓合齒輪輪廓
# 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 的 80%, 所以兩邊各預留 10% 距離
x_g1 = canvas.width*0.1+rp_g1
# y 方向繪圖區域上方預留 canvas.height 的 20%
y_g1 = canvas.height*0.2+rp_g1
# 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同
x_g2 = x_g1 + rp_g1 + rp_g2
y_g2 = y_g1
# 第3齒輪的圓心座標
x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3
y_g3 = y_g1

# 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2
# 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g1, y_g1)
# rotate to engage
ctx.rotate(math.pi/2)
# put it back
ctx.translate(-x_g1, -y_g1)
# 繪製第一個齒輪輪廓
Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, "blue")
ctx.restore()

# 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g2, y_g2)
# rotate to engage
ctx.rotate(-math.pi/2-math.pi/n_g2)
# put it back
ctx.translate(-x_g2, -y_g2)
Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, "black")
ctx.restore()

# 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x_g3, y_g3)
# rotate to engage
# math.pi+math.pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度
# 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快
# 第1個 -math.pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度
# -math.pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合
# (math.pi+math.pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, 
# 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, 
# 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3
ctx.rotate(-math.pi/2-math.pi/n_g3+(math.pi+math.pi/n_g2)*n_g2/n_g3)
# put it back
ctx.translate(-x_g3, -y_g3)
Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, "red")
ctx.restore()
&amp;lt;/script&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;轉為 Brython 繪圖的模擬應用:&lt;/p&gt;
&lt;canvas id='robot' width='800' height='400'&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
from javascript import JSConstructor
from browser import window

cango2d = JSConstructor(window.Cango2D)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
tweener = JSConstructor(window.Tweener)

cgo = cango2d("robot")
# 清除畫面
cgo.clearCanvas("lightyellow")
cgo.setWorldCoords(-50, -50, 300)

# 加上基軸與第一桿
# 畫筆移到 -20, -10, 畫直線到 -10,-10 以及 -10,0 
standData = ['M', -20,-10, 'L', -10,-10, -10,0, 'A', 10,10,0,0,0,10,0, 'L',10,-10, 20,-10, 20,-40, -20,-40,'z']
stand = obj2d(standData, "SHAPE", {
        "fillColor":'darkgray',
        "border": True,
        "strokeColor": "#222222" })
axle0 = obj2d(shapedefs.circle(10), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222" })
armGrp = cgo.createGroup2D(stand, axle0)

segData = ['M',0,-8, 'A',8,8,0,0,0,0,8, 'L',50,8, 'A',8,8,0,0,0,50,-8, 'Z']
seg1 = obj2d(segData, "SHAPE", {
        "fillColor":'darkGray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": -1 })
# 利用 zIndex 決定疊層的先後次序
axle1 = obj2d(shapedefs.circle(8), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": 1 })
axle1.translate(50, 0)
seg1Grp = cgo.createGroup2D(seg1, axle1)
armGrp.addObj(seg1Grp)

# 加上第二軸
seg2 = obj2d(segData, "SHAPE", {
        "fillColor":'darkGray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": -1 })
axle2 = obj2d(shapedefs.circle(8), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": 1 })
axle2.translate(50, 0)
seg2Grp = cgo.createGroup2D(seg2, axle2)
cgo.render(seg2Grp)
# 請注意 seg2Grp 加上 seg1Grp 物件上
seg1Grp.addObj(seg2Grp)

seg3 = obj2d(segData, "SHAPE", {
        'fillColor':'darkGray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': -1 })
axle3 = obj2d(shapedefs.circle(6), "SHAPE", {
        'fillColor':'gray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': 1 })
axle3.translate(50, 0)
seg3Grp = cgo.createGroup2D(seg3, axle3)
seg2Grp.addObj(seg3Grp)

seg4Data = ['M',0,-6, 'A',6,6,0,0,0,0,6, 'L',40,6, 40,12, 50,12, 50,-12, 40,-12, 40,-6, 'Z']
seg4 = obj2d(seg4Data, "SHAPE", {
        'fillColor':'darkGray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': -1 })
seg3Grp.addObj(seg4)

# setup animation
animData = {'s1': [0, 80, 45, 0],
                  's2': [0, -60, -60, 0],
                  's3': [0, -90, 0, 90, 0],
                  's4': [0, 30, -90, 0]}

armTwnr = tweener(0, 3500, 'loop')

def initArm(opts):
    seg2Grp.transform.translate(50,0)
    seg3Grp.transform.translate(50,0)
    seg4.transform.translate(50,0)


def armPathFn(time, opts):
    seg1Rot = armTwnr.getVal(time, opts.s1)
    seg2Rot = armTwnr.getVal(time, opts.s2)
    seg3Rot = armTwnr.getVal(time, opts.s3)
    seg4Rot = armTwnr.getVal(time, opts.s4)

    seg1Grp.transform.rotate(seg1Rot)
    seg2Grp.transform.rotate(seg2Rot)
    seg2Grp.transform.translate(50,0)
    seg3Grp.transform.rotate(seg3Rot)
    seg3Grp.transform.translate(50,0)
    seg4.transform.rotate(seg4Rot)
    seg4.transform.translate(50,0)

cgo.animate(armGrp, initArm, armPathFn, animData)
cgo.playAnimation()
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;上述動態模擬的原始碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&amp;lt;canvas id='robot' width='800' height='400'&amp;gt;&amp;lt;/canvas&amp;gt;

&amp;lt;script type="text/python"&amp;gt;
from javascript import JSConstructor
from browser import window

cango2d = JSConstructor(window.Cango2D)
shapedefs = window.shapeDefs
obj2d = JSConstructor(window.Obj2D)
tweener = JSConstructor(window.Tweener)

cgo = cango2d("robot")
# 清除畫面
cgo.clearCanvas("lightyellow")
cgo.setWorldCoords(-50, -50, 300)

# 加上基軸與第一桿
# 畫筆移到 -20, -10, 畫直線到 -10,-10 以及 -10,0 
standData = ['M', -20,-10, 'L', -10,-10, -10,0, 'A', 10,10,0,0,0,10,0, 'L',10,-10, 20,-10, 20,-40, -20,-40,'z']
stand = obj2d(standData, "SHAPE", {
        "fillColor":'darkgray',
        "border": True,
        "strokeColor": "#222222" })
axle0 = obj2d(shapedefs.circle(10), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222" })
armGrp = cgo.createGroup2D(stand, axle0)

segData = ['M',0,-8, 'A',8,8,0,0,0,0,8, 'L',50,8, 'A',8,8,0,0,0,50,-8, 'Z']
seg1 = obj2d(segData, "SHAPE", {
        "fillColor":'darkGray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": -1 })
# 利用 zIndex 決定疊層的先後次序
axle1 = obj2d(shapedefs.circle(8), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": 1 })
axle1.translate(50, 0)
seg1Grp = cgo.createGroup2D(seg1, axle1)
armGrp.addObj(seg1Grp)

# 加上第二軸
seg2 = obj2d(segData, "SHAPE", {
        "fillColor":'darkGray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": -1 })
axle2 = obj2d(shapedefs.circle(8), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": 1 })
axle2.translate(50, 0)
seg2Grp = cgo.createGroup2D(seg2, axle2)
cgo.render(seg2Grp)
# 請注意 seg2Grp 加上 seg1Grp 物件上
seg1Grp.addObj(seg2Grp)

seg3 = obj2d(segData, "SHAPE", {
        'fillColor':'darkGray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': -1 })
axle3 = obj2d(shapedefs.circle(6), "SHAPE", {
        'fillColor':'gray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': 1 })
axle3.translate(50, 0)
seg3Grp = cgo.createGroup2D(seg3, axle3)
seg2Grp.addObj(seg3Grp)

seg4Data = ['M',0,-6, 'A',6,6,0,0,0,0,6, 'L',40,6, 40,12, 50,12, 50,-12, 40,-12, 40,-6, 'Z']
seg4 = obj2d(seg4Data, "SHAPE", {
        'fillColor':'darkGray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': -1 })
seg3Grp.addObj(seg4)

# setup animation
animData = {'s1': [0, 80, 45, 0],
                  's2': [0, -60, -60, 0],
                  's3': [0, -90, 0, 90, 0],
                  's4': [0, 30, -90, 0]}

armTwnr = tweener(0, 3500, 'loop')

def initArm(opts):
    seg2Grp.transform.translate(50,0)
    seg3Grp.transform.translate(50,0)
    seg4.transform.translate(50,0)


def armPathFn(time, opts):
    seg1Rot = armTwnr.getVal(time, opts.s1)
    seg2Rot = armTwnr.getVal(time, opts.s2)
    seg3Rot = armTwnr.getVal(time, opts.s3)
    seg4Rot = armTwnr.getVal(time, opts.s4)

    seg1Grp.transform.rotate(seg1Rot)
    seg2Grp.transform.rotate(seg2Rot)
    seg2Grp.transform.translate(50,0)
    seg3Grp.transform.rotate(seg3Rot)
    seg3Grp.transform.translate(50,0)
    seg4.transform.rotate(seg4Rot)
    seg4.transform.translate(50,0)

cgo.animate(armGrp, initArm, armPathFn, animData)
cgo.playAnimation()
&amp;lt;/script&amp;gt;
&lt;/pre&gt;</summary><category term="MCAD"></category><category term="Web based"></category></entry><entry><title>電腦輔助機械設計流程中的分散式版本管理</title><link href="http://cadlab.mde.tw/post/dian-nao-fu-zhu-ji-jie-she-ji-liu-cheng-zhong-de-fen-san-shi-ban-ben-guan-li.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/dian-nao-fu-zhu-ji-jie-she-ji-liu-cheng-zhong-de-fen-san-shi-ban-ben-guan-li.html</id><summary type="html">&lt;p&gt;&lt;a href="http://bazaar.canonical.com/en/"&gt;Bazaar&lt;/a&gt; (2004 年從 &lt;a href="https://www.gnu.org/software/gnu-arch/"&gt;Gnu arch&lt;/a&gt; 分出), &lt;a href="http://www.bitkeeper.com/"&gt;BitKeeper&lt;/a&gt;, &lt;a href="http://darcs.net/"&gt;darcs&lt;/a&gt;, &lt;a href="https://github.com/git"&gt;Git&lt;/a&gt;, &lt;a href="https://www.mercurial-scm.org/"&gt;Mercurial&lt;/a&gt; 是目前較為常見的分散式版本管理 (Distributed Version Control Systems, DVCS) 技術, 其中自 1998 年前後推出, 唯一商用閉源的 Bitkeeper, 也終於在 2016.05.09, 宣佈轉為開放原始碼套件: &lt;a href="https://users.bitkeeper.org/t/bk-7-2ce-released-2016-05-09/93"&gt;https://users.bitkeeper.org/t/bk-7-2ce-released-2016-05-09/93&lt;/a&gt;.&lt;/p&gt;


&lt;p&gt;其實, 早在 1995 年左右的 &lt;a href="https://en.wikipedia.org/wiki/Sun_WorkShop_TeamWare"&gt;Sun WorkShop TeamWare&lt;/a&gt; 就已經擁有分散式版本的相關技術, 而且在許多與機械設計相關的 PDM/PLM 系統中, 也都提供各種分散式版本控管的功能, 只是大多與封閉的檔案系統格式搭配使用, 使得多人協同模式下的電腦輔助機械設計流程, 成本不斷推升, 而且造成導入新技術的步調緩慢.&lt;/p&gt;
&lt;p&gt;當然, 這些國際大公司面對快速發展的數位虛擬與雲端技術, 眼看無法透過賣斷的使用授權來限制使用者, 也紛紛隨著許多創新的先行者 (例如: Onshape), 喊出不再販售大而無當的單機賣斷版本套件, 而改採較具彈性的網路訂閱授權.&lt;/p&gt;
&lt;p&gt;接下來, 當快速進展的全球協同模式必得讓各方團隊開始自行打造各式本地端、區域網路端、廣域網路端與雲端上的網際服務系統時, 目前最佳的授權認証模式, 則多採取 &lt;a href="https://tools.ietf.org/html/rfc6749"&gt;oauth2&lt;/a&gt; 的協定進行, 例如: Onshape 已經釋出 node.js 相容的程式模組: &lt;a href="https://github.com/onshape/passport-onshape"&gt;https://github.com/onshape/passport-onshape&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;儘管如此, 身為一般的機械設計產品開發團隊, 仍然無法像全球大量持續甩開 Microsoft 約束的程式開發者一樣, 熱烈擁抱諸如 Linux 與 FreeBSD 相關分支, 因為 &lt;a href="http://www.freecadweb.org/"&gt;http://www.freecadweb.org/&lt;/a&gt; 尚未大到可以取代許多封閉套件的地步, 現階段只能期待 Onshape 的授權方案能夠持續友善, 未來能夠有機會藉著清楚展示設計流程的分散式版本管理, 讓使用者能夠從此自混水中解脫.&lt;/p&gt;
&lt;p&gt;儘管 Onshape 的 API 使用授權尚未全面釋出, 但是假如希望先利用 oauth2 自行打造一個網際產品設計開發系統, 可以參考下列的簡單程式開發描述:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;讓使用者以 Gmail 帳號, 經由 google 制式流程登入後轉回應用程式&lt;/p&gt;
&lt;p&gt;使用技術: oauth2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;網際程式可以在本地端、區域網路端與雲端平台上佈署, 得到相同執行結果&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用技術: 利用物件案例的啟始, 建立所需的環境目錄架構,  以及起始資料庫檔案等, 利用操作系統模組讀取特定變數判定執行環境&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;資料庫存取技術與分頁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;人性化的 Javascript 或 Brython 環境導入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;美化的 Template 與 css 導入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Github, bitbucket 與 &lt;a href="https://gogs.io/"&gt;gogs&lt;/a&gt; 的程式開發版本管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;規劃所要維護的資料表: &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;人員名單含角色管理&lt;/p&gt;
&lt;p&gt;事件管理&lt;/p&gt;
&lt;p&gt;網際運算 (結合 Jupyter)&lt;/p&gt;
&lt;p&gt;參考資料:&lt;/p&gt;
&lt;p&gt;flask&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-now-with-python-3-support"&gt;http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-now-with-python-3-support&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;oauth2&lt;/p&gt;
&lt;p&gt;&lt;a href="http://oauth.net/2/"&gt;http://oauth.net/2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-1-introduction/"&gt;https://blog.yorkxin.org/posts/2013/09/30/oauth2-1-introduction/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://tools.ietf.org/html/rfc6749"&gt;https://tools.ietf.org/html/rfc6749&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;git&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/git"&gt;https://github.com/git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;working flow&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.drupal.org/node/803746"&gt;https://www.drupal.org/node/803746&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Jupyter and oauth2&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/jupyterhub/oauthenticator"&gt;https://github.com/jupyterhub/oauthenticator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/ryanlovett/jh-google-oauthenticator"&gt;https://github.com/ryanlovett/jh-google-oauthenticator&lt;/a&gt;&lt;/p&gt;</summary><category term="MCAD"></category><category term="DVCS"></category></entry><entry><title>常用 Python3 程式模組</title><link href="http://cadlab.mde.tw/post/chang-yong-python3-cheng-shi-mo-zu.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/chang-yong-python3-cheng-shi-mo-zu.html</id><summary type="html">&lt;p&gt;&lt;a href="http://www.cherrypy.org/"&gt;CherryPy&lt;/a&gt;, &lt;a href="http://pytz.sourceforge.net/"&gt;pytz&lt;/a&gt;, &lt;a href="http://www.makotemplates.org/"&gt;mako&lt;/a&gt;, &lt;a href="https://www.crummy.com/software/BeautifulSoup/"&gt;beautifulsoup4&lt;/a&gt;, &lt;a href="https://github.com/PyMySQL/PyMySQL"&gt;pymysql&lt;/a&gt;, &lt;a href="https://github.com/coleifer/peewee"&gt;peewee&lt;/a&gt;, &lt;a href="https://github.com/sigmavirus24/github3.py"&gt;github3.py&lt;/a&gt;, &lt;a href="http://peterhudec.github.io/authomatic/"&gt;authomatic&lt;/a&gt; 等是 CADLab 網際程式開發流程中較常用的 Python3 模組.&lt;/p&gt;


&lt;p&gt;其中的 &lt;a href="http://www.cherrypy.org/"&gt;CherryPy&lt;/a&gt; 與 &lt;a href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt; 位階相似, 但是
特性卻有很大差別, CherryPy 小而自給自足, Flask 則架構較具彈性, 許多延伸功能都採 extension 方式補足, 有關 CherryPy 的各種用法, 請參考 &lt;a href="http://cad-lab.github.io/manual/post/cherrypy-shi-yong-shou-ce.html"&gt;http://cad-lab.github.io/manual/post/cherrypy-shi-yong-shou-ce.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/zzzeek/mako"&gt;https://github.com/zzzeek/mako&lt;/a&gt; 的最大特色, 是將 Python 的語法直接放到 template 文件中, 儘管如此可能會讓使用者將原本應該放在控制端的資料流程, 分散到展示端, 但是實際採用後, 也沒有發生太大問題, 反而可以利用相同的網際程式, 直接套用到 Mako 與 Flask 內建的 template 語法中, 進行比較.&lt;/p&gt;
&lt;p&gt;github3.py 針對 Github 倉儲新增協同者的程式片斷範例:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
@app.route('/yourrepoadd', methods=['POST'])
def yourrepoadd():
    account = request.form["account"]
    repository = "yourrepo"
    url = "https://github.com/youraccount/yourrepo.git"
    # 登入系統
    g = github3.login("youraccount", "yourpassword")
    # 以下則新增協同者
    #g.repository(倉儲帳號, 倉儲名稱).add_collaborator(協同者 github 帳號)
    # 若新增 collaborator 成功傳回 True 否則傳回 False
    if g.repository("youraccount", repository).add_collaborator(account):
        # 共同使用 cpaadd.html
        return render_template("cpaadd.html", account=account, repository=repository, url=url)
    else:
        return render_template("cpaerror.html")
&lt;/pre&gt;

&lt;p&gt;至於 authomatic 的使用, 共有3個步驟:&lt;/p&gt;
&lt;h2&gt;1. 取得 key 與 secret&lt;/h2&gt;
&lt;p&gt;設定網址:&lt;/p&gt;
&lt;p&gt;https://console.developers.google.com&lt;/p&gt;
&lt;p&gt;總共有兩項設定:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;啟用 Google + API&lt;/li&gt;
&lt;li&gt;然後到憑證處建立專案, 設定授權的 URI&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;設定目的在希望透過 Google+ API 讓 Web browser (Javascript) 能夠擷取 User data, 這時需要的是 Create an OAuth 2.0 client ID, 建立專案後, 必須選擇 Authorized Javascript origins 為 http://your.server.domain.name 與 http://localhost:5000, 而 Authorized redirect URIs 為: http://your.server.domain.name/autho_login/google/ 與 http://localhost:5000/autho_login/google/&lt;/p&gt;
&lt;h2&gt;2. 導入模組, 進行設定&lt;/h2&gt;
&lt;pre class="brush: python"&gt;
import authomatic
from authomatic.providers import oauth2

CONFIG = {
        'google': {
            'class_': oauth2.Google,
            'consumer_key': '1234567.apps.googleusercontent.com',
            'consumer_secret': '87654321',
            #'scope': oauth2.Google.user_info_scope
            # 以下只允許(瞭解您在 Google 上的身分)與(檢視電子郵件地址)
            'scope': ['email']
        }
    }
&lt;/pre&gt;

&lt;h2&gt;3. 配合建立登入連結&lt;/h2&gt;
&lt;pre class="brush: python"&gt;
@app.route('/autho_login/&amp;lt;provider_name&amp;gt;/', methods=['GET', 'POST'])
def autho_login(provider_name):

    # We need response object for the WerkzeugAdapter.
    response = make_response()

    # Log the user in, pass it the adapter and the provider name.
    result = authomatic.login(WerkzeugAdapter(request, response), provider_name)

    # If there is no LoginResult object, the login procedure is still pending.
    if result:
        if result.user:
            # We need to update the user to get more info.
            result.user.update()

        # 利用 session 登記登入者的 email
        session['login_email'] = result.user.email

        # 這裡必須分近端與雲端, 因為 google logout redirect 的 url 不同
        if 'OPENSHIFT_REPO_DIR' in os.environ.keys():
            # 表示程式在雲端執行
            local = False
        else:
            # 表示在近端執行
            local = True
        # The rest happens inside the template.
        return render_template('autho_login.html', result=result, local=local)

    # Don't forget to return the response.
    return response
&lt;/pre&gt;

&lt;h2&gt;oauth2 登入的情境&lt;/h2&gt;
&lt;p&gt;使用 oauth2 的目的, 在利用既有的使用者帳號進行應用程式的登入, 例如, 使用 facebook 或 gmail 帳號登入到我們所開發的網際應用程式, 好處是, 使用者無需在各類網際程式中額外再申請帳號, 而程式開發者也可以免去管理使用者帳號的難題.&lt;/p&gt;
&lt;p&gt;但是, 為了在使用者被 oauth2 協定轉介到 gmail 登入頁面, 完成登入後, 就會再帶著帳號擁有者所允許的相關訊息, 回到網際應用程式中, 通常這些網際程式會利用 session 與 cookie 來儲存使用者登入的身份資料, 如此一來, 便有以下情境:&lt;/p&gt;
&lt;p&gt;假如使用者在選擇登入到網際程式之前, 已經登入到 gmail, 那麼使用者無需再輸入帳號密碼, 只要同意允許擷取帳號資料 ,就會直接跳轉到網際程式功能中, 特別注意到, 這時 gmail 有使用者登入的 session 與 cookie, 而且使用者的瀏覽器還存在登入到網際應用程式的狀態.&lt;/p&gt;
&lt;p&gt;第2種情況則是, 使用者被轉介到 gmail 登入畫面時, 才輸入帳號密碼登入, 之後情境就與上述第1種情況相同.&lt;/p&gt;
&lt;p&gt;上述兩種情況, 在瀏覽器中, 使用者的狀態是同時登入到 gmail 與網際程式中, 即便使用者登入網際程式後, 若使用者沒有主動登出 gmail, 這位使用者在瀏覽器的狀態中, 仍然保持登入到 gmail 的狀態.&lt;/p&gt;
&lt;p&gt;因此第3種情況則是, 使用者經由 oauth2 協定轉介到 gmail 登入後同意讓網際程式擷取帳號資料後, 就能登入到網際程式中, 隨後使用者主動登出 gmail, 並不會影響仍然登入到網際程式中的狀態, 一直到使用者選擇登出網際應用程式為止.&lt;/p&gt;
&lt;p&gt;理論上, 假如我們所開發的網際程式, 只是透過一系列上述的設定, 藉由 gmail 的帳號, 來登入我們所開發的網際程式, 比較好的作法是一旦完成我們網際應用程式的登入後, 可以經由程式方法登出使用者的 gmail 帳號, 然後再由使用者決定何時要登出我們所開發的網際程式.&lt;/p&gt;
&lt;p&gt;以下就是利用 Javascript 在登入應用程式之後, 設法登出使用者 gmail 帳號的設計, 並且同時支援本地端程式開發與雲端應用的情況:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
{# autho_login.html #}
{% extends "autho_base.html" %}

{% block body %}

&amp;lt;!-- 這裡應該要再分近端與雲端的不同處理流程, 而且要在設定時便取得綁定的雲端網址 --&amp;gt;
{% if local %}
&amp;lt;script type="text/javascript"&amp;gt;
window.location="https://www.google.com/accounts/Logout?continue=https://appengine.google.com/_ah/logout?continue=http://localhost:5000/check_login";
&amp;lt;/script&amp;gt;
{% else %}
&amp;lt;script type="text/javascript"&amp;gt;
window.location="https://www.google.com/accounts/Logout?continue=https://appengine.google.com/_ah/logout?continue=http://your.server.domain.name/check_login";
&amp;lt;/script&amp;gt;
{% endif %}

{% endblock body %}
&lt;/pre&gt;</summary><category term="Python3"></category><category term="module"></category></entry><entry><title>Wordpress 網誌文章中的網際程式碼</title><link href="http://cadlab.mde.tw/post/wordpress-wang-zhi-wen-zhang-zhong-de-wang-ji-cheng-shi-ma.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/wordpress-wang-zhi-wen-zhang-zhong-de-wang-ji-cheng-shi-ma.html</id><summary type="html">&lt;p&gt;從 &lt;a href="https://www.w3.org/Graphics/SVG/History"&gt;SVG 歷史&lt;/a&gt; 與 &lt;a href="https://en.wikipedia.org/wiki/WebGL#History"&gt;WebGL 歷史&lt;/a&gt;, 以及 &lt;a href="https://github.com/socketio/socket.io/blob/master/History.md"&gt; socket.io 歷史&lt;/a&gt;, 也許不難發現, 多人協同在瀏覽器為基礎的應用程式環境, 已然成型.&lt;/p&gt;


&lt;p&gt;儘管如此, 要將所有的工作全時在網路連線的環境中完成, 可能仍言之過早, 比較讓人確定的是, 多點觸控的平台伴隨著本地端的桌機或者是筆電, 還會繼續是主流的電腦輔助設計環境.&lt;/p&gt;
&lt;p&gt;在這樣的所謂 Web Based (網際) 環境中, 身為一位機械設計工程師, 除了要關注傳統的 2D/3D 靜態與動態內容表達外, 能否逐步導入多點觸控裝置的資料, 便成為重點.&lt;/p&gt;
&lt;p&gt;以網際 2D 繪圖而言, 2013 年推出的 &lt;a href="http://snapsvg.io/"&gt;http://snapsvg.io/&lt;/a&gt;, 就是一套能夠順應未來電腦輔助機械設計繪圖的工具之一.&lt;/p&gt;
&lt;p&gt;從 &lt;a href="http://chiamingyen.github.io/kmolab/blog/dao-ru-brython-yu-snapsvg-wang-ji-hui-tu.html"&gt;導入 Brython 與 Snap.svg 網際繪圖&lt;/a&gt; 的說明中, 我們已經知道能夠透過網際的 Brython 來呼叫並運用 snap.svg 程式庫, 但是假如希望完成如 &lt;a href="http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html"&gt;Pelican 靜態網頁與 Wordpress 的整合方案&lt;/a&gt; 中所談到的資料整合, 並且導入 snap.svg 到 Wordpress 與 Pelican 網誌系統, 需要注意到 Wordpress 對於內文中處理程式碼的用法, 否則由 Pelican 靜態網誌轉進 Wordpress 系統中的所有 Brython 或 Javascript 程式內容, 將會全數被 Wordpress 當作一般文字資料處理.&lt;/p&gt;
&lt;p&gt;應對的方法很簡單, 只需要明確利用 html 的註解標註, 跳過 Wordpress 對於 Brython 與 Javascript 程式碼的額外處理就行.&lt;/p&gt;
&lt;p&gt;以下舉 Snap.svg 典型的動態模擬為例:&lt;/p&gt;
&lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"&gt;&lt;/script&gt;

&lt;script&gt;
//&lt;!--
window.onload=function(){
brython(1);
}
//--&gt;
&lt;/script&gt;

&lt;p&gt;&lt;svg width="800" height="600" viewBox="0 0 800 600" id="svgout"&gt;&lt;/svg&gt;&lt;/p&gt;
&lt;script type="text/python"&gt;
#&lt;!--
from javascript import JSConstructor
from browser import alert
from browser import window, document

# 透過 window 與 JSConstructor 從 Brython 物件 snap 擷取 Snap 物件的內容
snap = JSConstructor(window.Snap)

# 使用 id 為 "svgout" 的 svg 標註進行繪圖
s = snap("#svgout")

offsetY = 50

# 是否標示出繪圖範圍
#borderRect = s.rect(0,0,800,640,10,10).attr({ 'stroke': "silver", 'fill': "silver", 'strokeWidth': "3" })

g = s.group().transform('t250,120')
r0 = s.rect(150,150,100,100,20,20).attr({ 'fill': "orange", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c0 = s.circle(225,225,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4"  }).attr({ 'id': 'c0' })
g0 = s.group( r0,c0 ).attr({ 'id': 'g0' })
#g0.animate({ 'transform' : 't250,120r360,225,225' },4000)
g0.appendTo( g )
g0.animate({ 'transform' : 'r360,225,225' },4000)
# 讓 g0 可以拖動
g0.drag()

r1 = s.rect(100,100,100,100,20,20).attr({ 'fill': "red", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c1 = s.circle(175,175,10).attr({ 'fill': "silver", 'stroke': "black" , 'strokeWidth': "4"}).attr({ 'id': 'c1' })
g1 = s.group( r1,c1 ).attr({ 'id': 'g1' })
g1.appendTo( g0 ).attr({ 'id': 'g1' })
g1.animate({ 'transform' : 'r360,175,175' },4000)

r2 = s.rect(50,50,100,100,20,20).attr({ 'fill': "blue", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c2 = s.circle(125,125,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c2' })
g2 = s.group(r2,c2).attr({ 'id': 'g2' })

g2.appendTo( g1 );
g2.animate( { 'transform' : 'r360,125,125' },4000);

r3 = s.rect(0,0,100,100,20,20).attr({ 'fill': "yellow", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c3 = s.circle(75,75,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c3' })
g3 = s.group(r3,c3).attr({ 'id': 'g3' })

g3.appendTo( g2 )
g3.animate( { 'transform' : 'r360,75,75' },4000)

r4 = s.rect(-50,-50,100,100,20,20).attr({ 'fill': "green", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c4 = s.circle(25,25,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c4' })
g4 = s.group(r4,c4).attr({ 'id': 'g4' });
g4.appendTo( g3 )
g4.animate( { 'transform' : 'r360,25,25' },4000)
#--&gt;
&lt;/script&gt;

&lt;p&gt;Brython 程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&amp;lt;script type="text/javascript" src="http://brython.info/src/brython_dist.js"&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script&amp;gt;
//&amp;lt;!--
window.onload=function(){
brython(1);
}
//--&amp;gt;
&amp;lt;/script&amp;gt;

&amp;lt;svg width="800" height="600" viewBox="0 0 800 600" id="svgout"&amp;gt;&amp;lt;/svg&amp;gt;

&amp;lt;script type="text/python"&amp;gt;
#&amp;lt;!--
from javascript import JSConstructor
from browser import alert
from browser import window, document

# 透過 window 與 JSConstructor 從 Brython 物件 snap 擷取 Snap 物件的內容
snap = JSConstructor(window.Snap)

# 使用 id 為 "svgout" 的 svg 標註進行繪圖
s = snap("#svgout")

offsetY = 50

# 是否標示出繪圖範圍
#borderRect = s.rect(0,0,800,640,10,10).attr({ 'stroke': "silver", 'fill': "silver", 'strokeWidth': "3" })

g = s.group().transform('t250,120')
r0 = s.rect(150,150,100,100,20,20).attr({ 'fill': "orange", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c0 = s.circle(225,225,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4"  }).attr({ 'id': 'c0' })
g0 = s.group( r0,c0 ).attr({ 'id': 'g0' })
#g0.animate({ 'transform' : 't250,120r360,225,225' },4000)
g0.appendTo( g )
g0.animate({ 'transform' : 'r360,225,225' },4000)
# 讓 g0 可以拖動
g0.drag()

r1 = s.rect(100,100,100,100,20,20).attr({ 'fill': "red", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c1 = s.circle(175,175,10).attr({ 'fill': "silver", 'stroke': "black" , 'strokeWidth': "4"}).attr({ 'id': 'c1' })
g1 = s.group( r1,c1 ).attr({ 'id': 'g1' })
g1.appendTo( g0 ).attr({ 'id': 'g1' })
g1.animate({ 'transform' : 'r360,175,175' },4000)

r2 = s.rect(50,50,100,100,20,20).attr({ 'fill': "blue", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c2 = s.circle(125,125,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c2' })
g2 = s.group(r2,c2).attr({ 'id': 'g2' })

g2.appendTo( g1 );
g2.animate( { 'transform' : 'r360,125,125' },4000);

r3 = s.rect(0,0,100,100,20,20).attr({ 'fill': "yellow", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c3 = s.circle(75,75,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c3' })
g3 = s.group(r3,c3).attr({ 'id': 'g3' })

g3.appendTo( g2 )
g3.animate( { 'transform' : 'r360,75,75' },4000)

r4 = s.rect(-50,-50,100,100,20,20).attr({ 'fill': "green", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c4 = s.circle(25,25,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c4' })
g4 = s.group(r4,c4).attr({ 'id': 'g4' });
g4.appendTo( g3 )
g4.animate( { 'transform' : 'r360,25,25' },4000)
#--&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/pre&gt;</summary><category term="Wordpress"></category><category term="MCAD"></category></entry><entry><title>Onshape 提供免費教育單位帳號</title><link href="http://cadlab.mde.tw/post/onshape-ti-gong-mian-fei-jiao-yu-dan-wei-zhang-hao.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/onshape-ti-gong-mian-fei-jiao-yu-dan-wei-zhang-hao.html</id><summary type="html">&lt;p&gt;從 &lt;a href="https://www.onshape.com/cad-blog/introducing-the-onshape-education-plan"&gt;https://www.onshape.com/cad-blog/introducing-the-onshape-education-plan&lt;/a&gt; 得知, Onshpae 除了提供各種身份的用戶有使用限度的免費帳號以外, 從 2016.04.07 開始更加碼, 讓教育單位可以免費, 且沒有使用限度的情況下, 來探索使用這個劃時代的雲端電腦輔助機械設計套件.&lt;/p&gt;


&lt;h2&gt;穩定的網路連線是使用 Onshpae 的必要條件&lt;/h2&gt;
&lt;p&gt;假如電腦教室網路連線穩定, 六十名學生可以同時利用 Firefox 或 Chrome,  登入到 &lt;a href="https://www.onshape.com"&gt;Onshape&lt;/a&gt; 執行協同產品設計, 登記免費的教育單位專用帳號後, 只要完成電子郵箱驗證, 就會自動登入系統.&lt;/p&gt;
&lt;h2&gt;Onshape 的 Document 是專案容器&lt;/h2&gt;
&lt;p&gt;登入後, 可以利用左側的 Tutorials &amp;amp; Samples 來了解 Onshpae 的用法:&lt;/p&gt;
&lt;p&gt;Onshape 中的 Documents 為設計專案層次 (Project level) 的文件庫 (Container), 可以納入 3D 零件, 3D 組件, 工程圖, 以及從外部轉入的各式檔案.&lt;/p&gt;
&lt;h2&gt;Onshape 操作無需存檔, 而且保有流程版本&lt;/h2&gt;
&lt;p&gt;在 Onshpae 環境中操作零件繪圖, 使用者無需手動存檔, 只要完成任何操作, 都會自動儲存版本, 而且可以在各版本之間遊走.&lt;/p&gt;
&lt;p&gt;登入 Onshape, 就可以利用左上角的 Create 按鈕建立 Document 專案文件, 然後再利用左下角的 + 號, 選擇要建立零件, 組件, 工程圖或者是從本地端上傳各式文件.&lt;/p&gt;
&lt;p&gt;假如是建立零件, 與其他 MCAD 套件類似, 可以選擇 Sketch 再選擇作圖平面, 或者先選擇作圖平面, 再選擇 Sketch 繪製平面輪廓, 輪廓繪圖, 可以直接在 3D 環境畫圖, 或者利用滑鼠右鍵帶出 View normal to sketch plane 的功能, 以垂直繪圖面的平面上進行繪圖.&lt;/p&gt;
&lt;h2&gt;Onshape 可以轉出各式檔案&lt;/h2&gt;
&lt;p&gt;各種基本的平面繪圖與尺寸標定或約束條件設定, 都與其他傳統的單機 MCAD 大同小異, 雖然 Onshape 與 Solid Edge 採用相同的 PARASOLID kernel, 但是所有的零組件檔案, 可以直接以點選下方的零組件 Tab, 再以滑鼠右鍵帶出 Export 功能, 然後轉成 PARASOLID 或 ACIS 核心檔,甚至也能直接轉成 Solidworks 格式檔案, 當然也能轉成 IGES, STEP, RHINO, STL 等格式.&lt;/p&gt;
&lt;h2&gt;Onshape 擁有直覺的組立約束&lt;/h2&gt;
&lt;p&gt;當使用者在 Onshape 零件繪製模式下完成基本零件, 就可以利用左下方的 + 建立組立檔, 將各零件一一放入進行組裝.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/help/Content/mate-fastened.htm"&gt;Fastened mate&lt;/a&gt; 主要用於焊接式的組合, 約束條件置入後, 兩個零件間已經沒有任何自由度而結為一體.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/help/Content/mate-revolute.htm"&gt;Revolute mate&lt;/a&gt; 主要用於旋轉軸式的組合, 約束條件置入後, 兩個零件間只留下一個旋轉自由度.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/help/Content/mate-slider.htm"&gt;Slider mate&lt;/a&gt; 主要用於滑塊式的組合, 約束條件置入後, 兩個零件間只留下一個平移自由度.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/help/Content/mate-planar.htm"&gt;Planar mate&lt;/a&gt; 主要用於面接式組合, 約束條件置入後, 兩個零件面對面靠接, 只允許兩個方向的移動自由度, 以及垂直靠接面方向的一個旋轉自由度.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/help/Content/mate-cylindrical.htm&gt;Cylindrical mate&lt;/a&gt; 主要用於圓柱螺栓式的組合, 約束條件置入後, 兩個零件將具有旋轉與前進或後退的兩個自由度.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/help/Content/mate-pin_slot.htm"&gt;Pin slot mate&lt;/a&gt; 主要用於插銷式組合, 約束條件置入後, 兩個零件具有旋轉與側向平移等兩個自由度.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/help/Content/mate-ball.htm"&gt;Ball mate&lt;/a&gt; 主要用於球接頭式的組合, 約束條件置入後, 將保留3個方向的旋轉自由度.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/help/Content/mate-ball.htm"&gt;Tangent mate&lt;/a&gt; 則是比較特殊的相切組立, 約束條件置入後, 兩個零件將始終保持相切的關係.&lt;/p&gt;
&lt;h2&gt;簡單的組立應用&lt;/h2&gt;
&lt;p&gt;根據上述基本功能, 就可以完成下列腳踏車鏈條的基本組立:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/onshape_bike_chain_assembly.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;教育版對應帳號下所完成的 &lt;a href="https://cad.onshape.com/documents/29d1a262b055745e59be7c09/w/1f25948ad73282e2440ffdcf"&gt;Bike chain Document&lt;/a&gt;.&lt;/p&gt;</summary><category term="Onshape"></category><category term="MCAD"></category></entry><entry><title>CADLab 學員網誌系統</title><link href="http://cadlab.mde.tw/post/cadlab-xue-yuan-wang-zhi-xi-tong.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/cadlab-xue-yuan-wang-zhi-xi-tong.html</id><summary type="html">&lt;p&gt;我們希望每一位 CADLab 電腦輔助設計室的學員都能夠充份利用現階段各種全球資訊網上的工具, 有效管理自己與團隊間的協同產品開發或學習過程的各種資訊.&lt;/p&gt;


&lt;p&gt;這裡所謂的資訊包括:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;口語資訊&lt;/li&gt;
&lt;li&gt;Text 文字資訊&lt;/li&gt;
&lt;li&gt;2D 圖面資訊&lt;/li&gt;
&lt;li&gt;3D 動態資訊&lt;/li&gt;
&lt;li&gt;系統模擬資訊&lt;/li&gt;
&lt;li&gt;實體模型資訊&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中需要使用的工具包括 Python3, Leo Editor 以及 Pelican, 使用者若在 Windows 環境, 可以直接使用可攜套件: &lt;a href="https://github.com/chiamingyen/kmol2016"&gt;https://github.com/chiamingyen/kmol2016&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;而每位學員均可利用 &lt;a href="http://www.cmsimply.com"&gt;http://www.cmsimply.com&lt;/a&gt; 來收集上述各種資訊內容, 然後再配合時機點與需求, 將資料分別同步到動態 Wordpress 網誌與 Pelican 靜態網誌.&lt;/p&gt;
&lt;p&gt;目前所使用的 Leo Editor 網誌系統專案位於: &lt;a href="https://github.com/cad-lab/manual"&gt;https://github.com/cad-lab/manual&lt;/a&gt;, 學員可以在其中加入下列3個 Leo Editor 的指令按鈕, 讓內容與 Wordpress 動態網誌同步.&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#new-to-wordpress
#coding: utf-8
import xmlrpc.client
import datetime
import os

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python
    # 用跳行符號分割
    data_list = data.split("\n")
    #第2行為 title
    title= data_list[1]
    #第3行為 category
    category = data_list[2]
    #第4行為 tags
    tags = data_list[3]
    # 有多項資料的 content 型別為數列
    # 再將第7行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[6:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 &lt;!-more-&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    content = content.replace('~~~python', '[code lang="python"]')
    content = content.replace('~~~', '[/code]')
    return title, category, tags, content

os.environ['TZ'] = 'Asia/Taipei'

#################################
filepath = "/home/amd/Desktop/your_wordpress_account_and_password.txt"
wordpress = "your-wordpress-site-url"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

# 從網誌節點的 parent().h 取得 wp_url
# 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑
wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################
wp_blogid = "0"

status_draft = 0
status_published = 1

server = xmlrpc.client.ServerProxy(wp_url)

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 指定時間出版
'''
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime("2013-01-01 00:00",
"%Y-%m-%d %H:%M"))
'''
# 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \
datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),"%Y-%m-%d %H:%M"))
categories = [category_str.split(":")[1]]
# 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料
# 先用 : 斷開標投頭的 Tags:, 然後再透過逗點隔開, 將標註轉為數列資料
tags = tags_str.split(":")[1].split(",")
data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags}

post_id = server.metaWeblog.newPost(wp_blogid, wp_username, wp_password, data, status_published)
# 利用最後的 child 節點來儲存 post_id
to_save_post_id = p.insertAsLastChild()   
# 改為內文為空的節點, id 直接標在 head 標題 
to_save_post_id.b = ""
to_save_post_id.h = post_id
# 因為新增節點, commander 必須 redraw
c.redraw() 

g.es("post_id 為", post_id)
g.es("已經送出資料!")

'''
其他 metaWeblog 的用法:
metaWeblog.newPost (blogid, username, password, struct, publish) returns string(postid)
metaWeblog.editPost (postid, username, password, struct, publish) returns true
metaWeblog.getPost (postid, username, password) returns struct(blog content)
'''
&lt;/pre&gt;

&lt;pre class="brush: python"&gt;
#edit-to-wordpress
#coding: utf-8
import xmlrpc.client
import datetime
import os

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python
    # 用跳行符號分割
    data_list = data.split("\n")
    #第2行為 title
    title= data_list[1]
    #第3行為 category
    category = data_list[2]
    #第4行為 tags
    tags = data_list[3]
    # 有多項資料的 content 型別為數列
    # 再將第7行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[6:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 &lt;!-more-&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    content = content.replace('~~~python', '[code lang="python"]')
    content = content.replace('~~~', '[/code]')
    return title, category, tags, content

os.environ['TZ'] = 'Asia/Taipei'

#################################
filepath = "/home/amd/Desktop/your_wordpress_account_and_password.txt"
wordpress = "your-wordpress-site-url"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################
wp_blogid = "0"

status_draft = 0
status_published = 1

server = xmlrpc.client.ServerProxy(wp_url)

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 指定時間出版
'''
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime("2013-01-01 00:00",
"%Y-%m-%d %H:%M"))
'''
# 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \
datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),"%Y-%m-%d %H:%M"))
categories = [category_str.split(":")[1]]
# 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料
tags = tags_str.split(":")[1].split(",")
data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags}

# 設法取得原 post 的 id
origin_post = p.getLastChild()
# 直接從標題取得 post 的 id 號碼
post_id = origin_post.h
status = server.metaWeblog.editPost(post_id, wp_username, wp_password, data, status_published)

if status:
    g.es("資料已經更新!")
else:
    g.es("有問題, 資料沒有更新!")
'''
其他 metaWeblog 的用法:
metaWeblog.newPost (blogid, username, password, struct, publish) returns string(postid)
metaWeblog.editPost (postid, username, password, struct, publish) returns true
metaWeblog.getPost (postid, username, password) returns struct(blog content)
'''
&lt;/pre&gt;

&lt;pre class="brush: python"&gt;
#get-from-wordpress
#coding: utf-8
import xmlrpc.client
# 導入 html 模組, 使用 html.unescape 轉換 html 特殊符號
import html

#################################
filepath = "/home/amd/Desktop/your_wordpress_account_and_password.txt"
wordpress = "your-wordpress-site-url"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

# 從網誌節點的 parent().h 取得 wp_url
# 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑
wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################

server = xmlrpc.client.ServerProxy(wp_url)

# 設法透過上述網誌網址, 帳號與密碼, 以及文章 id, 取回 categories, tags, 文章標題, 文章內容等資

# 從最後的 child 節點來取 post_id
origin_post = p.getLastChild()
post_id = origin_post.h
# 取回與 post_id 對應的網誌文章內容
blog_content = server.metaWeblog.getPost(post_id, wp_username, wp_password)
title = blog_content["title"]
# 這裡要利用 html.unescape 轉回特殊符號
description = html.unescape(blog_content["description"])
mt_text_more = html.unescape(blog_content["mt_text_more"])
if mt_text_more != "":
    post_content = description + "\n&lt;!--more--&gt;\n"+mt_text_more
else:
    post_content = description
# 所取回的 categories 為 list
categories = blog_content["categories"]
# 所取回的 tags 為以逗點隔開的字串
mt_keywords = blog_content["mt_keywords"]
# 取回文章作者
author = blog_content["wp_author_display_name"]
p.h = title
categories_str = ""
for category in categories:
    # 假如不是最後一個
    if category != categories[len(categories)-1]:
        categories_str += category + ", "
    else:
        # 這是最後一個
        categories_str += category
line1 = "@language md\n"
line2 = "Title: " +title + "\n"
line3 = "Category: " + categories_str + "\n"
line4 = "Tags: " + mt_keywords + "\n"
line5 = "Author: " + author + "\n@others\n"
post_content = post_content.replace('&lt;!--more--&gt;', '\n&lt;!-- PELICAN_END_SUMMARY --&gt;\n')
post_content = post_content.replace('[code lang="python"]', '~~~python')
post_content = post_content.replace('[/code]', '~~~')
p.b = line1 + line2 + line3 + line4 + line5 + post_content + "\n"
# 因為節點資料更新, commander 必須 redraw
c.redraw() 
g.es("資料已經取回")
&lt;/pre&gt;</summary><category term="CADLAB"></category><category term="Pelican"></category><category term="Leo Editor"></category></entry><entry><title>CADLab 機械設計系網路配置圖</title><link href="http://cadlab.mde.tw/post/cadlab-ji-jie-she-ji-xi-wang-lu-pei-zhi-tu.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/cadlab-ji-jie-she-ji-xi-wang-lu-pei-zhi-tu.html</id><summary type="html">&lt;p&gt;我們正在使用 Python3 與 &lt;a href="http://blockdiag.com/en/"&gt;http://blockdiag.com/en/&lt;/a&gt; 中的 nwdiag 工具繪製機械設計工程系的網路配置圖.&lt;/p&gt;


&lt;p&gt;從 &lt;a href="http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-de-biao-da-ji-shu-ling-yu-yu-kao-liang-ceng-mian.html"&gt;機械設計專題的表達、技術領域與考量層面&lt;/a&gt; 範例, 可以了解利用文字描述轉成 2D 流程圖, 具有容易修改維護的優點, 這裡運用相同的概念, 嘗試利用類似的 nwdiag 工具, 畫出整個系的網路配置圖.&lt;/p&gt;
&lt;p&gt;blockdiag 與 nwdiag 若能夠搭配全球資訊網路上的 Python3 wsgi 程式, 採用資料庫系統來管理機械設計工程系的網路資源配置, 將可以實際納為&lt;a href="http://chiamingyen.github.io/kmolab/blog/tag/wang-ji-nei-rong-guan-li.html"&gt;網際內容管理&lt;/a&gt;課程的教材.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://cad-lab.github.io/cadlab_data/files/mde_network_diag.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;上述 CADLab 網路配置圖對應的 nwdiag 描述文件:&lt;/p&gt;
&lt;pre class="brush: bash;"&gt;
nwdiag {
    default_fontsize = 15;
    校主幹 [shape = cloud];
    校主幹 -- 系路由器;

    network 系主幹{
        address = "140.130.17.0/24";
        系路由器 [address="140.130.17.254"];
        雲端點名網路;
        八樓集線器 [address="140.130.17.82"];
        七樓集線器;
        六樓集線器;
        系伺服器群;
    }

    network 八樓主幹{
        address="17.10-82"
        八樓集線器 [address="140.130.17.82"];
        老師1伺服器群 [address="140.130.17.10-15"];
        老師2伺服器群 [address="140.130.17.16-25"];
        老師3伺服器群 [address="140.130.17.26-60"];
    }

    network CAD_CAE{
        address="17.83";
        八樓集線器 [address="140.130.17.82"];
        CAD_NAT [address="140.130.17.82"];
        CAE_NAT [address="140.130.17.83"];
    }

    network 電腦輔助設計室{
        address="192.168.1.0/24";
        CAD_NAT [address="192.168.1.1"];
        CAD1 [address=".2"];
        CAD2;
        CAD64 [address=".100"];
    }

    network 電腦輔助繪圖室{
        address="192.168.1.0/24";
        CAE_NAT [address="192.168.1.1"];
        CAE1 [address=".2"];
        CAE2;
        CAE64 [address=".100"];
    }

    network 七樓主幹{
        address="140.130.17.83-90"
        七樓集線器;
        老師4伺服器群 [address="140.130.17.61-63"];
        老師5伺服器群 [address="140.130.17.64-70"];
        老師6伺服器群 [address="140.130.17.71-75"];
    }

    network 六樓主幹{
        address="140.130.17.91-100"
        六樓集線器;
        老師7伺服器群 [address="140.130.17.76-78"];
        老師8伺服器群 [address="140.130.17.79-80"];
        老師9伺服器群 [address="140.130.17.81-95"];
    }
}
&lt;/pre&gt;</summary><category term="CADLAB"></category><category term="Network Diagram"></category></entry><entry><title>Gigabit 乙太網路線</title><link href="http://cadlab.mde.tw/post/gigabit-yi-tai-wang-lu-xian.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/gigabit-yi-tai-wang-lu-xian.html</id><summary type="html">&lt;p&gt;目前在 CADLab 中使用的網路線為傳輸速率每秒十億 bit (10**9 bit/sec) 的 Category 6 Gigabit Ethernet. 採 1000BASE‑T 無遮蔽雙絞線, 以 EIA/TIA 568B 連接 RJ45 接頭. 其接線方式為接頭向前, 耳朵朝下, 混白線在前, 緊接著色線, 以橘藍綠棕排列後,  再將藍白與綠白對調, 就是 568B 的接法.&lt;/p&gt;


&lt;p&gt;至於 568B 的網路跳線則再將一邊的橘白與橘線, 跟綠白與綠線對調. 因為橘白線的 pin 1 為 Transmit Data+, 橘線 pin2 則是 Transmit Data-, 綠白線 pin3 則為 Receive Data+, 綠線 pin 6 為 Receive Data-. 藍線 pin 4 與棕白 pin 7 同為 Bi-directional+, 而藍白線 pin5 與棕線 pin 8 則同為 Bi-directional-. 為了達到規格中的 Gigabit 傳輸速度, 8 條線都要確實連接, 假如只有 pin 1, 2, 3, 6 接線, 則傳輸速度將會降為 100 Mega bit/sec. 另外, 1000BASE‑T 的無遮蔽雙絞銅線, 建議每段最長為 100 m.&lt;/p&gt;
&lt;p&gt;EIA/TIA 568B 的標準雙絞線 (兩端採相同色線排列)
腳位: 接頭朝前, 耳朵朝下 (橘藍綠棕, 白線在前, 排好後, 藍白與綠白對調)
顏色: 橘白-橘-綠白-藍-藍白-綠-棕白-棕&lt;/p&gt;
&lt;p&gt;Cross Over (EIA/TIA 568B) 線 (一端採標準 EIA/TIA 568B 色線排列, 另一端則將綠線與橘線對調)
腳位: 接頭朝前, 耳朵朝下
顏色: 綠白-綠-橘白-藍-藍白-橘-棕白-棕 (即將上面正常線的橘線與綠線對調)&lt;/p&gt;
&lt;p&gt;最後, 假如要利用 Raspberry Pi 3 打造成為 Wifi 的 Access Point, 可以參考 &lt;a href="http://blog.itist.tw/2016/03/using-raspberry-pi-3-as-wifi-ap-with-raspbian-jessie.html"&gt;http://blog.itist.tw/2016/03/using-raspberry-pi-3-as-wifi-ap-with-raspbian-jessie.html&lt;/a&gt; 與 &lt;a href="http://raspberry-at-home.com/hotspot-wifi-access-point/"&gt;http://raspberry-at-home.com/hotspot-wifi-access-point/&lt;/a&gt; 與 &lt;a href="https://frillip.com/using-your-raspberry-pi-3-as-a-wifi-access-point-with-hostapd/"&gt;https://frillip.com/using-your-raspberry-pi-3-as-a-wifi-access-point-with-hostapd/&lt;/a&gt;&lt;/p&gt;</summary><category term="CADLAB"></category></entry><entry><title>電腦輔助設計室網路連線管理</title><link href="http://cadlab.mde.tw/post/dian-nao-fu-zhu-she-ji-shi-wang-lu-lian-xian-guan-li.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/dian-nao-fu-zhu-she-ji-shi-wang-lu-lian-xian-guan-li.html</id><summary type="html">&lt;p&gt;電腦輔助設計室長期以來都是在 IPV4 的架構下, 透過 NAT, 以共用一個網路位址上網, 若以整間教室 63 台電腦為例, 只需要設法利用 9 個固定的 IPV4 網路位址, 讓其中的 9 台電腦同時支援 IPV4 與 IPV6 協定, 並且透過 Squid 代理伺服器的設定, 就可以利用網路負載平衡, 大幅提升用戶的連網速度.&lt;/p&gt;


&lt;p&gt;自 2012 年起校園主幹就已經全面支援 IPV6 的網路協定, 但是由於台灣大部份的網站仍然只提供 IPV4 網址與協定連線, 因此即使在 IPV6 網址無虞的情況下, 讓每一台電腦輔助設計室的電腦都透過 IPV6 協定取得網址, 仍然需要 IPV4/IPV6 雙支援的代理主機, 才能連結使用所有的網站.&lt;/p&gt;
&lt;p&gt;因此目前的規劃是, 讓 63 台電腦全部透過 IPV6 協定取得 IP 位址上網, 但是其中的 9 台電腦則以其中規劃好的第3磁區 Ubuntu Server 開機 (其他兩個開機磁區分別為 Windows 7 與 Windows 10), 而且這 9 台電腦是在預先綁定 MAC 位址到雙支援 IPV4/IPV6 的固定 IP 情況下, 自行透過 DNS 設定, 以 Round Robin 的簡單負載平衡, 來服務其他僅設定 IPV6 DHCP Client 連線的電腦.&lt;/p&gt;
&lt;p&gt;其次, 學員自行攜入 CADLab 使用的 Raspberry Pi 3 隨身卡片電腦, 也可以利用 IEEE 802.11n 的協定取得 IPV6 位址, 然後也是透過雙支援的代理伺服器連線上網. 而使用 git 相關指令之前, 必須確定已經設定&lt;/p&gt;
&lt;p&gt;git config --global http.proxy http://myproxy.server:port&lt;/p&gt;
&lt;p&gt;git config --global https.proxy https://myproxy.server:port&lt;/p&gt;</summary><category term="CADLAB"></category><category term="Ｎetwork"></category><category term="IPV6"></category></entry><entry><title>該如何編寫一份電腦輔助機械設計使用手冊</title><link href="http://cadlab.mde.tw/post/gai-ru-he-bian-xie-yi-fen-dian-nao-fu-zhu-ji-jie-she-ji-shi-yong-shou-ce.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/gai-ru-he-bian-xie-yi-fen-dian-nao-fu-zhu-ji-jie-she-ji-shi-yong-shou-ce.html</id><summary type="html">&lt;p&gt;我們正在極力推廣使用的電腦輔助機械設計(Mechanical Computer Aided Design)相關套件, 包括 OnShape, Solvespace, FreeCAD, Elmer, V-rep 以及 Jupyter, 該如何用最"好"的方式來編寫使用手冊?&lt;/p&gt;


&lt;p&gt;假如您已經在使用 OnShape, 一定已經看過 &lt;a href="https://cad.onshape.com/help/"&gt;https://cad.onshape.com/help/&lt;/a&gt;. 對應的 Solvespce 導引 &lt;a href="http://solvespace.com/tutorial.pl"&gt;http://solvespace.com/tutorial.pl&lt;/a&gt; 也是很不錯, 其他的幾個套件, 也都已經有了不錯的英文導引資料, 只是從教導學員協力完成某件電腦輔助設計流程工作的同時, 我們想要試試在 Github 的版次管理模式下, 我們能夠怎樣協同編寫一份電腦輔助設計相關的網頁式手冊.&lt;/p&gt;
&lt;p&gt;啟動:&lt;/p&gt;
&lt;p&gt;在 Github cad-lab 帳號下新增一個倉儲, 命名為 manual, 然後 git clone 到本地端, 準備置入能夠協同編輯的 Leo Editor 與 Pelican 架構.&lt;/p&gt;
&lt;p&gt;git clone https://github.com/cad-lab/manual.git cadlabmanual 之後, 進入 cadlabmanual 目錄, 利用 git branch gh-pages 建立 Github Pages 對應分支, 然後以 git checkout gh-pages 指令將本地端倉儲的工作目錄定位在 gh-pages 分支.&lt;/p&gt;
&lt;p&gt;接下來就是放入 Pelican 靜態網頁系統, 就可以開始建立電腦輔助機械設計使用手冊了: &lt;a href="http://cad-lab.github.io/manual/"&gt;http://cad-lab.github.io/manual/&lt;/a&gt;&lt;/p&gt;</summary><category term="CADLAB"></category><category term="Ｍanual"></category><category term="MCAD"></category></entry><entry><title>CADLab CAD/E 軟體套件使用建議</title><link href="http://cadlab.mde.tw/post/cadlab-cade-ruan-ti-tao-jian-shi-yong-jian-yi.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/cadlab-cade-ruan-ti-tao-jian-shi-yong-jian-yi.html</id><summary type="html">&lt;p&gt;電腦輔助設計與工程分析是機械設計工程師進行 2D/3D 繪圖與理論分析表達的重要工具, 這裡是我們建議學員使用的 CAD/CAE 軟體套件.&lt;/p&gt;


&lt;h2&gt;CAD:&lt;/h2&gt;
&lt;p&gt;商用封閉單機套件:&lt;/p&gt;
&lt;p&gt;SolidWorks 與 PTC Creo&lt;/p&gt;
&lt;p&gt;雲端封閉套件(提供免費使用方案):&lt;/p&gt;
&lt;p&gt;Onshape: &lt;a href="http://onshape.com"&gt;http://onshape.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自由開源套件:&lt;/p&gt;
&lt;p&gt;Solvespace: &lt;a href="http://solvespace.com/"&gt;http://solvespace.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;FreeCAD: &lt;a href="http://www.freecadweb.org/"&gt;http://www.freecadweb.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;CAE:&lt;/h2&gt;
&lt;p&gt;商用封閉套件:&lt;/p&gt;
&lt;p&gt;ansys 與 comsol&lt;/p&gt;
&lt;p&gt;自由開源套件:&lt;/p&gt;
&lt;p&gt;Elmer: &lt;a href="https://www.csc.fi/web/elmer"&gt;https://www.csc.fi/web/elmer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Kratos: &lt;a href="http://www.cimne.com/kratos"&gt;http://www.cimne.com/kratos&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;數值運算:&lt;/h2&gt;
&lt;p&gt;商用封閉套件:&lt;/p&gt;
&lt;p&gt;Matlab 與 Mathematica&lt;/p&gt;
&lt;p&gt;自由開源套件:&lt;/p&gt;
&lt;p&gt;Jupyter: &lt;a href="http://jupyter.org/"&gt;http://jupyter.org/&lt;/a&gt;&lt;/p&gt;</summary><category term="CADLAB"></category><category term="CAX"></category></entry><entry><title>CADLab 學員卡片電腦規格與應用</title><link href="http://cadlab.mde.tw/post/cadlab-xue-yuan-qia-pian-dian-nao-gui-ge-yu-ying-yong.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/cadlab-xue-yuan-qia-pian-dian-nao-gui-ge-yu-ying-yong.html</id><summary type="html">&lt;p&gt;卡片電腦 (credit-card sized computer) 的盛行, 除了在操作系統上有機會讓 CADLab 的學員, 得以學習 Windows 10 以外的應用, 最大的功用, 是讓機械設計工程專長的學員能夠實際動手, 理解網路的整合, 並且迎接自造 (self-manufacturing) 時代的蒞臨.&lt;/p&gt;


&lt;h2&gt;Raspberry Pi 3 電腦&lt;/h2&gt;
&lt;p&gt;當一間嚴格管理, 軟硬體配置僵化的 CADLab 電腦輔助設計室已經無法滿足現代機械設計科技人才的培育使用時, 導入以 &lt;a href="https://www.raspberrypi.org/products/raspberry-pi-3-model-b/"&gt;Raspberry Pi 3 Model B&lt;/a&gt; 為基礎的個人隨身卡片電腦, 應該是個不錯的選擇.&lt;/p&gt;
&lt;p&gt;2016 年 2 月份推出的這一片採用 1.2GHz 64-bit quad-core ARMv8 CPU 的小卡片電腦, 不僅能夠用來控制 &lt;a href="http://delta.firepick.org/"&gt;http://delta.firepick.org/&lt;/a&gt;, 可以安裝執行 &lt;a href="https://github.com/jupyter/jupyterhub"&gt;Jupyter hub&lt;/a&gt;, 而且在 &lt;a href="https://www.raspberrypi.org/downloads/noobs/"&gt;Noobs&lt;/a&gt; 操作系統套件中, 還&lt;a href="https://www.raspberrypi.org/blog/mathematica-10/"&gt;內建&lt;/a&gt;免費的非營利版 Mathematica.&lt;/p&gt;
&lt;p&gt;以下是我們建議學員自備的 Raspberry Pi 3 Model B 卡片電腦規格:&lt;/p&gt;
&lt;p&gt;處理器:&lt;/p&gt;
&lt;p&gt;Broadcom BCM2387 晶片組，1.2GHz 四核心 ARM Cortex-A53.802.11 b/g/n 無線 LAN 和藍牙 4.1&lt;/p&gt;
&lt;p&gt;GPU:&lt;/p&gt;
&lt;p&gt;雙核心 VideoCore IVR 多媒體協同處理器。提供 Open GL ES 2.0、硬體加速 OpenVG，以及 1080p30 H.264 高型解碼。支援 1Gpixel/s、1.5Gtexel/s 或 24GFLOPs，並具備材質過濾功能與 DMA 基礎架構&lt;/p&gt;
&lt;p&gt;記憶體:&lt;/p&gt;
&lt;p&gt;1GB LPDDR2&lt;/p&gt;
&lt;p&gt;作業系統:&lt;/p&gt;
&lt;p&gt;由 Micro SD 記憶卡(建議使用 32 GB 以上) 啟動，建議安裝 Raspbian 操作系統&lt;/p&gt;
&lt;p&gt;尺寸:&lt;/p&gt;
&lt;p&gt;85 x 56 x 17mm&lt;/p&gt;
&lt;p&gt;電源:&lt;/p&gt;
&lt;p&gt;Micro USB 插槽 5V1，2.5A&lt;/p&gt;
&lt;h2&gt;Raspbian 安裝配置&lt;/h2&gt;
&lt;p&gt;當學員拿到 Raspberry Pi 3 卡片電腦之後, 首次配置時, 建議使用 CADLab 教室中的 HDMI 線連接到支援 HDMI 的電腦螢幕後, 進行 &lt;a href="https://www.raspberrypi.org/downloads/raspbian/"&gt;Raspbian&lt;/a&gt; 操作系統的安裝, 安裝後則必須開啟 SSH 的連線, 並且編輯 /etc/lightdm/lightdm.conf 設定檔, 將 [XDMCPServer] 項下的 enabled 設為 true.&lt;/p&gt;
&lt;h2&gt;CADLab 卡片電腦使用情境&lt;/h2&gt;
&lt;p&gt;完成 Raspbin 系統安裝後, Raspberry Pi 3 電腦在 CADLab 教室使用, 共有兩種基本情境:&lt;/p&gt;
&lt;h3&gt;連接滑鼠鍵盤螢幕開機&lt;/h3&gt;
&lt;p&gt;目前的 CADLab 電腦配置, USB 鍵盤與滑鼠的接頭是採隱藏式保護, 因此學員無法直接以公用的滑鼠與鍵盤連接 Raspberry Pi 3 卡片電腦, 但是若新配置的新電腦設備允許學員使用公用的 USB 鍵盤與滑鼠, 並且提供支援 HDMI 格式的電腦螢幕, 用戶就可以很單純直接用自行攜入的 Raspberry Pi 3 開機使用. 開機後, 可以透過 CADLab 中的 Wifi 連線 (Raspberry Pi 3 Model B 內建 802.11n Wireless LAN) 或實體線 (每桌必須提供 4 或 8 port hub) 上網, 使用較為簡單.&lt;/p&gt;
&lt;h3&gt;無滑鼠鍵盤螢幕開機&lt;/h3&gt;
&lt;p&gt;若新配置的 CADLab  電腦設備並不允許學員使用公用的滑鼠與鍵盤, 且桌上並無 hub 可用, 則建議 Raspberry Pi 3 使用者, 可以自帶一條網路跳線, 利用桌上型電腦的多 NIC 連線, 以 &lt;a href="https://sourceforge.net/projects/dhcpserver/"&gt;https://sourceforge.net/projects/dhcpserver/&lt;/a&gt; 發給 Raspberry Pi 3 電腦臨時的內部網路 IP, 然後再利用 &lt;a href="https://sourceforge.net/projects/xming/"&gt;https://sourceforge.net/projects/xming/&lt;/a&gt;, 以 XDMCP 協定 (只建議在內部網路使用, 廣域網路上, 建議採較安全的 SSH 連線), 登入 Raspberry Pi 3, 並且以 Wifi 連線到 CADLab 的 Access Point 後, 確定連線的 IP 位址後, 就可以移除與桌上型電腦的網路跳線, 改採與桌上型電腦同位階的內部網路上網, 然後透過桌上型電腦的 Putty, 以 SSH 連線到 Raspberry Pi 3 進行操控, 或者再透過 xming, 以 XDMCP 協定登入.&lt;/p&gt;
&lt;p&gt;另外, 假如 Raspberry Pi 3 電腦並無與電腦教室其他電腦設備連線的要求, 用戶希望利用網路跳線與桌機相連後上網, 則建議在桌機上使用代理程式 &lt;a href="http://www.youngzsoft.net/ccproxy/"&gt;http://www.youngzsoft.net/ccproxy/&lt;/a&gt; 的免費版 (可以3個用戶使用), 讓 Raspberry pi 3 電腦以桌機的 proxy server 上網, 或者設法將桌上型電腦 Windows 7 或 10 操作系統上的第2片網路卡橋接到第1片已經上網的網卡上, Raspberry Pi 3 就可以藉此設定直接上網.&lt;/p&gt;</summary><category term="CADLAB"></category><category term="raspberrypi"></category></entry><entry><title>CADLab 網路配線繪圖</title><link href="http://cadlab.mde.tw/post/cadlab-wang-lu-pei-xian-hui-tu.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/cadlab-wang-lu-pei-xian-hui-tu.html</id><summary type="html">&lt;p&gt;利用程式方法執行網路配線繪圖&lt;/p&gt;


&lt;p&gt;CADLab 中的網路配線圖, 就如同 &lt;a href="http://blockdiag.com/en/"&gt;http://blockdiag.com/en/&lt;/a&gt; 專案所示, 可以利用語法描述參數與配置之後, 透過程式方法轉出結果.&lt;/p&gt;
&lt;p&gt;以 nwdiag &lt;a href="https://bitbucket.org/blockdiag/nwdiag"&gt;https://bitbucket.org/blockdiag/nwdiag&lt;/a&gt; 為例, 在只有 Python3 的 Windows 環境中安裝:&lt;/p&gt;
&lt;p&gt;pip install nwdiag&lt;/p&gt;
&lt;p&gt;之後就可以利用 nwdiag 命令解讀 .diag network diagram 描述檔, 並且轉為 png 或 svg 格式.&lt;/p&gt;
&lt;p&gt;假如是在同時裝有 Python2 與 Python3 的 Ubuntu 環境中安裝 nwdiag:&lt;/p&gt;
&lt;p&gt;pip3 install nwdiag&lt;/p&gt;
&lt;p&gt;之後的應用與 Windows 環境相同.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blockdiag.com/en/"&gt;http://blockdiag.com/en/&lt;/a&gt; 專案還有方塊圖 blockdiag, 序列圖 seqdiag 以及活動圖 actdiag 等相關繪圖的應用.&lt;/p&gt;
&lt;p&gt;最後假如 CADLab 希望利用 Sphinx 來整理電腦輔助設計室的文件, 則可以套用 &lt;a href="https://github.com/blockdiag"&gt;https://github.com/blockdiag&lt;/a&gt; 中的 extensions 工具.&lt;/p&gt;</summary><category term="CADLAB"></category><category term="network"></category></entry><entry><title>Cadlab 的理想設置</title><link href="http://cadlab.mde.tw/post/cadlab-de-li-xiang-she-zhi.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/cadlab-de-li-xiang-she-zhi.html</id><summary type="html">&lt;p&gt;一個符合二十一世紀工學院實際需求的電腦輔助設計室, 應該如何規劃配置?&lt;/p&gt;


&lt;p&gt;Cadlab 是個熱門的名詞, 代表 Computer Aided Design Laboratory, 也就是電腦輔助設計實驗室, 或簡稱電腦輔助設計室.&lt;/p&gt;
&lt;p&gt;過去的電腦輔助設計室, 充滿各種讓使用者進行電腦輔助設計的公用電腦, 加上部份伺服器提供相關設計運算或資料儲存之用, 而現在, 這樣的配置可能不再恰當, 尤其是一間配置著 60 幾台最新硬體的桌上型電腦, 但卻採用所謂的防寫卡進行硬碟保護的電腦, 倘若無法隨時配合著經常性的操作系統或應用軟體更新, 這樣的 Cadlab 配置, 更是錯上加錯.&lt;/p&gt;
&lt;p&gt;其實, 二十一世紀的工學院, 所有課程都應該在數位網路環境中進行, 因此所有這些所謂未來的工程師, 就應該在入學的第1天就被配予一台 17 寸的筆記型電腦, 而且裝載著各種未來幾年甚至離開學校之後, 都還能夠合法使用的相關專業用軟硬體套件.&lt;/p&gt;
&lt;p&gt;過去, 由於全球協同的步調較慢, 各種產品的生命週期時間較長, 因此允許學校與產業界的差異性容忍度較大, 但是, 近幾年在在各種資訊與通訊軟硬體的快速發展衝擊下, 不僅全球協同的步調加速, 各種產品的生命週期愈來愈短, 促使學校教育單位與產業界必須在某些層面上攜手同步, 否則終將無法培育出適才、適所與適任的未來工程師.&lt;/p&gt;
&lt;p&gt;而且, 隨著可攜裝置與自造軟硬體的逐步普及, Cadlab 配置中的所謂電腦, 除了包括讓工程師可以隨身攜帶的筆記型電腦以外, 還必須包括各類微控制器與 3D 印表機, 讓 Cadlab 實驗室中的各種系統模擬, 可以透過初步的硬體原型測試基本的可行性.&lt;/p&gt;</summary><category term="CADLAB"></category></entry><entry><title>KMOL 2016 Spring Portable Tool</title><link href="http://cadlab.mde.tw/post/kmol-2016-spring-portable-tool.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/kmol-2016-spring-portable-tool.html</id><summary type="html">&lt;p&gt;針對 cadlab 上計算機程式、網際內容管理、電腦輔助設計實習與協同產品設計實習等課程, 採用 Python 3.4 打造的 Windows 版可攜程式套件&lt;/p&gt;


&lt;p&gt;可攜套件倉儲:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/chiamingyen/kmol2016"&gt;https://github.com/chiamingyen/kmol2016&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;kmol2016 下載:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://my.pcloud.com/publink/show?code=XZH5J4ZOj9C9aomi5F1DtnuQNIHYLDO7EjX"&gt;https://my.pcloud.com/publink/show?code=XZH5J4ZOj9C9aomi5F1DtnuQNIHYLDO7EjX&lt;/a&gt;&lt;/p&gt;</summary><category term="可攜套件"></category><category term="2016Spring"></category></entry><entry><title>Bezier 曲線導引</title><link href="http://cadlab.mde.tw/post/bezier-qu-xian-dao-yin.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/bezier-qu-xian-dao-yin.html</id><summary type="html">&lt;p&gt;A primer on Bezier curves&lt;/p&gt;


&lt;p&gt;&lt;a href="http://pomax.github.io/bezierinfo/"&gt;http://pomax.github.io/bezierinfo/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pomax.github.io/bezierjs/"&gt;http://pomax.github.io/bezierjs/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;嘗試將純 Javascript 的環境轉為 Brython based &lt;a href="https://github.com/brython-dev/brython"&gt;https://github.com/brython-dev/brython&lt;/a&gt;, 希望完成之後, 可以讓使用者編寫 Python3 程式碼來操控 Bezier 曲線 &lt;a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve"&gt;https://en.wikipedia.org/wiki/B%C3%A9zier_curve&lt;/a&gt;.&lt;/p&gt;</summary><category term="Javascript"></category><category term="程式"></category></entry><entry><title>導入 Ubuntu 操作系統</title><link href="http://cadlab.mde.tw/post/dao-ru-ubuntu-cao-zuo-xi-tong.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/dao-ru-ubuntu-cao-zuo-xi-tong.html</id><summary type="html">&lt;p&gt;身為一位機械設計工程系的學生, 有機會在 Ubuntu 操作系統上工作嗎?&lt;/p&gt;


&lt;p&gt;自從 1995 年, 第1套能在 Windows 操作系統執行的電腦輔助機械設計繪圖軟體套件, SolidWorks, 出現, 並且逐步蔚為風潮之後,  MCAD (Mechanical Computer Aided Design) 中端套件, 幾乎都只能在 Windows 操作系統上運作. 許多機械設計工程系相關師生, 幾乎早已經忘記, 最早的 MCAD 系統可都是在泛 Unix based 的操作系統上運作.&lt;/p&gt;
&lt;p&gt;時間轉到 2015 年, Onshape: &lt;a href="http://www.onshape.com"&gt;http://www.onshape.com&lt;/a&gt; 的出現, 雖然截至目前只提供陽春的 MCAD 功能, 但是至少讓原本必須在 Windows 操作系統上才能上課的約束條件, 頓時消失, 因為計算機程式、網際內容管理、電腦輔助設計實習與協同產品設計實習等課程, 已經能夠百分之百在 Ubuntu 操作系統上運作.&lt;/p&gt;
&lt;p&gt;過去, 我們在 Windows 操作系統上的工作類別, 不外乎:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文書處理&lt;/li&gt;
&lt;li&gt;程式編寫與執行&lt;/li&gt;
&lt;li&gt;MCAD 零件繪圖, 零件組立&lt;/li&gt;
&lt;li&gt;MCAE 工程分析&lt;/li&gt;
&lt;li&gt;擷取執行畫面&lt;/li&gt;
&lt;li&gt;錄製操作流程影片&lt;/li&gt;
&lt;li&gt;遠端登入到其他電腦 (Remote Desktop)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下將就這些工作分類, 介紹在 Ubuntu 操作系統中的相對應工具與使用方法.&lt;/p&gt;
&lt;p&gt;首先, 這裡建議的 Ubuntu 操作系統為 Ubuntu Server 版本加上 ubuntu-desktop 套件的安裝.&lt;/p&gt;
&lt;p&gt;一旦安裝完成, 第1項文書處理工作就可以由 LibreOffice 套件加以勝任.&lt;/p&gt;
&lt;h2&gt;程式編寫與執行&lt;/h2&gt;
&lt;p&gt;這裡包含 Python3, PyQt5, Leo Editor, SciTE, Git 等套件都是跨操作系統, 其中 Python3  已經內建在 Ubuntu 14.04 操作系統中, 只是必須透過 python3 執行, 例如: 必須在命令列中, 輸入 python3 帶出互動式解譯環境.&lt;/p&gt;
&lt;p&gt;pip3 模組則需要透過 sudo apt-get install python3-pip 安裝&lt;/p&gt;
&lt;p&gt;PyQt5 則需要透過 sudo apt-get install python3-pyqt5 安裝&lt;/p&gt;
&lt;p&gt;Leo Editor 透過 sudo pip3 install https://github.com/leo-editor/leo-editor/archive/master.zip 安裝, 並且以 leo&amp;amp; 呼叫&lt;/p&gt;
&lt;p&gt;SciTE 透過 sudo apt-get install scite 安裝&lt;/p&gt;
&lt;p&gt;git 透過 sudo apt-get install git 安裝&lt;/p&gt;
&lt;h2&gt;MCAD 零件與組件繪圖&lt;/h2&gt;
&lt;p&gt;這裡採用 &lt;a href="http://www.onshape.com"&gt;http://www.onshape.com&lt;/a&gt;, 只需要 Firefox 或 Chromium 瀏覽器就可以運作&lt;/p&gt;
&lt;p&gt;FreeCAD: &lt;a href="http://www.freecadweb.org/"&gt;http://www.freecadweb.org/&lt;/a&gt; 與 Solvespace: &lt;a href="http://solvespace.com/"&gt;http://solvespace.com/&lt;/a&gt;, 則是能在 Ubuntu 環境運作的 MCAD 套件.&lt;/p&gt;
&lt;h2&gt;MCAE 工程分析&lt;/h2&gt;
&lt;p&gt;這裡採用 &lt;a href="http://www.simscale.com"&gt;http://www.simscale.com&lt;/a&gt;, 只需要 Firefox 或 Chromium 瀏覽器就可以運作&lt;/p&gt;
&lt;p&gt;COMSOL &lt;a href="https://www.comsol.com/system-requirements"&gt;可以&lt;/a&gt;在 Ubuntu 環境中運作&lt;/p&gt;
&lt;p&gt;Ansys 則&lt;a href="http://www.ansys.com/-/media/Ansys/corporate/files/pdf/solutions/it-professionals/platform-support/platformsupportansys162stategyandplans.pdf?la=en"&gt;建議&lt;/a&gt;在 Red Hat 或 SUSE 商用版上運作&lt;/p&gt;
&lt;h2&gt;錄製操作流程影片&lt;/h2&gt;
&lt;p&gt;在 Ubuntu 操作系統中擷取電腦螢幕畫面, 只要按下 PrintScr 按鍵, 就可以直接存為 png 格式檔案&lt;/p&gt;
&lt;p&gt;操作流程則可以使用 Kazam 將過程錄成 mp4檔案&lt;/p&gt;
&lt;p&gt;Kazam: &lt;a href="https://code.launchpad.net/~kazam-team/kazam/stable"&gt;https://code.launchpad.net/~kazam-team/kazam/stable&lt;/a&gt; (以 Python 編寫)&lt;/p&gt;
&lt;p&gt;安裝:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
sudo add-apt-repository ppa:kazam-team/stable-series
sudo apt-get update
sudo apt-get install kazam
&lt;/pre&gt;

&lt;p&gt;使用: kazam&amp;amp;&lt;/p&gt;
&lt;p&gt;至於在 Ubuntu 遠端登入到 Windows, 可以使用 Ubuntu Software Center 安裝 remmina, 並且在連線設定上的 Advanced 頁面中, Security 選用 RDP 協定, 即可正確連線.&lt;/p&gt;
&lt;h2&gt;Ubuntu 檔案架構&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;/bin ­­ binary applications (most of your executable files) &lt;/li&gt;
&lt;li&gt;/boot ­­ files required to boot (such as the kernel, etc) &lt;/li&gt;
&lt;li&gt;/dev ­­ your devices (everything from drives to displays) &lt;/li&gt;
&lt;li&gt;/etc ­­ just about every configuration file for your system &lt;/li&gt;
&lt;li&gt;/etc/rc.d ­­ contains a number of shell scripts that are run on bootup at different run levels. &lt;/li&gt;
&lt;li&gt;/etc/X11 ­­ configuration files for the X Window system &lt;/li&gt;
&lt;li&gt;/home ­­ locally stored user files and folders &lt;/li&gt;
&lt;li&gt;/lib ­­ system libraries (similar to Program Files) &lt;/li&gt;
&lt;li&gt;/media ­­ mounted (or loaded) devices such as cdroms, digital cameras, etc. &lt;/li&gt;
&lt;li&gt;/mnt ­­ mounted file systems &lt;/li&gt;
&lt;li&gt;/opt ­­ location for “optionally” installed programs &lt;/li&gt;
&lt;li&gt;/sbin ­­ system ­only binaries&lt;/li&gt;
&lt;li&gt;/sys ­­ contains information about the system &lt;/li&gt;
&lt;li&gt;/tmp ­­ temporary files &lt;/li&gt;
&lt;li&gt;/usr ­­ applications mainly for regular users &lt;/li&gt;
&lt;li&gt;/var ­­ mainly logs, databases, etc. &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Ubuntu 常用指令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ls : list directory contents&lt;/li&gt;
&lt;li&gt;cd : Change Directory&lt;/li&gt;
&lt;li&gt;pwd : print the current/working directory&lt;/li&gt;
&lt;li&gt;mkdir : make/create directory&lt;/li&gt;
&lt;li&gt;rmdir : remove the empty directory&lt;/li&gt;
&lt;li&gt;rm : remove/delete file&lt;/li&gt;
&lt;li&gt;mv : rename or move a file/directory&lt;/li&gt;
&lt;li&gt;man : Manual pages for shell commands&lt;/li&gt;
&lt;li&gt;cp : Copy Files&lt;/li&gt;
&lt;li&gt;passwd : Change password for user&lt;/li&gt;
&lt;li&gt;tar : Creates and extracts files from a tape or disk archive&lt;/li&gt;
&lt;li&gt;find :  find searches the file located at /&lt;/li&gt;
&lt;li&gt;grep :  print lines matching a pattern&lt;/li&gt;
&lt;li&gt;chown :  change file owner and group&lt;/li&gt;
&lt;li&gt;chgrp :  change group ownership&lt;/li&gt;
&lt;li&gt;chmod :  change file mode bits&lt;/li&gt;
&lt;li&gt;ifconfig :  configure a network interface&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;參考資料:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://help.ubuntu.com/lts/serverguide/serverguide.pdf"&gt;https://help.ubuntu.com/lts/serverguide/serverguide.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://ecourts.nic.in/2/mannual/admin_manual.pdf"&gt;http://ecourts.nic.in/2/mannual/admin_manual.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://wiki.lib.sun.ac.za/images/7/7b/Ubuntu-desktop.pdf"&gt;http://wiki.lib.sun.ac.za/images/7/7b/Ubuntu-desktop.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://askubuntu.com/questions/154121/why-wont-remmina-connect-to-windows-7-remote-desktop"&gt;http://askubuntu.com/questions/154121/why-wont-remmina-connect-to-windows-7-remote-desktop&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Ubuntu"></category><category term="Mechanical Design"></category></entry><entry><title>電腦輔助設計室網誌開通</title><link href="http://cadlab.mde.tw/post/dian-nao-fu-zhu-she-ji-shi-wang-zhi-kai-tong.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>kmol</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/dian-nao-fu-zhu-she-ji-shi-wang-zhi-kai-tong.html</id><summary type="html">&lt;p&gt;機械設計工程系電腦輔助設計室 2016 Fall 電腦系統規劃.&lt;/p&gt;


&lt;p&gt;CADLab 是國立虎尾科技大學機械設計工程系, 綜一館八樓, 共配置 64 台 (9x7 加上老師一台) 個人電腦的教學實驗室.&lt;/p&gt;
&lt;h2&gt;網誌文章分類&lt;/h2&gt;
&lt;p&gt;本網站的文章分類暫定為:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;規劃 (Planning) - 規劃中的專案, 但是尚未完成之前的相關配置與架構設計紀錄&lt;/li&gt;
&lt;li&gt;導引 (Tutorial) - 已經完成的流程紀錄與心得感想&lt;/li&gt;
&lt;li&gt;資源 (Resources) - 配合上課需求所提供的各項內容服務&lt;/li&gt;
&lt;li&gt;參考 (References) - 紀錄其他相關類似教學實驗室的管理方法與現況了解&lt;/li&gt;
&lt;li&gt;其他 (Misc) - 未能納入上述其他分類的文章&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;磁區規劃&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;第1開機磁區為 &lt;a href="http://wincom.blob.core.windows.net/documents/Win10CompareTable.pdf"&gt;Windows 10 Pro 或 Education 64 位元版&lt;/a&gt;, 存放必須安裝才能啟動的應用程式&lt;/li&gt;
&lt;li&gt;第2開機磁區為 &lt;a href="http://wincom.blob.core.windows.net/documents/Win10CompareTable.pdf"&gt;Windows 10 Pro 或 Education 64 位元版&lt;/a&gt;, 存放無需安裝的綠色應用程式&lt;/li&gt;
&lt;li&gt;第3開機磁區為 &lt;a href="http://releases.ubuntu.com/16.04/"&gt;Ubuntu 16.04 LTS Server 版&lt;/a&gt;加裝 ubuntu-desktop&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;第1開機磁區&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;網路連線以 IPV4 設定為主&lt;/li&gt;
&lt;li&gt;若有部份教學程式無法在 &lt;a href="http://wincom.blob.core.windows.net/documents/Win10CompareTable.pdf"&gt;Windows 10 Pro 或 Education 64 位元版&lt;/a&gt;操作系統中啟動, 將建議在 &lt;a href="https://www.virtualbox.org/"&gt;Virtualbox&lt;/a&gt; 中, 安裝 &lt;a href="http://windows.microsoft.com/zh-tw/windows/lifecycle"&gt;Windows 7 Professional&lt;/a&gt; 環境中使用&lt;/li&gt;
&lt;li&gt;由於仍需透過 NAT 轉址, 64 台電腦將共用一個對外 IP, 為提升連線速度, 將在系主幹建立四台代理主機, 由上課老師選擇使用&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;第2開機磁區&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;網路連線以 IPV4 設定為主, 並以 IPV6 為輔&lt;/li&gt;
&lt;li&gt;當網路連線採 IPV6 上網後, 每一排特定電腦將以第3磁區開機 (共需要 9 個固定 IPV4  IP 位址), 並預先設定為 IPV4/IPV6 雙支援協定, 並啟動 &lt;a href="https://help.ubuntu.com/lts/serverguide/squid.html#squid-installation"&gt;Proxy Server&lt;/a&gt;, 其餘 55 台電腦將透過代理主機連線上網&lt;/li&gt;
&lt;li&gt;本磁區中的所有應用程式將以可攜方式配置, 無需安裝, 並同時提供支援 Ubuntu 或其他 Linux 操作系統中的對應版本&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;第3開機磁區&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;網路連線將以 IPV6 為主, 其中 9 台電腦將額外設置同時支援 IPV4/IPV6, 以便當作 &lt;a href="https://help.ubuntu.com/lts/serverguide/squid.html#squid-installation"&gt;Proxy Server&lt;/a&gt;, 讓其他純 IPV6 連線電腦可以連接純 IPV4 協定主機&lt;/li&gt;
&lt;li&gt;由於本磁區無法受還原卡保護, 因此開機後僅提供一般用戶權限, 使用預先安裝的應用套件&lt;/li&gt;
&lt;li&gt;本磁區所安裝的應用程式套件, 將與第2磁區對應, 專門提供跨平台應用程式教學使用&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;CADLab 使用與維護&lt;/h2&gt;
&lt;p&gt;各班上課時, 每排推派一名輪值生, 負責事項:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;敦促同學不要在電腦桌上用餐&lt;/li&gt;
&lt;li&gt;上課前後, 負責到 CADLab 日誌, 登記或勾選學員電腦使用情形, 填寫維修單或建議表&lt;/li&gt;
&lt;li&gt;負責在課後, 確實檢查各電腦是否正常關機, 是否遺留個人物品&lt;/li&gt;
&lt;li&gt;負責在課後清潔各排座位地板與桌面, 與班上幹部配合全員離開 CADLab 前確實關閉所有照明與空調系統&lt;/li&gt;
&lt;/ol&gt;</summary><category term="CAD"></category><category term="綜一館8F"></category></entry><entry><title>使用者貢獻文章標題(參考)</title><link href="http://cadlab.mde.tw/post/shi-yong-zhe-gong-xian-wen-zhang-biao-ti-can-kao.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>user</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/shi-yong-zhe-gong-xian-wen-zhang-biao-ti-can-kao.html</id><summary type="html">&lt;p&gt;使用者貢獻文章的參考 Leo Editor 檔案&lt;/p&gt;


&lt;p&gt;使用者貢獻文章的內容&lt;/p&gt;</summary><category term="Reference"></category><category term="user template"></category></entry><entry><title>使用者貢獻文章標題</title><link href="http://cadlab.mde.tw/post/shi-yong-zhe-gong-xian-wen-zhang-biao-ti.html" rel="alternate"></link><updated>2016-05-30T09:23:54+08:00</updated><author><name>user</name></author><id>tag:cadlab.mde.tw,2016-05-30:post/shi-yong-zhe-gong-xian-wen-zhang-biao-ti.html</id><summary type="html">&lt;p&gt;使用者貢獻文章的參考 Leo Editor 檔案&lt;/p&gt;


&lt;p&gt;本網誌的系統與靜態資料為一個 Github 倉儲 &lt;a href="https://github.com/cad-lab/blog"&gt;https://github.com/cad-lab/blog&lt;/a&gt;, 只要符合 GNU AFFERO GENERAL PUBLIC LICENSE 授權規範, 任何人都可以取用.&lt;/p&gt;
&lt;p&gt;本網誌的規劃是希望透過 Gmail 的認証取得參與協同著作的權限後, 各作者可以利用 users 目錄下的 .leo 檔案, 各自維護自己的文章, 基本要求是, 每篇文章, 必須以使用者帳號作為開頭, 並建議依照日期分類, 以避免各用戶的文章彼此覆蓋.&lt;/p&gt;
&lt;p&gt;各用戶若需要協同著作, 共同維護一篇 content 目錄中的某一個 .md 檔案, 那麼各用戶在 gh-pages 倉儲分支版本提交與推送過程, 就必須設法處理版本內容的衝突, 但各 .md 檔案建議是在 Leo Editor @edit 或@clean 節點下進行協同編輯並處理內容衝突.&lt;/p&gt;
&lt;p&gt;下圖為機械設計工程系即時網路連線:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://140.130.1.199/graph_image.php?action=view&amp;amp;local_graph_id=120&amp;amp;rra_id=5" alt="mde realtime network graph" /&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src="http://140.130.1.199/graph_image.php?action=view&amp;amp;local_graph_id=120&amp;amp;rra_id=2" alt="mde realtime network graph" /&gt;&lt;/p&gt;</summary><category term="Reference"></category><category term="user template"></category></entry></feed>