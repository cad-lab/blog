{"pages":[{"url":"http://cadlab.mde.tw/post/pages/about/","tags":"misc","title":"About","text":"CAD 實驗室 CADLab 為台灣國立虎尾科技大學, 機械設計工程系, 電腦輔助設計室, 全稱為 Computer Aided Design Laboratory (縮寫為 CADLab), Department of Mechanical Design Engineering, National Formosa University, Taiwan. CADLab 電腦輔助設計室配備 63 +1 台桌上型電腦, 以及下列相關內容管理網站: CADLab 靜態網誌: http://cadlab.mde.tw (具內容版次管理, 可在本地端與遠端全面佈署使用) CADLab 動態網誌: http://wordpress-cadlab.rhcloud.com (內容無版次管理, 但方便多人即時線上編輯內容, 部份內容可與靜態網誌同步) CADLab 內容管理網站: http://cmsimply-cadlab.rhcloud.com (專門用來收集資料, 集結構思, 編寫章節式文章用) CADLab WIKI: https://github.com/cad-lab/blog/wiki (附屬在 Github, 專門提供內容協同者統一訊息用) CADLab 雲端應用程式: http://2016spring-cadlab.rhcloud.com/ ( Python3 wsgi 應用程式展示用) 伺服主機 http://101.mde.tw"},{"url":"http://cadlab.mde.tw/post/wang-ji-ji-jie-she-ji-2d-hui-tu.html","tags":"MISC","title":"網際機械設計 2D 繪圖","text":"http://2015fallhw.github.io/arcidau/Flintlock.html 是一個典型的網際機械設計 2D 繪圖範例, CADLab 希望能夠利用 Brython 重新建立一個直接以 Python3 在網頁中繪圖的類似應用. #flintlockImg { float: right; display: inline; /* IE6 hack to fix double margin bug */ width: 24em; margin: 1em 2em 1em 1em; } #flintlockImg img { width: 100%; padding: 0.5em; border: 1px solid #404040; } #cvsUpper, #cvsLower { position: relative; width: 600px; height: 300px; text-align: center; /* this will center console if it has display:inline-block */ background-color: #aabdd3; } window.onload=function(){ brython(1); } if (typeof addLoadEvent === \"undefined\") { var addLoadEvent = function(func) { var oldonload = window.onload; if (typeof window.onload != 'function') { window.onload = func; } else { window.onload = function(){oldonload(); func();} } } } if (typeof addEvent === \"undefined\") { var addEvent = function(element, eventType, handler) { if (element.attachEvent) { return element.attachEvent('on'+eventType, handler); } return element.addEventListener(eventType, handler, false); }; } function cancelBubble(e) { var evt = e ? e:window.event; if (evt.stopPropagation) evt.stopPropagation(); if (evt.cancelBubble!=null) evt.cancelBubble = true; } function enableBtn(btnId) { var btn = document.getElementById(btnId); btn.disabled = false; } function disableBtn(btnId) { var btn = document.getElementById(btnId); btn.disabled = true; } function FlintlockDemo(cvsU, cvsL) { \"use strict\" var innerGCL0, innerGCL1, outerGC, // Lock components (Cango2D groups) cockObj, fizzenObj, plateObj, searSpringObj, searObj, tumblerObj, mainSpringObj, screwsObj, // draw outside in lower canvas plateOutside, cockOutside, fizzenOutside, fizzenSpring, outScrews; this.fire_JS = function() { innerGCL0.playAnimation(0, 1000); // play for 1000 then pause outerGC.playAnimation(0, 1000); disableBtn('cock'); disableBtn('fire'); setTimeout(\"enableBtn('load')\", 1000); }; this.load_JS = function() { innerGCL0.playAnimation(1000, 3500); // resume from pause play until 3500 outerGC.playAnimation(1000, 3500); disableBtn('load'); disableBtn('fire'); setTimeout(\"enableBtn('cock')\", 2500); }; this.cock_JS = function() { innerGCL0.playAnimation(3500, 5000); // resume from pause play until 5000 outerGC.playAnimation(3500, 5000); disableBtn('load'); disableBtn('cock'); setTimeout(\"enableBtn('fire')\", 1500); }; // Upper display innerGCL0 = new Cango(cvsU); // layer for the cock and fizzen innerGCL0.setWorldCoords(-250, -100, 500); // square pixels origin in center of canvas innerGCL1 = new Cango(innerGCL0.createLayer()); // layer for main spring and sear innerGCL1.dupCtx(innerGCL0); // construct all the component objects cockObj = makeCock(innerGCL0); fizzenObj = makeFizzenInside(innerGCL0); plateObj = makePlate(innerGCL0); searSpringObj = makeSearSpring(innerGCL1); searObj = makeSear(innerGCL1); tumblerObj = makeTumbler(innerGCL1); mainSpringObj = makeMainSpring(innerGCL1); screwsObj = makeScrews(innerGCL1); var innerTwnr = new Tweener(0, 5000); var innerData = { cockRot: [0, 54, 54, 18, 18, 0], cockRotTimes:[0, 10, 20, 60, 70, 90], fizzenRot: [0, 0, 73, 73, 0], fizzenRotTimes:[0, 4, 8, 60, 70], searSpringRot: [0, -5, -6, -3.5, 0, -2, -3.5, -3.5, 0, 0, -2, -3, -3.5, 0], searSpringRotTimes:[0, 5, 10, 15, 20, 30, 40, 50, 60, 70, 75, 80, 85, 90], searRot: [0, 10, 12, 7, 0, 4, 7, 7, 0, 0, 4, 5.5, 7, 0], searRotTimes:[0, 5, 10, 15, 20, 30, 40, 50, 60, 70, 75, 80, 85, 90], tumblerRot: [0, 54, 54, 18, 18, 0], tumblerRotTimes:[0, 10, 20, 60, 70, 90], mainSpringRot: [0, -7, -7, -2, -2, 0], mainSpringRotTimes:[0, 10, 20, 60, 70, 90] }; function initCock(opts) { this.nextState.x = cockCxOfs; this.nextState.y = -cockCyOfs; } function initFissen(opts) { this.nextState.x = fizzenCxOfs; this.nextState.y = -fizzenCyOfs; } function initSearSpring(opts) { this.nextState.x = searSpringCxOfs; this.nextState.y = -searSpringCyOfs; } function initSear(opts) { this.nextState.x = searCxOfs; this.nextState.y = -searCyOfs; } function initMainSpring(opts) { this.nextState.x = mainSpringCxOfs; this.nextState.y = -mainSpringCyOfs; } function cockPathFn(time, opts) { var cockRotVal = innerTwnr.getVal(time, opts.cockRot, opts.cockRotTimes); this.nextState.rot = cockRotVal; } function fizzenPathFn(time, opts) { var fizzenRotVal = innerTwnr.getVal(time, opts.fizzenRot, opts.fizzenRotTimes); this.nextState.rot = fizzenRotVal; } function searSpringPathFn(time, opts) { var searSpringRotVal = innerTwnr.getVal(time, opts.searSpringRot, opts.searSpringRotTimes); this.nextState.rot = searSpringRotVal; } function searPathFn(time, opts) { var searRotVal = innerTwnr.getVal(time, opts.searRot, opts.searRotTimes); this.nextState.rot = searRotVal; } function tumblerPathFn(time, opts) { var tumblerRotVal = innerTwnr.getVal(time, opts.tumblerRot, opts.tumblerRotTimes); this.nextState.rot = tumblerRotVal; } function mainSpringPathFn(time, opts) { var mainSpringRotVal = innerTwnr.getVal(time, opts.mainSpringRot, opts.mainSpringRotTimes); this.nextState.rot = mainSpringRotVal; } innerGCL0.animate(cockObj, initCock, cockPathFn, innerData); innerGCL0.animate(fizzenObj, initFissen, fizzenPathFn, innerData); innerGCL0.animate(plateObj); innerGCL1.animate(searSpringObj, initSearSpring, searSpringPathFn, innerData); innerGCL1.animate(searObj, initSear, searPathFn, innerData); innerGCL1.animate(tumblerObj, initCock, tumblerPathFn, innerData); innerGCL1.animate(mainSpringObj, initMainSpring, mainSpringPathFn, innerData); innerGCL1.animate(screwsObj); // Lower display outerGC = new Cango(cvsL); outerGC.setWorldCoords(-250, -100, 500); // construct all the component objects plateOutside = makePlateOutside(outerGC); cockOutside = makeCockOutside(outerGC); fizzenOutside = makeFizzenOutside(outerGC); fizzenSpring = makeFizzenSpring(outerGC); outScrews = makeOutScrews(outerGC); var outerTwnr = new Tweener(0, 5000); var outerData = { outerCockRot: [0, -54, -54, -18, -18, 0], outerCockRotTimes:[0, 10, 20, 60, 70, 90], outerFizRot: [0, 0, -73, -73, 0], outerFizRotTimes:[0, 4, 8, 60, 70], outerFizSpringRot: [0, 0, 5, 6, 3.5, 0, 0, 3, 4, 3, 0], outerFizSpringRotTimes:[0, 4, 5, 6, 7, 8, 60, 62.5, 65, 67.5, 70] }; function initCockOutside(opts) { this.nextState.x = -cockCxOfs; this.nextState.y = -cockCyOfs; } function initFissenOutside(opts) { this.nextState.x = -fizzenCxOfs; this.nextState.y = -fizzenCyOfs; } function initFissenSpring(opts) { this.nextState.x = -fizzenSpringCxOfs; this.nextState.y = -fizzenSpringCyOfs; } function outerCockPathFn(time, opts) { var cockRotVal = outerTwnr.getVal(time, opts.outerCockRot, opts.outerCockRotTimes); this.nextState.rot = cockRotVal; } function outerFizzenPathFn(time, opts) { var fizzenRotVal = outerTwnr.getVal(time, opts.outerFizRot, opts.outerFizRotTimes); this.nextState.rot = fizzenRotVal; } function fizzenSpringPathFn(time, opts) { var fizzenSpringRotVal = outerTwnr.getVal(time, opts.outerFizSpringRot, opts.outerFizSpringRotTimes); this.nextState.rot = fizzenSpringRotVal; } outerGC.animate(plateOutside); outerGC.animate(cockOutside, initCockOutside, outerCockPathFn, outerData); outerGC.animate(fizzenOutside, initFissenOutside, outerFizzenPathFn, outerData); outerGC.animate(fizzenSpring, initFissenSpring, fizzenSpringPathFn, outerData); outerGC.animate(outScrews); disableBtn('load'); disableBtn('cock'); enableBtn('fire'); } var consoleBtns = { f1:function(){demo.load_JS()}, f2:function(){demo.cock_JS()}, f3:function(){demo.fire_JS()}, f4:function(){} }; addLoadEvent( function(){ demo = new FlintlockDemo('cvsUpper', 'cvsLower'); enableStickyNav(); }); HALF COCK COCK FIRE 利用 http://2015fallhw.github.io/cptocadp/static/gearUtils-05.js 程式庫, 繪製正齒輪: # 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容 from browser import document as doc # 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換 from browser import window # 針對 Javascript 既有的物件, 則必須透過 JSConstructor 轉換 from javascript import JSConstructor import math # 主要用來取得畫布大小 canvas = doc[\"gear1\"] # 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx #ctx = canvas.getContext(\"2d\") # 針對類別的轉換, 將 Cango.js 中的 Cango 物件轉為 Python cango 物件 cango = JSConstructor(window.Cango) # 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換 shapedefs = window.shapeDefs # 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形 # in CangoAnimation.js #interpolate1 = window.interpolate # Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件 cobj = JSConstructor(window.Cobj) creategeartooth = JSConstructor(window.createGearTooth) # 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id=\"plotarea\" 的 canvas 上 cgo = cango(\"gear1\") ###################################### # 畫正齒輪輪廓 ##################################### # n 為齒數 n = 17 # pa 為壓力角 pa = 25 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth m = 0.8*canvas.width/n # pr 為節圓半徑 pr = n*m/2 # gear Pitch radius # generate gear data = creategeartooth(m, n, pa) # Brython 程式中的 print 會將資料印在 Browser 的 console 區 #print(data) gearTooth = cobj(data, \"SHAPE\", { \"fillColor\":\"#ddd0dd\", \"border\": True, \"strokeColor\": \"#606060\" }) gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中 gear = gearTooth.dup() # gear 為單一齒的輪廓資料 #cgo.render(gearTooth) # 利用單齒輪廓旋轉, 產生整個正齒輪外形 for i in range(1, n): # 將 gearTooth 中的資料複製到 newTooth newTooth = gearTooth.dup() # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear newTooth.rotate(360*i/n) # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號 gear.appendPath(newTooth, True) # trim move command = True # 建立軸孔 # add axle hole, hr 為 hole radius hr = 0.6*pr # diameter of gear shaft shaft = cobj(shapedefs.circle(hr), \"PATH\") shaft.revWinding() gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path cx = canvas.width/2 cy = canvas.height/2 gear.translate(cx, cy) # render 繪出靜態正齒輪輪廓 cgo.render(gear) 上述正齒輪繪圖原始碼: <canvas id='gear1' width='800' height='750'></canvas> <script type=\"text/python\"> # 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容 from browser import document as doc # 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換 from browser import window # 針對 Javascript 既有的物件, 則必須透過 JSConstructor 轉換 from javascript import JSConstructor import math # 主要用來取得畫布大小 canvas = doc[\"gear1\"] # 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx #ctx = canvas.getContext(\"2d\") # 針對類別的轉換, 將 Cango.js 中的 Cango 物件轉為 Python cango 物件 cango = JSConstructor(window.Cango) # 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換 shapedefs = window.shapeDefs # 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形 # in CangoAnimation.js #interpolate1 = window.interpolate # Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件 cobj = JSConstructor(window.Cobj) creategeartooth = JSConstructor(window.createGearTooth) # 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id=\"plotarea\" 的 canvas 上 cgo = cango(\"gear1\") ###################################### # 畫正齒輪輪廓 ##################################### # n 為齒數 n = 17 # pa 為壓力角 pa = 25 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth m = 0.8*canvas.width/n # pr 為節圓半徑 pr = n*m/2 # gear Pitch radius # generate gear data = creategeartooth(m, n, pa) # Brython 程式中的 print 會將資料印在 Browser 的 console 區 #print(data) gearTooth = cobj(data, \"SHAPE\", { \"fillColor\":\"#ddd0dd\", \"border\": True, \"strokeColor\": \"#606060\" }) gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中 gear = gearTooth.dup() # gear 為單一齒的輪廓資料 #cgo.render(gearTooth) # 利用單齒輪廓旋轉, 產生整個正齒輪外形 for i in range(1, n): # 將 gearTooth 中的資料複製到 newTooth newTooth = gearTooth.dup() # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear newTooth.rotate(360*i/n) # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號 gear.appendPath(newTooth, True) # trim move command = True # 建立軸孔 # add axle hole, hr 為 hole radius hr = 0.6*pr # diameter of gear shaft shaft = cobj(shapedefs.circle(hr), \"PATH\") shaft.revWinding() gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path cx = canvas.width/2 cy = canvas.height/2 gear.translate(cx, cy) # render 繪出靜態正齒輪輪廓 cgo.render(gear) </script> 直接利用 Canvas 繪製正齒輪: # 導入 browser 模組中的 document, 並設為 doc 變數 from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) # 準備在 id=\"gear2\" 的 canvas 中繪圖 canvas = doc[\"gear2\"] ctx = canvas.getContext(\"2d\") x = (canvas.width)/2 y = (canvas.height)/2 r = 0.8*(canvas.width/2) # 齒數 n = 53 # 壓力角 pa = 20 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") 上述直接利用 Canvas 繪正齒輪的原始碼: <canvas id='gear2' width='800' height='700'></canvas> <script type=\"text/python3\"> # 導入 browser 模組中的 document, 並設為 doc 變數 from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) # 準備在 id=\"gear2\" 的 canvas 中繪圖 canvas = doc[\"gear2\"] ctx = canvas.getContext(\"2d\") x = (canvas.width)/2 y = (canvas.height)/2 r = 0.8*(canvas.width/2) # 齒數 n = 53 # 壓力角 pa = 20 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") </script> 正齒輪囓合繪圖: # 導入 browser 模組中的 document, 並設為 doc 變數 from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) # 準備在 id=\"gear3\" 的 canvas 中繪圖 canvas = doc[\"gear3\"] ctx = canvas.getContext(\"2d\") # 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角 # 壓力角 pa 單位為角度 pa = 20 # 第1齒輪齒數 n_g1 = 17 # 第2齒輪齒數 n_g2 = 11 # 第3齒輪齒數 n_g3 = 13 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 m = (0.8*canvas.width)/(n_g1+n_g2+n_g3) # 根據模數 m, 計算各齒輪的節圓半徑 rp_g1 = m*n_g1/2 rp_g2 = m*n_g2/2 rp_g3 = m*n_g3/2 #單一正齒輪繪圖呼叫格式 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") # 開始繪製囓合齒輪輪廓 # 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 的 80%, 所以兩邊各預留 10% 距離 x_g1 = canvas.width*0.1+rp_g1 # y 方向繪圖區域上方預留 canvas.height 的 20% y_g1 = canvas.height*0.2+rp_g1 # 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同 x_g2 = x_g1 + rp_g1 + rp_g2 y_g2 = y_g1 # 第3齒輪的圓心座標 x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3 y_g3 = y_g1 # 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2 # 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖 ctx.save() # translate to the origin of second gear ctx.translate(x_g1, y_g1) # rotate to engage ctx.rotate(math.pi/2) # put it back ctx.translate(-x_g1, -y_g1) # 繪製第一個齒輪輪廓 Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, \"blue\") ctx.restore() # 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g2, y_g2) # rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g2) # put it back ctx.translate(-x_g2, -y_g2) Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, \"black\") ctx.restore() # 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g3, y_g3) # rotate to engage # math.pi+math.pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度 # 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快 # 第1個 -math.pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度 # -math.pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合 # (math.pi+math.pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, # 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, # 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3 ctx.rotate(-math.pi/2-math.pi/n_g3+(math.pi+math.pi/n_g2)*n_g2/n_g3) # put it back ctx.translate(-x_g3, -y_g3) Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, \"red\") ctx.restore() 上述正齒輪囓合繪圖原始碼: <canvas id='gear3' width='800' height='400'></canvas> <script type=\"text/python3\"> # 導入 browser 模組中的 document, 並設為 doc 變數 from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) # 準備在 id=\"gear3\" 的 canvas 中繪圖 canvas = doc[\"gear3\"] ctx = canvas.getContext(\"2d\") # 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角 # 壓力角 pa 單位為角度 pa = 20 # 第1齒輪齒數 n_g1 = 17 # 第2齒輪齒數 n_g2 = 11 # 第3齒輪齒數 n_g3 = 13 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 m = (0.8*canvas.width)/(n_g1+n_g2+n_g3) # 根據模數 m, 計算各齒輪的節圓半徑 rp_g1 = m*n_g1/2 rp_g2 = m*n_g2/2 rp_g3 = m*n_g3/2 #單一正齒輪繪圖呼叫格式 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") # 開始繪製囓合齒輪輪廓 # 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 的 80%, 所以兩邊各預留 10% 距離 x_g1 = canvas.width*0.1+rp_g1 # y 方向繪圖區域上方預留 canvas.height 的 20% y_g1 = canvas.height*0.2+rp_g1 # 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同 x_g2 = x_g1 + rp_g1 + rp_g2 y_g2 = y_g1 # 第3齒輪的圓心座標 x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3 y_g3 = y_g1 # 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2 # 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖 ctx.save() # translate to the origin of second gear ctx.translate(x_g1, y_g1) # rotate to engage ctx.rotate(math.pi/2) # put it back ctx.translate(-x_g1, -y_g1) # 繪製第一個齒輪輪廓 Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, \"blue\") ctx.restore() # 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g2, y_g2) # rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g2) # put it back ctx.translate(-x_g2, -y_g2) Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, \"black\") ctx.restore() # 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g3, y_g3) # rotate to engage # math.pi+math.pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度 # 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快 # 第1個 -math.pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度 # -math.pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合 # (math.pi+math.pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, # 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, # 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3 ctx.rotate(-math.pi/2-math.pi/n_g3+(math.pi+math.pi/n_g2)*n_g2/n_g3) # put it back ctx.translate(-x_g3, -y_g3) Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, \"red\") ctx.restore() </script> 轉為 Brython 繪圖的模擬應用: from javascript import JSConstructor from browser import window cango2d = JSConstructor(window.Cango2D) shapedefs = window.shapeDefs obj2d = JSConstructor(window.Obj2D) tweener = JSConstructor(window.Tweener) cgo = cango2d(\"robot\") # 清除畫面 cgo.clearCanvas(\"lightyellow\") cgo.setWorldCoords(-50, -50, 300) # 加上基軸與第一桿 # 畫筆移到 -20, -10, 畫直線到 -10,-10 以及 -10,0 standData = ['M', -20,-10, 'L', -10,-10, -10,0, 'A', 10,10,0,0,0,10,0, 'L',10,-10, 20,-10, 20,-40, -20,-40,'z'] stand = obj2d(standData, \"SHAPE\", { \"fillColor\":'darkgray', \"border\": True, \"strokeColor\": \"#222222\" }) axle0 = obj2d(shapedefs.circle(10), \"SHAPE\", { \"fillColor\":'gray', \"border\": True, \"strokeColor\": \"#222222\" }) armGrp = cgo.createGroup2D(stand, axle0) segData = ['M',0,-8, 'A',8,8,0,0,0,0,8, 'L',50,8, 'A',8,8,0,0,0,50,-8, 'Z'] seg1 = obj2d(segData, \"SHAPE\", { \"fillColor\":'darkGray', \"border\": True, \"strokeColor\": \"#222222\", \"zIndex\": -1 }) # 利用 zIndex 決定疊層的先後次序 axle1 = obj2d(shapedefs.circle(8), \"SHAPE\", { \"fillColor\":'gray', \"border\": True, \"strokeColor\": \"#222222\", \"zIndex\": 1 }) axle1.translate(50, 0) seg1Grp = cgo.createGroup2D(seg1, axle1) armGrp.addObj(seg1Grp) # 加上第二軸 seg2 = obj2d(segData, \"SHAPE\", { \"fillColor\":'darkGray', \"border\": True, \"strokeColor\": \"#222222\", \"zIndex\": -1 }) axle2 = obj2d(shapedefs.circle(8), \"SHAPE\", { \"fillColor\":'gray', \"border\": True, \"strokeColor\": \"#222222\", \"zIndex\": 1 }) axle2.translate(50, 0) seg2Grp = cgo.createGroup2D(seg2, axle2) cgo.render(seg2Grp) # 請注意 seg2Grp 加上 seg1Grp 物件上 seg1Grp.addObj(seg2Grp) seg3 = obj2d(segData, \"SHAPE\", { 'fillColor':'darkGray', 'border': True, 'strokeColor': \"#222222\", 'zIndex': -1 }) axle3 = obj2d(shapedefs.circle(6), \"SHAPE\", { 'fillColor':'gray', 'border': True, 'strokeColor': \"#222222\", 'zIndex': 1 }) axle3.translate(50, 0) seg3Grp = cgo.createGroup2D(seg3, axle3) seg2Grp.addObj(seg3Grp) seg4Data = ['M',0,-6, 'A',6,6,0,0,0,0,6, 'L',40,6, 40,12, 50,12, 50,-12, 40,-12, 40,-6, 'Z'] seg4 = obj2d(seg4Data, \"SHAPE\", { 'fillColor':'darkGray', 'border': True, 'strokeColor': \"#222222\", 'zIndex': -1 }) seg3Grp.addObj(seg4) # setup animation animData = {'s1': [0, 80, 45, 0], 's2': [0, -60, -60, 0], 's3': [0, -90, 0, 90, 0], 's4': [0, 30, -90, 0]} armTwnr = tweener(0, 3500, 'loop') def initArm(opts): seg2Grp.transform.translate(50,0) seg3Grp.transform.translate(50,0) seg4.transform.translate(50,0) def armPathFn(time, opts): seg1Rot = armTwnr.getVal(time, opts.s1) seg2Rot = armTwnr.getVal(time, opts.s2) seg3Rot = armTwnr.getVal(time, opts.s3) seg4Rot = armTwnr.getVal(time, opts.s4) seg1Grp.transform.rotate(seg1Rot) seg2Grp.transform.rotate(seg2Rot) seg2Grp.transform.translate(50,0) seg3Grp.transform.rotate(seg3Rot) seg3Grp.transform.translate(50,0) seg4.transform.rotate(seg4Rot) seg4.transform.translate(50,0) cgo.animate(armGrp, initArm, armPathFn, animData) cgo.playAnimation() 上述動態模擬的原始碼: <canvas id='robot' width='800' height='400'></canvas> <script type=\"text/python\"> from javascript import JSConstructor from browser import window cango2d = JSConstructor(window.Cango2D) shapedefs = window.shapeDefs obj2d = JSConstructor(window.Obj2D) tweener = JSConstructor(window.Tweener) cgo = cango2d(\"robot\") # 清除畫面 cgo.clearCanvas(\"lightyellow\") cgo.setWorldCoords(-50, -50, 300) # 加上基軸與第一桿 # 畫筆移到 -20, -10, 畫直線到 -10,-10 以及 -10,0 standData = ['M', -20,-10, 'L', -10,-10, -10,0, 'A', 10,10,0,0,0,10,0, 'L',10,-10, 20,-10, 20,-40, -20,-40,'z'] stand = obj2d(standData, \"SHAPE\", { \"fillColor\":'darkgray', \"border\": True, \"strokeColor\": \"#222222\" }) axle0 = obj2d(shapedefs.circle(10), \"SHAPE\", { \"fillColor\":'gray', \"border\": True, \"strokeColor\": \"#222222\" }) armGrp = cgo.createGroup2D(stand, axle0) segData = ['M',0,-8, 'A',8,8,0,0,0,0,8, 'L',50,8, 'A',8,8,0,0,0,50,-8, 'Z'] seg1 = obj2d(segData, \"SHAPE\", { \"fillColor\":'darkGray', \"border\": True, \"strokeColor\": \"#222222\", \"zIndex\": -1 }) # 利用 zIndex 決定疊層的先後次序 axle1 = obj2d(shapedefs.circle(8), \"SHAPE\", { \"fillColor\":'gray', \"border\": True, \"strokeColor\": \"#222222\", \"zIndex\": 1 }) axle1.translate(50, 0) seg1Grp = cgo.createGroup2D(seg1, axle1) armGrp.addObj(seg1Grp) # 加上第二軸 seg2 = obj2d(segData, \"SHAPE\", { \"fillColor\":'darkGray', \"border\": True, \"strokeColor\": \"#222222\", \"zIndex\": -1 }) axle2 = obj2d(shapedefs.circle(8), \"SHAPE\", { \"fillColor\":'gray', \"border\": True, \"strokeColor\": \"#222222\", \"zIndex\": 1 }) axle2.translate(50, 0) seg2Grp = cgo.createGroup2D(seg2, axle2) cgo.render(seg2Grp) # 請注意 seg2Grp 加上 seg1Grp 物件上 seg1Grp.addObj(seg2Grp) seg3 = obj2d(segData, \"SHAPE\", { 'fillColor':'darkGray', 'border': True, 'strokeColor': \"#222222\", 'zIndex': -1 }) axle3 = obj2d(shapedefs.circle(6), \"SHAPE\", { 'fillColor':'gray', 'border': True, 'strokeColor': \"#222222\", 'zIndex': 1 }) axle3.translate(50, 0) seg3Grp = cgo.createGroup2D(seg3, axle3) seg2Grp.addObj(seg3Grp) seg4Data = ['M',0,-6, 'A',6,6,0,0,0,0,6, 'L',40,6, 40,12, 50,12, 50,-12, 40,-12, 40,-6, 'Z'] seg4 = obj2d(seg4Data, \"SHAPE\", { 'fillColor':'darkGray', 'border': True, 'strokeColor': \"#222222\", 'zIndex': -1 }) seg3Grp.addObj(seg4) # setup animation animData = {'s1': [0, 80, 45, 0], 's2': [0, -60, -60, 0], 's3': [0, -90, 0, 90, 0], 's4': [0, 30, -90, 0]} armTwnr = tweener(0, 3500, 'loop') def initArm(opts): seg2Grp.transform.translate(50,0) seg3Grp.transform.translate(50,0) seg4.transform.translate(50,0) def armPathFn(time, opts): seg1Rot = armTwnr.getVal(time, opts.s1) seg2Rot = armTwnr.getVal(time, opts.s2) seg3Rot = armTwnr.getVal(time, opts.s3) seg4Rot = armTwnr.getVal(time, opts.s4) seg1Grp.transform.rotate(seg1Rot) seg2Grp.transform.rotate(seg2Rot) seg2Grp.transform.translate(50,0) seg3Grp.transform.rotate(seg3Rot) seg3Grp.transform.translate(50,0) seg4.transform.rotate(seg4Rot) seg4.transform.translate(50,0) cgo.animate(armGrp, initArm, armPathFn, animData) cgo.playAnimation() </script>"},{"url":"http://cadlab.mde.tw/post/wordpress-wang-zhi-wen-zhang-zhong-de-wang-ji-cheng-shi-ma.html","tags":"MISC","title":"Wordpress 網誌文章中的網際程式碼","text":"從 SVG 歷史 與 WebGL 歷史 , 以及 socket.io 歷史 , 也許不難發現, 多人協同在瀏覽器為基礎的應用程式環境, 已然成型. 儘管如此, 要將所有的工作全時在網路連線的環境中完成, 可能仍言之過早, 比較讓人確定的是, 多點觸控的平台伴隨著本地端的桌機或者是筆電, 還會繼續是主流的電腦輔助設計環境. 在這樣的所謂 Web Based (網際) 環境中, 身為一位機械設計工程師, 除了要關注傳統的 2D/3D 靜態與動態內容表達外, 能否逐步導入多點觸控裝置的資料, 便成為重點. 以網際 2D 繪圖而言, 2013 年推出的 http://snapsvg.io/ , 就是一套能夠順應未來電腦輔助機械設計繪圖的工具之一. 從 導入 Brython 與 Snap.svg 網際繪圖 的說明中, 我們已經知道能夠透過網際的 Brython 來呼叫並運用 snap.svg 程式庫, 但是假如希望完成如 Pelican 靜態網頁與 Wordpress 的整合方案 中所談到的資料整合, 並且導入 snap.svg 到 Wordpress 與 Pelican 網誌系統, 需要注意到 Wordpress 對於內文中處理程式碼的用法, 否則由 Pelican 靜態網誌轉進 Wordpress 系統中的所有 Brython 或 Javascript 程式內容, 將會全數被 Wordpress 當作一般文字資料處理. 應對的方法很簡單, 只需要明確利用 html 的註解標註, 跳過 Wordpress 對於 Brython 與 Javascript 程式碼的額外處理就行. 以下舉 Snap.svg 典型的動態模擬為例: //<!-- window.onload=function(){ brython(1); } //--> #<!-- from javascript import JSConstructor from browser import alert from browser import window, document # 透過 window 與 JSConstructor 從 Brython 物件 snap 擷取 Snap 物件的內容 snap = JSConstructor(window.Snap) # 使用 id 為 \"svgout\" 的 svg 標註進行繪圖 s = snap(\"#svgout\") offsetY = 50 # 是否標示出繪圖範圍 #borderRect = s.rect(0,0,800,640,10,10).attr({ 'stroke': \"silver\", 'fill': \"silver\", 'strokeWidth': \"3\" }) g = s.group().transform('t250,120') r0 = s.rect(150,150,100,100,20,20).attr({ 'fill': \"orange\", 'opacity': \"0.8\", 'stroke': \"black\", 'strokeWidth': \"2\" }) c0 = s.circle(225,225,10).attr({ 'fill': \"silver\", 'stroke': \"black\", 'strokeWidth': \"4\" }).attr({ 'id': 'c0' }) g0 = s.group( r0,c0 ).attr({ 'id': 'g0' }) #g0.animate({ 'transform' : 't250,120r360,225,225' },4000) g0.appendTo( g ) g0.animate({ 'transform' : 'r360,225,225' },4000) # 讓 g0 可以拖動 g0.drag() r1 = s.rect(100,100,100,100,20,20).attr({ 'fill': \"red\", 'opacity': \"0.8\", 'stroke': \"black\", 'strokeWidth': \"2\" }) c1 = s.circle(175,175,10).attr({ 'fill': \"silver\", 'stroke': \"black\" , 'strokeWidth': \"4\"}).attr({ 'id': 'c1' }) g1 = s.group( r1,c1 ).attr({ 'id': 'g1' }) g1.appendTo( g0 ).attr({ 'id': 'g1' }) g1.animate({ 'transform' : 'r360,175,175' },4000) r2 = s.rect(50,50,100,100,20,20).attr({ 'fill': \"blue\", 'opacity': \"0.8\", 'stroke': \"black\", 'strokeWidth': \"2\" }) c2 = s.circle(125,125,10).attr({ 'fill': \"silver\", 'stroke': \"black\", 'strokeWidth': \"4\" }).attr({ 'id': 'c2' }) g2 = s.group(r2,c2).attr({ 'id': 'g2' }) g2.appendTo( g1 ); g2.animate( { 'transform' : 'r360,125,125' },4000); r3 = s.rect(0,0,100,100,20,20).attr({ 'fill': \"yellow\", 'opacity': \"0.8\", 'stroke': \"black\", 'strokeWidth': \"2\" }) c3 = s.circle(75,75,10).attr({ 'fill': \"silver\", 'stroke': \"black\", 'strokeWidth': \"4\" }).attr({ 'id': 'c3' }) g3 = s.group(r3,c3).attr({ 'id': 'g3' }) g3.appendTo( g2 ) g3.animate( { 'transform' : 'r360,75,75' },4000) r4 = s.rect(-50,-50,100,100,20,20).attr({ 'fill': \"green\", 'opacity': \"0.8\", 'stroke': \"black\", 'strokeWidth': \"2\" }) c4 = s.circle(25,25,10).attr({ 'fill': \"silver\", 'stroke': \"black\", 'strokeWidth': \"4\" }).attr({ 'id': 'c4' }) g4 = s.group(r4,c4).attr({ 'id': 'g4' }); g4.appendTo( g3 ) g4.animate( { 'transform' : 'r360,25,25' },4000) #--> Brython 程式碼: <script type=\"text/javascript\" src=\"http://brython.info/src/brython_dist.js\"></script> <script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js\"></script> <script> //<!-- window.onload=function(){ brython(1); } //--> </script> <svg width=\"800\" height=\"600\" viewBox=\"0 0 800 600\" id=\"svgout\"></svg> <script type=\"text/python\"> #<!-- from javascript import JSConstructor from browser import alert from browser import window, document # 透過 window 與 JSConstructor 從 Brython 物件 snap 擷取 Snap 物件的內容 snap = JSConstructor(window.Snap) # 使用 id 為 \"svgout\" 的 svg 標註進行繪圖 s = snap(\"#svgout\") offsetY = 50 # 是否標示出繪圖範圍 #borderRect = s.rect(0,0,800,640,10,10).attr({ 'stroke': \"silver\", 'fill': \"silver\", 'strokeWidth': \"3\" }) g = s.group().transform('t250,120') r0 = s.rect(150,150,100,100,20,20).attr({ 'fill': \"orange\", 'opacity': \"0.8\", 'stroke': \"black\", 'strokeWidth': \"2\" }) c0 = s.circle(225,225,10).attr({ 'fill': \"silver\", 'stroke': \"black\", 'strokeWidth': \"4\" }).attr({ 'id': 'c0' }) g0 = s.group( r0,c0 ).attr({ 'id': 'g0' }) #g0.animate({ 'transform' : 't250,120r360,225,225' },4000) g0.appendTo( g ) g0.animate({ 'transform' : 'r360,225,225' },4000) # 讓 g0 可以拖動 g0.drag() r1 = s.rect(100,100,100,100,20,20).attr({ 'fill': \"red\", 'opacity': \"0.8\", 'stroke': \"black\", 'strokeWidth': \"2\" }) c1 = s.circle(175,175,10).attr({ 'fill': \"silver\", 'stroke': \"black\" , 'strokeWidth': \"4\"}).attr({ 'id': 'c1' }) g1 = s.group( r1,c1 ).attr({ 'id': 'g1' }) g1.appendTo( g0 ).attr({ 'id': 'g1' }) g1.animate({ 'transform' : 'r360,175,175' },4000) r2 = s.rect(50,50,100,100,20,20).attr({ 'fill': \"blue\", 'opacity': \"0.8\", 'stroke': \"black\", 'strokeWidth': \"2\" }) c2 = s.circle(125,125,10).attr({ 'fill': \"silver\", 'stroke': \"black\", 'strokeWidth': \"4\" }).attr({ 'id': 'c2' }) g2 = s.group(r2,c2).attr({ 'id': 'g2' }) g2.appendTo( g1 ); g2.animate( { 'transform' : 'r360,125,125' },4000); r3 = s.rect(0,0,100,100,20,20).attr({ 'fill': \"yellow\", 'opacity': \"0.8\", 'stroke': \"black\", 'strokeWidth': \"2\" }) c3 = s.circle(75,75,10).attr({ 'fill': \"silver\", 'stroke': \"black\", 'strokeWidth': \"4\" }).attr({ 'id': 'c3' }) g3 = s.group(r3,c3).attr({ 'id': 'g3' }) g3.appendTo( g2 ) g3.animate( { 'transform' : 'r360,75,75' },4000) r4 = s.rect(-50,-50,100,100,20,20).attr({ 'fill': \"green\", 'opacity': \"0.8\", 'stroke': \"black\", 'strokeWidth': \"2\" }) c4 = s.circle(25,25,10).attr({ 'fill': \"silver\", 'stroke': \"black\", 'strokeWidth': \"4\" }).attr({ 'id': 'c4' }) g4 = s.group(r4,c4).attr({ 'id': 'g4' }); g4.appendTo( g3 ) g4.animate( { 'transform' : 'r360,25,25' },4000) #--> </script>"},{"url":"http://cadlab.mde.tw/post/rang-virtualbox-xu-ni-ji-qi-sui-zhu-ji-qi-dong.html","tags":"導引","title":"讓 Virtualbox 虛擬機器隨主機啟動","text":"目前所使用的 Virtualbox 主體分別是 Windows 7 與 Ubuntu 14.04/16.04, 在 Windows 7 的虛擬機器可以透過 http://vboxvmservice.sourceforge.net/ , 讓特定虛擬機器 (virtual machine), 隨著 Host 電腦的開啟而以 service 的方式啟用. 至於在 Ubuntu 14.04 或 16.04 操作系統中, 則可以在 /etc/init.d/ 目錄下建立一個啟動程序, 然後讓電腦在開關機時執行, 主要的指令是開機時, 利用 VBoxHeadless 啟動個別的虛擬機器, 且在關機時, 利用 VBoxManage controlvm 儲存各虛擬機器的運行狀態. StartVM 檔案的內容如下, 分別控制三台虛擬機器: #! /bin/sh # /etc/init.d/StartVM VMUSER=yen VMNAME1=\"Ubuntu_1604_8888\" VMNAME2=\"Ubuntu_1604_6666\" VMNAME3=\"Ubuntu_1404_4444\" case \"$1\" in start) echo \"Starting VirtualBox VM...\" sudo -H -b -u $VMUSER /usr/bin/VBoxHeadless -startvm \"$VMNAME1\" sudo -H -b -u $VMUSER /usr/bin/VBoxHeadless -startvm \"$VMNAME2\" sudo -H -b -u $VMUSER /usr/bin/VBoxHeadless -startvm \"$VMNAME3\" ;; stop) echo \"Saving state of Virtualbox VM...\" sudo -H -u $VMUSER /usr/bin/VBoxManage controlvm \"$VMNAME1\" savestate sudo -H -u $VMUSER /usr/bin/VBoxManage controlvm \"$VMNAME2\" savestate sudo -H -u $VMUSER /usr/bin/VBoxManage controlvm \"$VMNAME3\" savestate ;; *) echo \"Usage: /etc/init.d/StartVM {start|stop}\" exit 1 ;; esac exit 0 接著讓 StartVM 程序檔案可以執行: sudo chmod +x /etc/init.d/StartVM 最後則是將 StartVM 納入開機程序中: sudo update-rc.d StartVM defaults 99 01 參考資料: http://askubuntu.com/questions/57220/start-vboxheadless-vm-at-startup"},{"url":"http://cadlab.mde.tw/post/tinymce4-shi-yong-dao-yin.html","tags":"導引","title":"Tinymce4 使用導引","text":"https://www.tinymce.com/ 版本為 4.3.13 community 版本, 使用授權為 Open Source LGPL 2.1. 啟用 Tinymce4 導入 Tinymce4 Javascript 程式庫, 然後啟動: <script src='//cdn.tinymce.com/4/tinymce.min.js'></script> <script>tinymce.init({ selector:'textarea' });</script> 有關 tinymce4 的啟動: <script> tinymce.init({ selector: \"textarea\", height: 500, plugins: [ \"advlist autolink autosave link image lists charmap print preview hr anchor pagebreak spellchecker\", \"searchreplace wordcount visualblocks visualchars code fullscreen insertdatetime media nonbreaking\", \"table contextmenu directionality emoticons template textcolor paste textcolor colorpicker textpattern\" ], toolbar1: \"newdocument fullpage | bold italic underline strikethrough | alignleft aligncenter alignright alignjustify | styleselect formatselect fontselect fontsizeselect\", toolbar2: \"cut copy paste | searchreplace | bullist numlist | outdent indent blockquote | undo redo | link unlink anchor image media code | insertdatetime preview | forecolor backcolor\", toolbar3: \"table | hr removeformat | subscript superscript | charmap emoticons | print fullscreen | ltr rtl | spellchecker | visualchars visualblocks nonbreaking template pagebreak restoredraft\", menubar: false, toolbar_items_size: 'small', style_formats: [{ title: 'Bold text', inline: 'b' }, { title: 'Red text', inline: 'span', styles: { color: '#ff0000' } }, { title: 'Red header', block: 'h1', styles: { color: '#ff0000' } }, { title: 'Example 1', inline: 'span', classes: 'example1' }, { title: 'Example 2', inline: 'span', classes: 'example2' }, { title: 'Table styles' }, { title: 'Table row 1', selector: 'tr', classes: 'tablerow1' }], templates: [{ title: 'Test template 1', content: 'Test 1' }, { title: 'Test template 2', content: 'Test 2' }], content_css: [ '//fast.fonts.net/cssapi/e6dc9b99-64fe-4292-ad98-6974f93cd2a2.css', '//www.tinymce.com/css/codepen.min.css' ] }); </script> 這裡在將 CMSimply 中的 Tinymce3 改為 Tinymce4 的過程有一點必須注意, 因為 CMSimply 中的各頁面編輯所傳回的 html 並不需要 fullpage plugin, 因此導入 Tinyme4 時就必須避開 fullpage 的使用."},{"url":"http://cadlab.mde.tw/post/ubuntu-1604-windows-7-yu-windows-10-xu-ni-ji-qi.html","tags":"導引","title":"Ubuntu 16.04, Windows 7 與 Windows 10 虛擬機器","text":"Ubuntu 16.04 剛推出兩個月, Windows 10 則推出將近滿一年, 這兩個號稱創新度高的電腦操作系統, 經過幾個禮拜密集的測試, 在今年暑假即將更新的電腦輔助設計室所採購的電腦中, 初步決定都不積極採用, 而只在虛擬機器中提供測試之用. 當然我們必須承認, 問題出在我們迎接創新的速度不足, 現有整體環境沒有辦法迎接這兩種\"最新\"的操作系統. 兩年多前從 Ubuntu 12.04 轉到 14.04 的過程, 或者 5 年多前從 XP 轉進 Windows 7 時, 也面臨過類似的問題, 但是感覺問題都很容易解決, 只是這次之所以捨棄全面提升到 Ubuntu 16.04, 問題出在 AMD 陣營中的 libGL 程式庫驅動程式老舊, 導致 X-Windows 無法 remote 帶回瀏覽器, 至於 Windows 10 在非觸控螢幕的電腦上感覺操作效能提升不大, 但是必須額外配合新介面與並不實用的許多即時服務, 所花費的代價實在太高, 因此作罷. 另外一個讓我們決定不採用 Windows 10 與 Ubuntu 16.04 作為主要操作系統的原因是, 機械設計工程系正要逐步將已經使用多年的 IPV4 環境, 換轉到 IPV6 與 IPV4 混用的環境, 所遭遇的問題已經夠多, 因此決定在新電腦安裝 Windows 7 專業版, 並且在其中利用 Virtualbox 配置 Windows 7, Windows 10, Ubuntu 14.04 與 Ubuntu 16.04 虛擬機器, 讓使用者可以在虛實整合的環境中配置各種機械設計相關的網路環境. Python3, Git 與 Leo Editor 機械設計工程系目前的計算機程式、網際內容管理、電腦輔助設計實習與協同產品設計實習等課程, 強調以數位運算方法來協助解決問題的工具, 包含 Python3, Git 與 Leo Editor. 在 Windows 64 位元環境中, 我們已經製作了一套可攜的 Python3 程式環境, 其中還包括 Git 與 Leo Editor, 使用者只要 git clone https://github.com/chiamingyen/kmol2016.git 就可以取得, 但前提是使用者的 Windows 環境必須要有 git 工具, 可以從 https://github.com/git-for-windows/git/releases 下載. 假如是在 Ubuntu 14.04 或 16.04 環境中, 使用純 IPV6 網路協定上網, 而 apt-get, pip3 或 git 等指令正, 可能就必須要設定支援 IPV4/IPV6 的代理主機, 才能正確執行. Git 使用代理主機 git 在純 IPV6 協定下使用代理主機的設定如下: git config --global http.proxy http://[2001:288:6004:17::17]:3128 git config --global https.proxy http://[2001:288:6004:17::17]:3128 apt 使用代理主機 編輯 /etc/apt/apt.conf, 並且納入下列內容: Acquire::http::Proxy \"http://username:password@your.proxy.server:3128\"; 之後就可以安裝 python3-pip 與 python3-pyqt5 sudo apt install python3-pip sudo apt install python3-pyqt5 pip3 使用代理主機 在支援純 IPV6 協定上網的 Ubuntu 電腦安裝 pip3 與 python3-pyqt5 之後, 就可以接著安裝 Leo Editor, 但是為了安裝 5.1 以上的版本 (才提供 @clean 節點指令的支援), 必須要先以下列指令安裝 Leo Editor 5.0b2 版, 然後再利用 5.3 版的程式碼進行替換即可. 首先是利用代理主機安裝 leo: sudo pip3 --proxy=[2001:288:6004:17::17]:3128 install leo 假如使用者利用： sudo pip3 --proxy=[2001:288:6004:17::17]:3128 install https://github.com/leo-editor/leo-editor/archive/5.3.zip 執行 Leo Editor 5.3 版程式碼安裝時, 將會出現以 Python2 進行 setup.py 的錯誤, 處理方式可以採直接修改 Leo Editor 5.3 版的原始碼, 或者安裝完 5.0b2 版之後, 再將 5.3 版的程式碼取代 /usr/local/lib/python3.5/dist-packages/leo 中的內容. 另外, 利用 pip3 移除模組的指令如下: sudo pip3 --proxy=[2001:288:6004:17::17]:3128 uninstall leo 而在 Ubuntu 16.04 中移除 apt 所安裝的模組, 則必須使用: sudo apt remove python3-pyqt4 完成 Leo Editor 安裝後, 就可以利用 leo& 啟動. 純 IPV6 環境下的 wsgi 程式 當 Virtualbox 環境下的各虛擬機器, 利用 Bridged 網路設定, 成為一台廣域網路上的伺服器之後, 假如要以 IPV6 網址執行 wsgi 程式, 可以修改 CMSimply 的設定: if inOpenshift: # operate in OpenShift application = cherrypy.Application(root, config = application_conf) else: # operate in localhost cherrypy.server.socket_port = 8080 cherrypy.server.socket_host = '2001:288:6004:17::6666' cherrypy.quickstart(root, config = application_conf) 然後透過 http://[2001:288:6004:17::6666]:8080 擷取 CMSimply wsgi 網際程式, 但是目前的 CMSimply 系統中的 html editor 為 tinymce3, 無法正確解析 IPV6 網址, 因此需要改用最新的 tinymce4 才行. 但是, 隨著改用 tinymce4, 後續衍生的問題就是必須再將先前已經在 tinymce3 實現的各種 html 上傳檔案與圖片整合的程序, 全部修改為 tinymce4 相容. Virtualbox 虛擬機器採用純 IPV6 結論 隨著操作系統版本不斷更新, 而且各單位轉用 IPV6 的需求日益增高, 許多過去所使用的流程與架構都被迫必須修改因應: 就各純 IPV6 環境架設的虛擬機器, 至少需要以下代理主機設定, 來配合許多僅支援 IPV4 的服務主機: git 指令的代理, 使用 git config --global http.proxy http://[2001:288:6004:17::17]:3128 apt 或 apt-get 的代理, 必須建立 /etc/apt/apt.conf, 並納入代理主機的設定: Acquire::http::Proxy \"http://username:password@your.proxy.server:3128\"; pip3 的代理, 則採用 sudo pip3 --proxy=[2001:288:6004:17::17]:3128 install leo 除了上述的程式安裝代理, 後續還有 sftp 的代理, 工程軟體套件的認証協定, 也都必須配合 IPV4 轉進到 IPV6 逐一處理."},{"url":"http://cadlab.mde.tw/post/kua-cao-zuo-xi-tong-de-virtualbox-vdi-dang-an.html","tags":"導引","title":"跨操作系統的 Virtualbox vdi 檔案","text":"在這個展示中, 我們利用 Windows 7 操作系統中的 Virtualbox 5.0 建立了一個 Windows 7 pro 操作系統的虛擬機器 vdi 檔案後, 將這個 64 位元的 Windows 7 pro 檔案轉到 Ubuntu Virtualbox 中, 用來建立 新的 Windows 7 虛擬機器, 其中分別啟用三種虛擬網路卡的設定, 也就是分別將虛擬網卡設定為 NAT, Host-only 與 Bridged 網路, 主要目的在說明這三種虛擬網路的使用時機與設定細節. NAT 網路設定 通常使用者在虛擬機器中建立虛擬 NAT 網路卡, 在於讓虛擬機器利用網路轉址上網, 其中的設定只需要在 Virtualbox 的 File-Preference-Network 中加入對應的 NAT 設定, 決定該網路卡的名稱, 網路 CIDR, 是否啟用 DHCP, 以及是否支援 IPV6 協定與 Port Forwarding 等, 至於在個人虛擬機器中, 與此 NAT 網路對應的虛擬網路卡只要設定為透過 DHCP 取得 CIDR 所選用的網段網路 IP 位址, 就能以 NAT 方式上網. 當然, 從 File-Preference-Network 中的 NAT Networks 頁面中, 可以發現使用者可以建立多個 global configuration 對應的 NAT 網路, 並給予不同的名稱, 好讓隨後的虛擬機器中選用 NAT 啟動的虛擬網路卡時, 可以配合納入不同的網段, 模擬各種需求的網路架構. 以下這一張圖就是在 Ubuntu 操作系統中, File-Preference-Network 設定選項, 也就是所謂的 global configuration 設定, 這裡的設定適用於所有這個操作系統下 Virtualbox 所屬的虛擬機器. 當使用者進 File-Preference-Network 中的網路設定, 選擇新增 NAT 網路時, 呈現的畫面如下, NatNetwork 就是這個 NAT 網路的內定名稱, 假如使用者新增第二個 NAT 網路, 內定名稱就是 NatNetwork1, 當使用者建立虛擬機器, 並在虛擬機器中選擇建立 NAT 虛擬網路卡時, 就可以配合需要, 將該網路卡納入 NatNetwork 或 NatNetwork1 網段, 以取得不同網段的位址與設定. 接下來這個畫面就是有關 File-Preference-Network global configuration 中有關網路設定的第二個頁面, 也就是 Host-only 網路的設定頁面, 這是用來新增 \"僅限主機\" 網路中的喜好設定, 當使用者增加一組 Host-only 網路設定時, 就可以選擇該網路的網段與是否啟用虛擬的 DHCP 服務, 這項功能隨後再來說明. 而下面這張圖, 就是針對個別虛擬機器的網路卡設定, 這裡啟用的第1張網路卡, 選擇使用 NAT 設定, 從畫面上顯示, 選用的是最簡單的 NAT (而不是可以選擇網段的 NAT NetWork, 如前所述, 若選擇 NAT NetWork, 可以再對應到 NatNetwork 或 NatNetwork1 NAT 網路名稱), 這裡選擇 NAT, 目的純脆是讓虛擬機器上網. 接下來, 有關虛擬的 NAT 網路卡, 在對應的 Windows 7 操作系統中開機之後的網路設定畫面, 只要確定與 NAT 網路對應的虛擬網卡, 選擇所使用的 IPV4 或 IPV6 協定, 並讓該網卡以 DHCP client, 自動取得 IP 與網路設定即可. 這裡要特別提醒的是, 假如某一個虛擬機器啟用多片網路卡之後, 不同屬性的虛擬網卡只能透過 MAC 位址加以對應, 假如是在 Windows 虛擬操作系統, 可以利用命令列, 以 ipconfig /all 取得所有與網路相關的設定, 假如是在 Ubuntu 虛擬操作系統, 則採用 ifconfig. Host-only 網路設定與 tinyproxy 接著, 我們來看看與 Host-only 相關的網路設定, 先前的網誌已經談過, Host-only 建置的主要目的, 通常在讓虛擬機器與 Host 間透過虛擬交換器, 讓 Host 的實體網路卡與虛擬機器的虛擬網路卡, 連接在同一個網段上, 而這個網段所使用的設定分為 global configuration 與個別虛擬機器的設定. global configuration 可在 File-Preference-Network 的 Host-only Network 頁面中新增一個對應虛擬網卡, 而每一個虛擬 Host-only 網卡 global 設定, 可以決定所要使用的區域網路段, 這裡選擇不啟用 DHCP, 而是自行在虛擬機器的 Host-only 虛擬網卡設定固定 IPV4 與 IPV6 網址. 下圖就是設定 File-Preference-Network 的地方: 使用者可以進入 Host-only 頁面, 新增一個 Host-only 的全域用虛擬網路設定. 從下圖可以看到, 新增了一個 Host-only 的 vboxnet0 網路, 以及 Adapter 與 DHCP Server 的相關設定. 必須特別注意的是, 這裡的設定會影響 Host 操作系統中 (再提醒一下, 是 Host 中的虛擬網卡 ,而不是虛擬機器中的虛擬網路卡) 所產生的 Host-only 虛擬網路卡中的設定 (使用者無需手動設定, 當然也不可以自行手動修改設定, 因為必須與 Virtualbox 中的虛擬交換器與虛擬 DHCP 伺服器彼此對應) , 並且決定虛擬機器中加入此 Host-only 網路設定 (也就是 vboxnet0, 或其他 Host-only 網路設定, 分別以不同名稱對應) 中虛擬網卡所相依的設定. 例如, 下圖中的 Host-only Network Details 畫面中使用的 IPV4 位址為 192.168.56.1, 就表示 Host 中與此一 Host-only 對應的的虛擬網卡, 會採用這個網路位址設定. 至於 DHCP Server 的設定, 如下圖所示, 假如啟用 DHCP, 且令其產生一個虛擬的 DHCP 伺服器, 可以設定該伺服器的網址與所能分配的網路位 IP 位址範圍: 但是一般在機械設計分析與模擬的情境下, 選用 Host-only 虛擬網路, 通常是要在虛擬機器與 Host 之後配置固定 IP 的各種伺服器, 因此就必須如下圖, 不啟用 DHCP, 而是在各虛擬機器中選擇所附屬的 Host-only 網路設定 (如附屬到前述的 vboxnet0, 或其他 Host-only 網路設定) 後, 配合該網路段, 設定固定 IP 位址. 處理好了 Host-only global configuration 設定後, 接下來就是配合在虛擬機器中, 啟用 Host-only 的網路卡, 如下圖所示, 我們將該虛擬網路卡附屬到 vboxnet0 設定, 並且選擇網路卡的型號, 並且設定 MAC 位址. 完成設定後, 可以從下圖見到 test 虛擬機器中的虛擬網路卡已經透過 Host-only 配置到 vboxnet0 的設定中: 接下來, 將 test 虛擬機器開機, 下圖就是配合 vboxnet0 中所選擇的 192.168.56.1 作為虛擬網路的通道 (gateway), 完成設定, 但是從下圖可以看到, 該虛擬機器僅與 Host 操作系統中的虛擬網卡, 以虛擬交換器相連, 因為屬於內部網路段, 並沒有任何虛擬 NAT 或橋接, 讓此一 192.168.56.0/24 的網路連上廣域網路, 因此若這時啟動 Chrome, 在不使用 Host 機器中的代理主機情況下, 將無法上網. 有關 Host 操作系統中的代理主機 (proxy server), 先前我們在 Windows host 中介紹利用 ccproxy 當作代理主機, 這裡在 Ubuntu 中則利用 sudo apt-get install tinyproxy 安裝 tinyproxy , 並設定允許 VM 連結. 當然也可以在 Host 機器中安裝功能更強的 Squid 作為代理主機. 如下圖所示, 在 Host-only 模式下, 虛擬機器設定了 Host 機器中的代理主機, 就可以順利上網了, 而且虛擬機器中的 git 操作, 也必須透過 git config --global http.proxy http://192.168.56.1:8888 與 git config --global https.proxy http://192.168.56.1:8888 才能連上廣域網路. 接著, 在 Host-only 的網路設定中, 為了讓虛擬機器中的 Filezilla 可以經由 tinyproxy 代理主機以 SFTP 連線, 則該 proxy 必須允許 port 22 進行 connect 資料傳送, 以下為 tinyproxy 的參考用設定檔: ## ## tinyproxy.conf -- tinyproxy daemon configuration file ## ## This example tinyproxy.conf file contains example settings ## with explanations in comments. For decriptions of all ## parameters, see the tinproxy.conf(5) manual page. ## # # User/Group: This allows you to set the user and group that will be # used for tinyproxy after the initial binding to the port has been done # as the root user. Either the user or group name or the UID or GID # number may be used. # User nobody Group nogroup # # Port: Specify the port which tinyproxy will listen on. Please note # that should you choose to run on a port lower than 1024 you will need # to start tinyproxy using root. # tinyproxy 代理主機所使用的埠號 Port 8888 # # Listen: If you have multiple interfaces this allows you to bind to # only one. If this is commented out, tinyproxy will bind to all # interfaces present. # #Listen 192.168.0.1 # # Bind: This allows you to specify which interface will be used for # outgoing connections. This is useful for multi-home'd machines where # you want all traffic to appear outgoing from one particular interface. # #Bind 192.168.0.1 # # BindSame: If enabled, tinyproxy will bind the outgoing connection to the # ip address of the incoming connection. # #BindSame yes # # Timeout: The maximum number of seconds of inactivity a connection is # allowed to have before it is closed by tinyproxy. # Timeout 600 # # ErrorFile: Defines the HTML file to send when a given HTTP error # occurs. You will probably need to customize the location to your # particular install. The usual locations to check are: # /usr/local/share/tinyproxy # /usr/share/tinyproxy # /etc/tinyproxy # #ErrorFile 404 \"/usr/share/tinyproxy/404.html\" #ErrorFile 400 \"/usr/share/tinyproxy/400.html\" #ErrorFile 503 \"/usr/share/tinyproxy/503.html\" #ErrorFile 403 \"/usr/share/tinyproxy/403.html\" #ErrorFile 408 \"/usr/share/tinyproxy/408.html\" # # DefaultErrorFile: The HTML file that gets sent if there is no # HTML file defined with an ErrorFile keyword for the HTTP error # that has occured. # DefaultErrorFile \"/usr/share/tinyproxy/default.html\" # # StatHost: This configures the host name or IP address that is treated # as the stat host: Whenever a request for this host is received, # Tinyproxy will return an internal statistics page instead of # forwarding the request to that host. The default value of StatHost is # tinyproxy.stats. # #StatHost \"tinyproxy.stats\" # # # StatFile: The HTML file that gets sent when a request is made # for the stathost. If this file doesn't exist a basic page is # hardcoded in tinyproxy. # StatFile \"/usr/share/tinyproxy/stats.html\" # # Logfile: Allows you to specify the location where information should # be logged to. If you would prefer to log to syslog, then disable this # and enable the Syslog directive. These directives are mutually # exclusive. # Logfile \"/var/log/tinyproxy/tinyproxy.log\" # # Syslog: Tell tinyproxy to use syslog instead of a logfile. This # option must not be enabled if the Logfile directive is being used. # These two directives are mutually exclusive. # #Syslog On # # LogLevel: # # Set the logging level. Allowed settings are: # Critical (least verbose) # Error # Warning # Notice # Connect (to log connections without Info's noise) # Info (most verbose) # # The LogLevel logs from the set level and above. For example, if the # LogLevel was set to Warning, then all log messages from Warning to # Critical would be output, but Notice and below would be suppressed. # LogLevel Info # # PidFile: Write the PID of the main tinyproxy thread to this file so it # can be used for signalling purposes. # PidFile \"/var/run/tinyproxy/tinyproxy.pid\" # # XTinyproxy: Tell Tinyproxy to include the X-Tinyproxy header, which # contains the client's IP address. # #XTinyproxy Yes # # Upstream: # # Turns on upstream proxy support. # # The upstream rules allow you to selectively route upstream connections # based on the host/domain of the site being accessed. # # For example: # # connection to test domain goes through testproxy # upstream testproxy:8008 \".test.domain.invalid\" # upstream testproxy:8008 \".our_testbed.example.com\" # upstream testproxy:8008 \"192.168.128.0/255.255.254.0\" # # # no upstream proxy for internal websites and unqualified hosts # no upstream \".internal.example.com\" # no upstream \"www.example.com\" # no upstream \"10.0.0.0/8\" # no upstream \"192.168.0.0/255.255.254.0\" # no upstream \".\" # # # connection to these boxes go through their DMZ firewalls # upstream cust1_firewall:8008 \"testbed_for_cust1\" # upstream cust2_firewall:8008 \"testbed_for_cust2\" # # # default upstream is internet firewall # upstream firewall.internal.example.com:80 # # The LAST matching rule wins the route decision. As you can see, you # can use a host, or a domain: # name matches host exactly # .name matches any host in domain \"name\" # . matches any host with no domain (in 'empty' domain) # IP/bits matches network/mask # IP/mask matches network/mask # #Upstream some.remote.proxy:port # # MaxClients: This is the absolute highest number of threads which will # be created. In other words, only MaxClients number of clients can be # connected at the same time. # MaxClients 100 # # MinSpareServers/MaxSpareServers: These settings set the upper and # lower limit for the number of spare servers which should be available. # # If the number of spare servers falls below MinSpareServers then new # server processes will be spawned. If the number of servers exceeds # MaxSpareServers then the extras will be killed off. # MinSpareServers 5 MaxSpareServers 20 # # StartServers: The number of servers to start initially. # StartServers 10 # # MaxRequestsPerChild: The number of connections a thread will handle # before it is killed. In practise this should be set to 0, which # disables thread reaping. If you do notice problems with memory # leakage, then set this to something like 10000. # MaxRequestsPerChild 0 # # Allow: Customization of authorization controls. If there are any # access control keywords then the default action is to DENY. Otherwise, # the default action is ALLOW. # # The order of the controls are important. All incoming connections are # tested against the controls based on order. # Allow 127.0.0.1 # 設定允許使用 tinyproxy 代理主機的網路段 Allow 192.168.56.0/24 #Allow 192.168.0.0/16 #Allow 172.16.0.0/12 #Allow 10.0.0.0/8 # # AddHeader: Adds the specified headers to outgoing HTTP requests that # Tinyproxy makes. Note that this option will not work for HTTPS # traffic, as Tinyproxy has no control over what headers are exchanged. # #AddHeader \"X-My-Header\" \"Powered by Tinyproxy\" # # ViaProxyName: The \"Via\" header is required by the HTTP RFC, but using # the real host name is a security concern. If the following directive # is enabled, the string supplied will be used as the host name in the # Via header; otherwise, the server's host name will be used. # ViaProxyName \"tinyproxy\" # # DisableViaHeader: When this is set to yes, Tinyproxy does NOT add # the Via header to the requests. This virtually puts Tinyproxy into # stealth mode. Note that RFC 2616 requires proxies to set the Via # header, so by enabling this option, you break compliance. # Don't disable the Via header unless you know what you are doing... # #DisableViaHeader Yes # # Filter: This allows you to specify the location of the filter file. # #Filter \"/etc/filter\" # # FilterURLs: Filter based on URLs rather than domains. # #FilterURLs On # # FilterExtended: Use POSIX Extended regular expressions rather than # basic. # #FilterExtended On # # FilterCaseSensitive: Use case sensitive regular expressions. # #FilterCaseSensitive On # # FilterDefaultDeny: Change the default policy of the filtering system. # If this directive is commented out, or is set to \"No\" then the default # policy is to allow everything which is not specifically denied by the # filter file. # # However, by setting this directive to \"Yes\" the default policy becomes # to deny everything which is _not_ specifically allowed by the filter # file. # #FilterDefaultDeny Yes # # Anonymous: If an Anonymous keyword is present, then anonymous proxying # is enabled. The headers listed are allowed through, while all others # are denied. If no Anonymous keyword is present, then all headers are # allowed through. You must include quotes around the headers. # # Most sites require cookies to be enabled for them to work correctly, so # you will need to allow Cookies through if you access those sites. # #Anonymous \"Host\" #Anonymous \"Authorization\" #Anonymous \"Cookie\" # # ConnectPort: This is a list of ports allowed by tinyproxy when the # CONNECT method is used. To disable the CONNECT method altogether, set # the value to 0. If no ConnectPort line is found, all ports are # allowed (which is not very secure.) # # The following two ports are used by SSL. # # for HTTPS ConnectPort 443 ConnectPort 563 # 為了讓虛擬機器中的 filezilla 可以透過 SFTP 協定傳輸, 必須允許使用 port 22 ConnectPort 22 # # Configure one or more ReversePath directives to enable reverse proxy # support. With reverse proxying it's possible to make a number of # sites appear as if they were part of a single site. # # If you uncomment the following two directives and run tinyproxy # on your own computer at port 8888, you can access Google using # http://localhost:8888/google/ and Wired News using # http://localhost:8888/wired/news/. Neither will actually work # until you uncomment ReverseMagic as they use absolute linking. # #ReversePath \"/google/\" \"http://www.google.com/\" #ReversePath \"/wired/\" \"http://www.wired.com/\" # # When using tinyproxy as a reverse proxy, it is STRONGLY recommended # that the normal proxy is turned off by uncommenting the next directive. # #ReverseOnly Yes # # Use a cookie to track reverse proxy mappings. If you need to reverse # proxy sites which have absolute links you must uncomment this. # #ReverseMagic Yes # # The URL that's used to access this reverse proxy. The URL is used to # rewrite HTTP redirects so that they won't escape the proxy. If you # have a chain of reverse proxies, you'll need to put the outermost # URL here (the address which the end user types into his/her browser). # # If not set then no rewriting occurs. # #ReverseBaseURL \"http://localhost:8888/\" Bridged 網路設定 接下來, 則是 Bridged network 的應用, 先前已經提過, 虛擬機器採用 Bridged 設定的目的在於讓虛擬機器可以藉由 host 電腦的實體網路卡, 充當一台虛擬的伺服器. 當使用者在建立虛擬機器的過程, 啟用 Bridged 網路卡時, 就必須選擇 host 電腦上, 所要附加的一片實體網路卡, 經過實作, 即便在只有一片實體網路卡的電腦, 也可以將此唯一的實體網卡附加給虛擬機器中的 Bridged 虛擬網路卡, 以下的網路情境是 Host 為 Ubuntu 操作系統採用光世代路由器, 以 IPV4 tunnel 啟用 IPV6 網路協定, 因此一旦 Windows 7 中的虛擬機器選擇將虛擬網卡, 以 bridged network 的設定, 附加到 Ubuntu 操作系統中唯一的網路卡時, 就 Ubuntu 操作系統所對應的連外網路來說, Windows 7 的這一片虛擬網卡, 就成為一張可以獨立設定與運作的網路卡 (儘管是虛擬產生, 且透過虛擬交換器與實體網卡相連), 由於此時 Host 機器中的實體網路卡是直接連光世代的 NAT/DHCP 上網, 因此若將虛擬機器 Windows 7 中的這片 bridged 虛擬網卡設為採 DHCP client 連網, 則這片網卡也能透過虛擬的交換器與 Ubuntu 的實體網卡同位階, 以 DHCP 取得光世代的網路設定而連接到廣域網路, 如下圖所示: 讓我們再回頭看看 bridged 網路的設定, 選用 bridged 網路設定後的虛擬機器 Windows 7 網卡採自動取得網路設定: Virtualbox 的 global configuratin 網路設定中, 可以無需建立任何 NAT 或 Host-only 的設定: 只需要在個別的虛擬機器網路設定中, 啟用 Bridged 網路時, 與 Host 中的實體網路卡進行綁定 (這裡 attached 到 Ubuntu 操作系統中的 p10p1 實體網路卡): Virtualbox 網路設定結論 從上面與 Virtualbox 網路設定有關的三種模式: NAT, Host-only 與 Bridged, 各有不同的特性, NAT 可以簡便地讓虛擬機器上網, Host-only 可以在主機範圍以內的虛擬網域中創造出多台內部伺服器, 而 Bridged 網路則透過 Host 實體網路卡的驅動程式與實體的網路卡接線, 在虛擬機器中模擬出一片如假包換的網路卡, 可以讓外部網路上的主機, 直接連線到虛擬機器中的各種伺服服務. 就 MDE CADLab 的實際配置而言, 我們在 Windows 7 Host 操作系統中配置 Ubuntu 虛擬機器, 並採用 http://vboxvmservice.sourceforge.net/ 服務自動啟用, 然後在 Ubuntu 虛擬操作系統中配置固定的 IPV4 與 IPV6 網路位址, 安裝配置支援雙網路協定的 Squid 代理主機後, 接著再透過 Bridged 網路設定讓其他純 IPV6 上網的電腦, 就能透過這些 Squid 代理主機連線到 IPV4 與 IPV6 的網路服務器. 最後, 當我們在安裝配置各種電腦輔助設計、工程分析、電腦輔助製造與自動控制相關套件時, 可以在一台機器中完成多元的安裝配置與測試, 並且希望未來能將這些實際配置的過程納入相關課程教學之中."},{"url":"http://cadlab.mde.tw/post/ji-jie-she-ji-gong-cheng-xi-ipv6-wang-zhi-fen-pei.html","tags":"規劃","title":"機械設計工程系 IPV6 網址分配","text":"虎尾科大機械設計工程系將自即日起逐步啟用 IPV6 網路協定, 目前只有與軟體授權認証 (因為要服務廣域網路上僅支援 IPV4 協定的用戶連線) 及同時支援 IPV4/IPV6 協定的代理主機, 一定需要配置固定的 IPV4 網路位址外, 其他單純的網路連線均可採用純 IPV6 協定配置, 以純 IPV6 協定上網者, 若須連線到僅支援 IPV4 網路協定的主機, 請透過提供 IPV4/IPV6 雙支援的代理主機進行連線. 以下為各 MDE 使用群組的 IPV6 網址分配: table, th, td { border: 1px solid black; border-collapse: collapse; } th, td { padding: 15px; } MDE 群組 分配 IPV6 網段 說明 備註 MDE 行政專用 2001:288:6004:17:168:0000:0000:0000 ~ 2001:288:6004:17:168:FFFF:FFFF:FFFF 所有行政支援相關的裝置均採此網段設定, 各行政人員再依員工編號設定所屬的裝置網址 prefix 設為 64 gateway 設為 2001:288:6004:17::254 dns 伺服器設為: 2001:288:6004:1::2 (虎科大) 與 2001:b000:168::1 (中華電信) (以管理人員員工編號尾碼為 3026 為例) 2001:288:6004:17:168:3026:0000:0000 ~ 2001:288:6004:17:168:3026:FFFF:FFFF 以管理人員編號 B03026 為例, 取 3026 作為設定代號 prefix 設為 64 gateway 設為 2001:288:6004:17::254 dns 伺服器設為: 2001:288:6004:1::2 (虎科大) 與 2001:b000:168::1 (中華電信) MDE 各教師 (以教師員工編號尾碼為 3001 為例) 2001:288:6004:17:3001:0000:0000:0000 ~ 2001:288:6004:17:3001:FFFF:FFFF:FFFF 所有與教師相關的裝置均採此網段設定, 取各教師員工編號最後四碼作為設定代號 prefix 設為 64 gateway 設為 2001:288:6004:17::254 dns 伺服器設為: 2001:288:6004:1::2 (虎科大) 與 2001:b000:168::1 (中華電信) MDE 工作站室 2001:288:6004:17:0000:0000:0000:0000 ~ 2001:288:6004:17:0000:0000:0000:FFFF 所有 8F 工作站室相關的裝置均採此網段設定 prefix 設為 64 gateway 設為 2001:288:6004:17::254 dns 伺服器設為: 2001:288:6004:1::2 (虎科大) 與 2001:b000:168::1 (中華電信) MDE 6F 教學實驗室 2001:288:6004:17:6F:0000:0000:0000 ~ 2001:288:6004:17:6F:FFFF:FFFF:FFFF 所有 6F 與教學相關的裝置均採此網段設定, 各教學實驗室再依教室編號最後四碼設定所屬的裝置網址 prefix 設為 64 gateway 設為 2001:288:6004:17::254 dns 伺服器設為: 2001:288:6004:1::2 (虎科大) 與 2001:b000:168::1 (中華電信) (以實驗室編號尾碼為 6768 為例) 2001:288:6004:17:6F:6768:0000:0000 ~ 2001:288:6004:17:6F:6768:FFFF:FFFF 以 6F 實驗室編號最後四碼為 6768 為例, 取 6768 作為設定代號 prefix 設為 64 gateway 設為 2001:288:6004:17::254 dns 伺服器設為: 2001:288:6004:1::2 (虎科大) 與 2001:b000:168::1 (中華電信) MDE 7F 教學實驗室 2001:288:6004:17:7F:0000:0000:0000 ~ 2001:288:6004:17:7F:FFFF:FFFF:FFFF 所有 7F 與教學相關的裝置均採此網段設定, 各教學實驗室再依教室編號最後四碼設定所屬的裝置網址 prefix 設為 64 gateway 設為 2001:288:6004:17::254 dns 伺服器設為: 2001:288:6004:1::2 (虎科大) 與 2001:b000:168::1 (中華電信) (以實驗室編號尾碼為 7768 為例) 2001:288:6004:17:7F:7768:0000:0000 ~ 2001:288:6004:17:7F:7768:FFFF:FFFF 以 7F 實驗室編號最後四碼為 7768 為例, 取 7768 作為設定代號 prefix 設為 64 gateway 設為 2001:288:6004:17::254 dns 伺服器設為: 2001:288:6004:1::2 (虎科大) 與 2001:b000:168::1 (中華電信) MDE 8F 教學實驗室 2001:288:6004:17:8F:0000:0000:0000 ~ 2001:288:6004:17:8F:FFFF:FFFF:FFFF 所有 8F 與教學相關的裝置均採此網段設定, 各教學實驗室再依教室編號最後四碼設定所屬的裝置網址 prefix 設為 64 gateway 設為 2001:288:6004:17::254 dns 伺服器設為: 2001:288:6004:1::2 (虎科大) 與 2001:b000:168::1 (中華電信) (以實驗室編號尾碼為 8768 為例) 2001:288:6004:17:8F:8768:0000:0000 ~ 2001:288:6004:17:8F:8768:FFFF:FFFF 以 8F 實驗室編號最後四碼為 8768 為例, 取 8768 作為設定代號 prefix 設為 64 gateway 設為 2001:288:6004:17::254 dns 伺服器設為: 2001:288:6004:1::2 (虎科大) 與 2001:b000:168::1 (中華電信) MDE 9F 教學實驗室 2001:288:6004:17:9F:0000:0000:0000 ~ 2001:288:6004:17:9F:FFFF:FFFF:FFFF 所有 9F 與教學相關的裝置均採此網段設定, 各教學實驗室再依教室編號最後四碼設定所屬的裝置網址 prefix 設為 64 gateway 設為 2001:288:6004:17::254 dns 伺服器設為: 2001:288:6004:1::2 (虎科大) 與 2001:b000:168::1 (中華電信) (以實驗室編號尾碼為 9768 為例) 2001:288:6004:17:9F:9768:0000:0000 ~ 2001:288:6004:17:9F:9768:FFFF:FFFF 以 9F 實驗室編號最後四碼為 9768 為例, 取 9768 作為設定代號 prefix 設為 64 gateway 設為 2001:288:6004:17::254 dns 伺服器設為: 2001:288:6004:1::2 (虎科大) 與 2001:b000:168::1 (中華電信) MDE 其他應用 2001:288:6004:17:a:0000:0000:0000 ~ 2001:288:6004:17:a:FFFF:FFFF:FFFF 所有未納入上列相關的裝置均採此網段設定 prefix 設為 64 gateway 設為 2001:288:6004:17::254 dns 伺服器設為: 2001:288:6004:1::2 (虎科大) 與 2001:b000:168::1 (中華電信) 各 MDE 用戶若在校外採用中華電信光世代上網, 需啟用 IPV6 協定, 請參考 http://www.ipv6.hinet.net/ 相關說明, 一旦啟用 IPV6 網路協定後, 可以利用 http://[2001:288:6004:17::101]/ 與 http://test-ipv6.com/ 進行 IPV6 網路連線測試. 從下圖可以發現目前中華電信光世代所提供的 IPV6 網路連線採用 IPV4 Tunnel 技術, 可以同時支援 IPV4/IPV6 雙協定連線:"},{"url":"http://cadlab.mde.tw/post/virtualbox-de-ying-yong-yu-wang-lu-she-ding-er.html","tags":"導引","title":"Virtualbox 的應用與網路設定 (二)","text":"透過 Virtualbox 的使用說明: https://www.virtualbox.org/manual/ 可以了解一個 Virtualbox 的虛擬機器, 若啟用 ICH9 Chipset, 最多可以 支援 36 片網路卡 . Virtualbox 虛擬機器最多可以支援 36 片網路卡 如下圖所示: 至於 host-only 的網路卡設定 正好介於 bridged 與 internal 網路設定特性之間. 也就是說 host-only 網路卡設定與 bridged 網路卡設定類似, 可以想像各採用 host-only 設定的虛擬機器與 host 機器的網路線全部接到同一台network switch (網路交換器), 不僅可以彼此連線, 也能與 host 連線. 但是 host-only 網路卡設定與 bridged network 設定的差異是, host-only 無需與任何實體網路卡進行橋接, 而是透過位於 host 機器上的虛擬網路卡達到與各虛擬機器及 host 網路相連的目的. 而 host-only 網路卡設定與 internal 網路設定類似的地方, 在於這些設定為 host-only 網路卡相連的虛擬機器無法與 host 以外的網路相連. 另外, 透過 bridged 網路卡設定說明: https://www.virtualbox.org/manual/ch06.html#network_bridged , 我們也可以得知, 所謂虛擬機器的橋接網路連線設定, 就是要讓虛擬機器透過 host 上的實體網路卡, 與外部的網路相連, 成為一台與 host 位階相同的伺服機器. 虛擬機器與虛擬硬碟的 uuid 編號 至於在使用 Virtualbox 的過程, 當使用者需要設定虛擬機器的 uuid 時, 可以透過下列 Python3 程式產生 uuid. import uuid print(uuid.uuid1()) #UUID('5361a11b-615c-42bf-9bdb-e2c3790ada14') 接著再利用: VBoxManage startvm \"Your VM name\", 使用 Virtualbox 指定的 uuid, 或者自行指定虛擬機器的 uuid. VBoxManage startvm \"Your VM name\" 5361a11b-615c-42bf-9bdb-e2c3790ada14 由於虛擬機器的 uuid 只用於 global configuration data 的設定, 以及各虛擬機器啟動時的基本辨識, 因此也可以直接在設定檔案中更改, 只要前後呼應即可. 但是虛擬硬碟的對應 uuid 則與 .vdi 檔案綁定, 因此根據 https://www.virtualbox.org/manual/ch08.html#vboxmanage-clonevdi 中的說明, 可以利用: VBoxManage clonemedium Master.vdi Clone.vdi 手動進行 vdi 檔案的複製, 基本概念是存在同一個 host 中的虛擬機器個別要有一個 uuid 編號, 而這個編號會在 host 中所安裝的 Virtualbox 套件中, 經由 preferances 設定檔案與個別虛擬機器引用時進行對應, 至於虛擬硬碟的 uuid, 除了與 .vdi 綁定, 也會在個別虛擬機器的設定檔案中前後出現兩次. 但是若 Master.vdi 在下 VBoxManage.exe 指令的 Host 機器上, 已經註冊在虛擬機器中, 則必須要先更改虛擬機器的硬碟 .vdi 檔案之後, 才能夠執行 clonemedium 指令: 也就是必須先執行: \"c:\\Program Files\\Oracle\\VirtualBox\\VBoxManage.exe\" internalcommands sethduuid registered_vdi.vdi 然後再執行: \"c:\\Program Files\\Oracle\\VirtualBox\\VBoxManage.exe\" clonemedium registered_vdi.vdi new_vdi.vdi 之後若在同一個 Virtualbox 的主體中利用此一 new_vdi.vdi 建立虛擬機器, 就不會發生硬碟 uuid 編號重複的問題. 至於 Global configuration data 檔案的存放位置, 根據 https://www.virtualbox.org/manual/ch10.html#idm8784 的說明, 在視窗操作系統會存在 HOME/.VirtualBox 目錄, 以 xml 格式儲存, 在 Linux 與 Solaris 操作系統中, 則儲存在 HOME/.config/VirtualBox 目錄中, 假如是 OS X 操作系統, 則會儲存在 HOME/Library/VirtualBox. 值得一提的是, 當操作系統中 Virtualbox 沒有開啟時, 使用者可以直接修改上述的相關設定檔案, 例如, Virtualbox 的 GUI 介面中 ,只能讓一個虛擬機器啟用 4 片網路卡, 假如使用者需要啟用第 5 ~ 36 片網路卡時, 可以根據 https://www.virtualbox.org/manual/ch08.html#idm4023 的說明, 利用 VBoxManage modifyvm 指令進行設定, 或者直接編輯相關的設定檔案達成. Virtualbox 虛擬機器檔案跨操作系統應用 以下則是在 Windows 7 Pro 電腦上啟動 Vt-x, 建立 64 位元的 Windows 7 虛擬機器後, 將虛擬機器檔案轉到 Ubuntu 的 Virtualbox 上, 然後根據上述說明, 啟動 36 片虛擬網路卡的過程畫面: 首先是從網路上下載 Windows 7 64 位元的虛擬機器檔案壓縮檔, 然後解開壓縮檔, 準備在 Ubuntu 上的 Virtualbox 建立虛擬機器: 接著是解開壓縮檔案之後的 Windows 7 虛擬機器檔案, 其中包括 .vdi 與兩個虛擬機器的設定檔: 利用解開壓縮的 .vdi 檔案, 在 Ubuntu 上的 Virtualbox 建立虛擬機器, 每一個虛擬機器都對應一個 .vdi 檔案與兩個設定檔案: 接下來是 Ubuntu 上的虛擬機器準備開機的畫面: 接著是虛擬機器在 Ubuntu 上開啟 Windows 7 的畫面, 測試 V-rep, 可攜 Python3 程式環境啟動, 開啟 Leo Editor 與 Jypyter 的畫面: 最後則是在 Windows 7 虛擬機器中創建 36 張虛擬網路卡的畫面: 虛擬機器設定檔案 以下則為創建 36 片虛擬網路卡的虛擬機器設定檔案: <?xml version=\"1.0\"?> <!-- ** DO NOT EDIT THIS FILE. ** If you make changes to this file while any VirtualBox related application ** is running, your changes will be overwritten later, without taking effect. ** Use VBoxManage or the VirtualBox Manager GUI to make changes. --> <VirtualBox xmlns=\"http://www.innotek.de/VirtualBox-settings\" version=\"1.14-linux\"> <Machine uuid=\"{2d4c505c-6d5c-430b-9e07-e7cc478d3386}\" name=\"test\" OSType=\"Windows7_64\" snapshotFolder=\"Snapshots\" lastStateChange=\"2016-06-18T12:23:49Z\"> <MediaRegistry> <HardDisks> <HardDisk uuid=\"{f03c812c-5a12-496b-bd9a-d235f809d184}\" location=\"/home/amd/VirtualBox VMs/Win7/cadlab_win7_64/cadlab_win7_64.vdi\" format=\"VDI\" type=\"Normal\"/> </HardDisks> <DVDImages/> <FloppyImages/> </MediaRegistry> <ExtraData> <ExtraDataItem name=\"GUI/LastGuestSizeHint\" value=\"1835,986\"/> <ExtraDataItem name=\"GUI/LastNormalWindowPosition\" value=\"710,284,1835,1008\"/> </ExtraData> <Hardware version=\"2\"> <CPU count=\"1\" hotplug=\"false\"> <HardwareVirtEx enabled=\"true\"/> <HardwareVirtExNestedPaging enabled=\"true\"/> <HardwareVirtExVPID enabled=\"true\"/> <HardwareVirtExUX enabled=\"true\"/> <PAE enabled=\"false\"/> <LongMode enabled=\"true\"/> <HardwareVirtExLargePages enabled=\"false\"/> <HardwareVirtForce enabled=\"false\"/> </CPU> <Memory RAMSize=\"1024\" PageFusion=\"false\"/> <HID Pointing=\"USBTablet\" Keyboard=\"PS2Keyboard\"/> <HPET enabled=\"false\"/> <Chipset type=\"ICH9\"/> <Boot> <Order position=\"1\" device=\"Floppy\"/> <Order position=\"2\" device=\"DVD\"/> <Order position=\"3\" device=\"HardDisk\"/> <Order position=\"4\" device=\"None\"/> </Boot> <Display VRAMSize=\"27\" monitorCount=\"1\" accelerate3D=\"false\" accelerate2DVideo=\"false\"/> <VideoCapture enabled=\"false\" screens=\"18446744073709551615\" horzRes=\"1024\" vertRes=\"768\" rate=\"512\" fps=\"25\"/> <RemoteDisplay enabled=\"false\" authType=\"Null\" authTimeout=\"5000\"/> <BIOS> <ACPI enabled=\"true\"/> <IOAPIC enabled=\"true\"/> <Logo fadeIn=\"true\" fadeOut=\"true\" displayTime=\"0\"/> <BootMenu mode=\"MessageAndMenu\"/> <TimeOffset value=\"0\"/> <PXEDebug enabled=\"false\"/> </BIOS> <USB> <Controllers> <Controller name=\"OHCI\" type=\"OHCI\"/> </Controllers> <DeviceFilters/> </USB> <Network> <Adapter slot=\"0\" enabled=\"true\" MACAddress=\"0800277B9303\" cable=\"true\" speed=\"0\" promiscuousModePolicy=\"AllowAll\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> <InternalNetwork name=\"intnet\"/> <NATNetwork name=\"NatNetwork\"/> </DisabledModes> <HostOnlyInterface name=\"vboxnet0\"/> </Adapter> <Adapter slot=\"1\" enabled=\"true\" MACAddress=\"0800278F6747\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> <InternalNetwork name=\"intnet\"/> <NATNetwork name=\"NatNetwork\"/> </DisabledModes> <HostOnlyInterface name=\"vboxnet0\"/> </Adapter> <Adapter slot=\"2\" enabled=\"true\" MACAddress=\"0800272937DA\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> <InternalNetwork name=\"intnet\"/> <NATNetwork name=\"NatNetwork\"/> </DisabledModes> <HostOnlyInterface name=\"vboxnet0\"/> </Adapter> <Adapter slot=\"3\" enabled=\"true\" MACAddress=\"0800270A010D\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> <InternalNetwork name=\"intnet\"/> <NATNetwork name=\"NatNetwork\"/> </DisabledModes> <HostOnlyInterface name=\"vboxnet0\"/> </Adapter> <Adapter slot=\"4\" enabled=\"true\" MACAddress=\"0800273CE501\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"5\" enabled=\"true\" MACAddress=\"08002745C214\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"6\" enabled=\"true\" MACAddress=\"080027AE8437\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"7\" enabled=\"true\" MACAddress=\"080027AD4C2C\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"8\" enabled=\"true\" MACAddress=\"080027B1ECB6\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"9\" enabled=\"true\" MACAddress=\"0800272514D6\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"10\" enabled=\"true\" MACAddress=\"0800272FBEFC\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"11\" enabled=\"true\" MACAddress=\"080027461D31\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"12\" enabled=\"true\" MACAddress=\"08002713AA63\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"13\" enabled=\"true\" MACAddress=\"080027926EC8\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"14\" enabled=\"true\" MACAddress=\"08002730A135\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"15\" enabled=\"true\" MACAddress=\"080027C7A2E5\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"16\" enabled=\"true\" MACAddress=\"080027DEB56D\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"17\" enabled=\"true\" MACAddress=\"080027C72A21\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"18\" enabled=\"true\" MACAddress=\"080027C91346\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"19\" enabled=\"true\" MACAddress=\"080027EA4F42\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"20\" enabled=\"true\" MACAddress=\"08002704BF93\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"21\" enabled=\"true\" MACAddress=\"080027A40974\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"22\" enabled=\"true\" MACAddress=\"08002753975C\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"23\" enabled=\"true\" MACAddress=\"080027ECD7D1\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"24\" enabled=\"true\" MACAddress=\"080027F9E90D\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"25\" enabled=\"true\" MACAddress=\"080027800C0B\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"26\" enabled=\"true\" MACAddress=\"080027F2677A\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"27\" enabled=\"true\" MACAddress=\"080027804C07\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"28\" enabled=\"true\" MACAddress=\"080027FA622A\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"29\" enabled=\"true\" MACAddress=\"0800272BBA95\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"30\" enabled=\"true\" MACAddress=\"080027B65D42\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"31\" enabled=\"true\" MACAddress=\"08002748148E\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"32\" enabled=\"true\" MACAddress=\"080027D7F82D\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"33\" enabled=\"true\" MACAddress=\"08002744A19B\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"34\" enabled=\"true\" MACAddress=\"080027FFCAD2\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> <Adapter slot=\"35\" enabled=\"true\" MACAddress=\"08002711EAF7\" cable=\"true\" speed=\"0\" type=\"82540EM\"> <DisabledModes> <NAT> <DNS pass-domain=\"true\" use-proxy=\"false\" use-host-resolver=\"false\"/> <Alias logging=\"false\" proxy-only=\"false\" use-same-ports=\"false\"/> </NAT> </DisabledModes> </Adapter> </Network> <UART> <Port slot=\"0\" enabled=\"false\" IOBase=\"0x3f8\" IRQ=\"4\" hostMode=\"Disconnected\"/> <Port slot=\"1\" enabled=\"false\" IOBase=\"0x2f8\" IRQ=\"3\" hostMode=\"Disconnected\"/> </UART> <LPT> <Port slot=\"0\" enabled=\"false\" IOBase=\"0x378\" IRQ=\"7\"/> <Port slot=\"1\" enabled=\"false\" IOBase=\"0x378\" IRQ=\"7\"/> </LPT> <AudioAdapter controller=\"HDA\" driver=\"Pulse\" enabled=\"true\"/> <RTC localOrUTC=\"local\"/> <SharedFolders/> <Clipboard mode=\"Disabled\"/> <DragAndDrop mode=\"Disabled\"/> <IO> <IoCache enabled=\"true\" size=\"5\"/> <BandwidthGroups/> </IO> <HostPci> <Devices/> </HostPci> <EmulatedUSB> <CardReader enabled=\"false\"/> </EmulatedUSB> <Guest memoryBalloonSize=\"0\"/> <GuestProperties> <GuestProperty name=\"/VirtualBox/GuestAdd/Components/VBoxControl.exe\" value=\"5.0.20r106931\" timestamp=\"1466252388372790000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Components/VBoxCredProv.dll\" value=\"-\" timestamp=\"1466252388391702000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Components/VBoxDisp.dll\" value=\"5.0.20r106931\" timestamp=\"1466252388376477000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Components/VBoxGINA.dll\" value=\"-\" timestamp=\"1466252388391487000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Components/VBoxGuest.sys\" value=\"5.0.20r106931\" timestamp=\"1466252388435555000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Components/VBoxHook.dll\" value=\"5.0.20r106931\" timestamp=\"1466252388376005000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Components/VBoxMRXNP.dll\" value=\"5.0.20r106931\" timestamp=\"1466252388382593000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Components/VBoxMouse.sys\" value=\"5.0.20r106931\" timestamp=\"1466252388436002000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Components/VBoxOGL.dll\" value=\"5.0.20r106931\" timestamp=\"1466252388433836000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Components/VBoxOGLarrayspu.dll\" value=\"5.0.20r106931\" timestamp=\"1466252388394307000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Components/VBoxOGLcrutil.dll\" value=\"5.0.20r106931\" timestamp=\"1466252388397255000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Components/VBoxOGLerrorspu.dll\" value=\"5.0.20r106931\" timestamp=\"1466252388399115000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Components/VBoxOGLfeedbackspu.dll\" value=\"5.0.20r106931\" timestamp=\"1466252388416093000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Components/VBoxOGLpackspu.dll\" value=\"5.0.20r106931\" timestamp=\"1466252388411664000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Components/VBoxOGLpassthroughspu.dll\" value=\"5.0.20r106931\" timestamp=\"1466252388413562000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Components/VBoxSF.sys\" value=\"5.0.20r106931\" timestamp=\"1466252388436401000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Components/VBoxService.exe\" value=\"5.0.20r106931\" timestamp=\"1466252388379749000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Components/VBoxTray.exe\" value=\"5.0.20r106931\" timestamp=\"1466252388379335000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Components/VBoxVideo.sys\" value=\"5.0.20r106931\" timestamp=\"1466252388436923000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/HostVerLastChecked\" value=\"4.3.36\" timestamp=\"1466252184409813000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/InstallDir\" value=\"C:/Program Files/Oracle/VirtualBox Guest Additions\" timestamp=\"1466252388370068000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Revision\" value=\"106931\" timestamp=\"1466252388369917000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/Version\" value=\"5.0.20\" timestamp=\"1466252388369624000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestAdd/VersionExt\" value=\"5.0.20\" timestamp=\"1466252388369717000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestInfo/OS/Product\" value=\"Windows 7\" timestamp=\"1466252388368633000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/GuestInfo/OS/Release\" value=\"6.1.7600\" timestamp=\"1466252388368805000\" flags=\"\"/> <GuestProperty name=\"/VirtualBox/HostInfo/GUI/LanguageID\" value=\"en_US\" timestamp=\"1466252365654611000\" flags=\"\"/> </GuestProperties> </Hardware> <StorageControllers> <StorageController name=\"IDE\" type=\"PIIX4\" PortCount=\"2\" useHostIOCache=\"true\" Bootable=\"true\"> <AttachedDevice passthrough=\"false\" type=\"DVD\" port=\"1\" device=\"0\"/> </StorageController> <StorageController name=\"SATA\" type=\"AHCI\" PortCount=\"1\" useHostIOCache=\"false\" Bootable=\"true\" IDE0MasterEmulationPort=\"0\" IDE0SlaveEmulationPort=\"1\" IDE1MasterEmulationPort=\"2\" IDE1SlaveEmulationPort=\"3\"> <AttachedDevice type=\"HardDisk\" port=\"0\" device=\"0\"> <Image uuid=\"{f03c812c-5a12-496b-bd9a-d235f809d184}\"/> </AttachedDevice> </StorageController> </StorageControllers> </Machine> </VirtualBox>"},{"url":"http://cadlab.mde.tw/post/dian-nao-fu-zhu-she-ji-shi-dian-nao-ci-qu-gui-hua.html","tags":"規劃","title":"電腦輔助設計室電腦磁區規劃","text":"希望能根據不同性質課程, 將軟體分為 3 個開機磁區: 安裝所有老師提出的上課套件, 集中在第 1 磁區, 其中包括 CAD, CAE, CAM, 數值分析與自動控制相關所有套件. 只安裝 Solidworks, PTC Creo, AutoDesk Inventor, AutoCAD, A360, Ansys, Comsol, Matlab 與 Mathematica, 等 CAD, CAE 與數值分析相關套件. 只安裝操作系統, 加上無需安裝的綠色套件 (PTC, Creo, Comsol, Matlab 等). 至於以上 3 個開機磁區則傾向將新購買的 Windows 10 Pro 操作系統降為 Windows 7 Pro, 以提升使用效能. 但是仍然在第 2 磁區利用 Virtualbox 建立安裝 Windows 10 Pro 的兩台虛擬機器, 其中一台虛擬機配合安裝 Solidworks, PTC Creo, AutoDesk Inventor 與 Matlab , 而另一台虛擬機也採用 Windows 10 Pro 開機, 但只配置各軟體的原始 DVD, 可以讓老師教導學生執行各套件安裝與設定的教學. 至於第 3 磁區則將利用 Virtualbox 建立一台配置 網路代理功能 (IPV4/IPV6 雙支援) 的 Ubuntu Server 虛擬伺服器, 以及一台空白的 Windows 10 Pro 虛擬機, 以便在純 IPV6 環境下進行課程教學. 註解: 根據 https://en.wikipedia.org/wiki/X86_virtualization#Intel-VT-x 與 https://en.wikipedia.org/wiki/List_of_Intel_Core_i7_microprocessors 的說明, 幾乎所有的 Intel CPU 都已經支援 VT-x 虛擬技術, 只要電腦的其他軟硬體配合啟動 VT-x, 就可以在 64 位元的操作系統主體, 模擬 64 位元的虛擬機, 假如再配合 Oracle 的新聞稿: http://www.oracle.com/us/corporate/press/1842885 說明, Virtualbox 中的一台虛擬機 (Virtual Machine) 最多可以啟用 36 片虛擬網路卡, 因此只要電腦主體的硬體支援許可, 利用虛擬機就能有效模擬出相當複雜的網路伺服器架構."},{"url":"http://cadlab.mde.tw/post/virtualbox-de-ying-yong-yu-wang-lu-she-ding.html","tags":"導引","title":"Virtualbox 的應用與網路設定","text":"Virtualbox 是一套能在 Windows, Linux, Mac 與 Solaris 操作系統上使用的虛擬器 (Virtualizer). Virtualbox 功能 虛擬器的功能有下列幾點: 在任一操作系統開機後, 可以同時啟動多種虛擬的操作系統平台, 並且透過虛擬硬體的配置與設定, 執行各種老舊的操作系統應用程式 , 畢竟老應用程式不死, 只是慢慢凋零! 以檔案的架構保留各種電腦軟硬體的配置, 可提升軟體開發效能外, 並可在軟體推銷過程避開多次煩雜的設定 (當然 Docker based 的虛擬技術, 已經逐漸超越這種整套操作系統虛擬的應用). 程式開發者可以在虛擬機器中廣泛透過虛擬的硬體配置, 大膽進行各項操作與測試, 無需擔心損毀電腦週邊實體. 在開機的一台電腦實體中, 可同時模擬多台電腦的運作, 省下操作可能消耗的電力, 降低實體運作與硬體維護成本. Virtualbox 的參考手冊: https://www.virtualbox.org/manual/ 以下將針對 Virtualbox 的網路設定與應用加以說明: Virtualbox 的網路設定模式分為 NAT, Bridged, Internal, Host-only, UDP tunnel 與 VDE 等. NAT 使用情境為啟動虛擬機器後, 當作一般客戶端電腦使用, 虛擬機的連網是透過 NAT 轉址, 以 Host 電腦的網路 IP 對外抓取資料. Bridged 使用情境為啟動虛擬機器後, 當作一般伺服器電腦使用, 在 Host 操作系統中模擬出的虛擬網卡, 可以與 Host 電腦的實體網路卡進行橋接與設定外部 IP 後, 視為網路幹線上的一台伺服器. Internal 使用情境主要關注在虛擬機器之間的網路彼此相連, 但卻自外於與 Host 連接的區域或廣域網路, Internal networking 的特性通常用來當作資料庫伺服器, 可以透過 internal 網路, 提供對外連線的全球資訊網伺服器資料, 但是外部電腦無法跨越 internal 網路架構直接連線. Host-only 使用情境則將網路服務的範圍界定在 Host 主機範圍內, 在虛擬機器所啟動的各種服務, 可以讓 Host 連線, 但是因為沒有像 Bridged 網路設置, 與 Host 的實體網路卡進行橋接, 因此 Host-only 的網路環境通常讓操作 Host 的程式設計師將 Host-only 的電腦當作跨網路的虛擬伺服器使用. UDP tunnel 網路用來串接位於不同 Hosts 的虛擬機器, 而 VDE 則是 Virtual Distributed Ethernet 則是一種虛擬網路基礎架構. 以機械設計的電腦輔助設計應用而言, Virtualbox 網路中的 NAT 與 Host-only 模式最為常用, 而 NAT 網路的設定非常直覺, 只要在所新增的虛擬機器中的網路設定, 選擇 NAT, 然後開機之後, 就可以直接在虛擬機器中使用轉址的網路服務. Host-only 虛擬網路設定 Host-only 的網路設置則稍微複雜, 其中牽涉到 Virtualbox 應用程式的網路偏好設定, 以及虛擬機器本身的網路設定搭配, 才能讓 Host 中的應用程式透過 Host 操作系統中的 Host-only 虛擬網路卡, 與位於同一網段的虛擬機器設置連線. Virtualbox 網路偏好設定 Virtualbox 的網路相關設定分為兩個層次, 有關整個 Virtualbox 的設定位於 File->Preferences->Network, 而第二個層次為各虛擬機器的個別設定. 若以 File->Preferences->Network 中, 有關 Host-only 網路設定的目的, 在讓 Virtualbox 的 Host 本體, 可以透過虛擬的網路卡與 Virtualbox 中的虛擬機器網路卡處於同一個區域網路中. 換言之, 如 Host-only 這個名稱本身的所謂 Host only, 就是虛擬機器的網路能見度, 僅止於 Host only, 外部電腦無法與這些虛擬機器連線, 甚至若虛擬機器沒有透過 Host 電腦中的代理主機, 虛擬機器中的瀏覽器也無法連線上網. 至於 File->Preferences->Network 中的 Host-only 設定, 總共決定兩件虛擬功能, 其一為位於 Host 中的虛擬網路卡, 要採用的網路協定與網址, 所謂的網路協定就是可以使用 IPV4 或 IPV6 網路協定, 至於虛擬網卡的網址, 就會決定這個所謂的 Host-only 網路, 位於那一個內部網段, 例如, 可以使用 IPV4 協定, 並將虛擬網路卡的網址設為 192.168.56.1, 也就是將 Host-only 的網段設為 192.168.56.0. File->Preferences->Network 中的 Host-only 第 2 個設定, 就是在這個上述設定的虛擬網段中, 是否要再虛擬出一台 DHCP 伺服器, 例如, 選擇要在這個虛擬 Host-only 網段中啟用虛擬的 DHCP 伺服器, 就可以決定這個虛擬的 DHCP 伺服器的 IP (當然要與第 1 項設定的網段相同, 也就是必須位於 192.168.56.0 網段中), 例如, 將虛擬的 DHCP server IP 設為 192.168.56.100, 並且將 DHCP IP 範圍設為 192.168.56.101-200. 儘管 Virtualbox 中的 File->Preferences->Network 中的 Host-only 第 2 個設定, 可以啟用 DHCP, 但是通常使用 Host-only 虛擬網路模式的目的, 大多要在 Host 中連接虛擬機器中的伺服器, 使用特定的服務內容, 因此一般都停用 Host-only 網路設定中的虛擬 DHCP server 服務, 而採手動設定虛擬機器中的 IP 與 Gateway. 虛擬機器的網路設定 例如, 可以將其中第一台使用 Host-only 網路模式的虛擬機器網路 IP 設為 192.168.56.101, 並將 Gateway 設為 192.168.56.1 (也就是 Host 中對應虛擬網卡的 IP 位址), 第 2 台則設可為 192.168.56.102, 依此類推採用固定的 IP 位址來界定虛擬機器所提供的不同服務. Host-only 虛擬網路相關設定的參考畫面如下:"},{"url":"http://cadlab.mde.tw/post/onshape-featurescript-spur-gear-ling-jian.html","tags":"MISC","title":"Onshape Featurescript Spur Gear 零件","text":"從 https://forum.onshape.com/discussion/4064/use-opfillet-for-a-sketch 的討論, 我們得知, 目前無法利用 FeatureScript 在繪圖平面中利用 opFillet, 對特定平面圖元進行倒圓角運算, 因此延續 上一篇利用漸開線正齒輪輪廓 轉換為正齒輪零件, 就必須在實體模型中進行倒圓角運算. 這裡的 FeatureScript 程式碼, 基本架構引用 Onshape 官方正齒輪繪圖 FeatureScript 程式第1版 的內容, 只將推導的漸開線點座標, 透過 skFitSpline 轉為平滑曲線, 但是原版的 offset 參數, 目前只導入 offsetAngle, 以便產生的正齒輪, 可以在組立件中進行囓合. 17 齒漸開線正齒輪 FeatureScript 程式繪圖: 170 齒漸開線正齒輪 FeatureScript 程式繪圖: 2016 Spring 的協同產品設計實習課程, 就要在這個 Onshape FeatureScript 正齒輪零件程式的練習中劃下句點, 下學期的電腦輔助設計實習課程仍將採用 Onshape 與 FreeCAD, 當然 PTC Creo Parametric 年久失修的 Pro/Web.Link 仍可列入參考, 只是 Onshape 加上 FeatureScript 的魅力, 至今沒有其他 MCAD 套件可以比擬, 假如您是隸屬於特定團隊的電腦輔助機械設計工程師, 一定要試試 Onshape, 並且利用 FeatureScript 程式客製化產品開發流程中特定的重要零件. 一旦領略雲端電腦輔助機械設計套件的威力之後, 應該就再也回不去了. 我們當然也知道台灣有許多創新產品開發公司, 至今仍然使用著多年前的 MACD 套件, 忍受著系統更新維護與版本老舊的諸多問題, 假如以購買一套桌上版的商用中端 MCAD 套件, 等於可以連續付月費使用 Onshape 5 年來說, 在日新月異的當下, 5 年前的任何一套 MCAD, 即便功能再強, 也早就應該要更迭換新了, 何況, 檢查一下過去 5 年來工程師為了應付機電整合與製程規劃, 儲存在特定電腦硬碟中的紛亂版本, 將設計研發重心逐步轉換到 Onshape 應該才是解決之道. 以下為上述漸開線正齒輪零件繪圖的 FeatureScript 原始碼: FeatureScript 355; import(path : \"onshape/std/geometry.fs\", version : \"355.0\"); annotation { \"Feature Type Name\" : \"Summer Spur Gear\", \"Feature Name Template\" : \"Spur Gear (#teeth teeth)\", \"Filter Selector\" : \"fs\", \"Editing Logic Function\" : \"editGearLogic\" } export const SpurGear = defineFeature(function(context is Context, id is Id, definition is map) precondition { annotation { \"Name\" : \"teeth\", \"UIHint\" : \"ALWAYS_HIDDEN\" } definition.teeth is string; //used to name the feature only annotation { \"Name\" : \"Number of teeth\" } isInteger(definition.numTeeth, TEETH_BOUNDS); annotation { \"Name\" : \"Input type\" } definition.GearInputType is GearInputType; if (definition.GearInputType == GearInputType.module) { annotation { \"Name\" : \"Module\" } isLength(definition.module, MODULE_BOUNDS); } if (definition.GearInputType == GearInputType.diametralPitch) { annotation { \"Name\" : \"Diametral pitch\" } isReal(definition.diametralPitch, POSITIVE_REAL_BOUNDS); } if (definition.GearInputType == GearInputType.circularPitch) { annotation { \"Name\" : \"Circular pitch\" } isLength(definition.circularPitch, LENGTH_BOUNDS); } annotation { \"Name\" : \"Pitch circle diameter\" } isLength(definition.pitchCircleDiameter, LENGTH_BOUNDS); annotation { \"Name\" : \"Pressure angle\" } isAngle(definition.pressureAngle, PRESSURE_ANGLE_BOUNDS); annotation { \"Name\" : \"Center hole\" } definition.centerHole is boolean; if (definition.centerHole) { annotation { \"Name\" : \"Hole diameter\" } isLength(definition.centerHoleDia, CENTERHOLE_BOUNDS); annotation { \"Name\" : \"Keyway\" } definition.key is boolean; if (definition.key) { annotation { \"Name\" : \"Key width\" } isLength(definition.keyWidth, KEY_BOUNDS); annotation { \"Name\" : \"Key height\" } isLength(definition.keyHeight, KEY_BOUNDS); } } annotation { \"Name\" : \"Select origin position\" } definition.centerPoint is boolean; if (definition.centerPoint) { annotation { \"Name\" : \"Sketch vertex for center\", \"Filter\" : EntityType.VERTEX && SketchObject.YES, \"MaxNumberOfPicks\" : 1 } definition.center is Query; } annotation { \"Name\" : \"Extrude depth\" } isLength(definition.gearDepth, BLEND_BOUNDS); annotation { \"Name\" : \"Extrude direction\", \"UIHint\" : \"OPPOSITE_DIRECTION\" } definition.flipGear is boolean; annotation { \"Name\" : \"Offset\" } definition.offset is boolean; if (definition.offset) { annotation { \"Name\" : \"Root diameter\" } isLength(definition.offsetClearance, ZERO_DEFAULT_LENGTH_BOUNDS); annotation { \"Name\" : \"Outside diameter\" } isLength(definition.offsetDiameter, ZERO_DEFAULT_LENGTH_BOUNDS); annotation { \"Name\" : \"Tooth angle\" } isAngle(definition.offsetAngle, ANGLE_360_ZERO_DEFAULT_BOUNDS); } } { var offsetDiameter = 0 * meter; var offsetClearance = 0 * meter; var offsetAngle = 0 * degree; if (definition.offset) { offsetDiameter = definition.offsetDiameter; offsetClearance = definition.offsetClearance; offsetAngle = definition.offsetAngle; } if (definition.centerHole && definition.centerHoleDia >= definition.pitchCircleDiameter - 4 * definition.module) { throw regenError(\"Center hole diameter must be less than the root diameter\", [\"centerHoleDia\"]); } if (definition.key && definition.keyHeight / 2 + definition.centerHoleDia >= definition.pitchCircleDiameter - 4 * definition.module) { throw regenError(\"Center hole diameter plus Key height must be less than the root diameter\", [\"keyHeight\"]); } // if no center vertex selected build gear on the front plane at the origin var location = vector(0, 0, 0) * meter; var sketchPlane = plane(location, vector(0, -1, 0), vector(1, 0, 0)); var center3D = location; // else find location of selected vertex and its sketch plane and create a new sketch for the gear profile if (definition.centerPoint) { location = evaluateQuery(context, definition.center)[0]; sketchPlane = evOwnerSketchPlane(context, { \"entity\" : location }); center3D = evVertexPoint(context, { \"vertex\" : location }); } const gearSketch = newSketchOnPlane(context, id + \"gearSketch\", { \"sketchPlane\" : sketchPlane }); const center2D = worldToPlane(sketchPlane, center3D); var filletEdges = []; var regionPoint; // 漸開線近似點數 var imax = 5; // 使用者所選的齒輪圓心 x 座標 var midx = center2D[0]; // 使用者所選的齒輪圓心 y 座標 var midy = center2D[1]; // 齒數 var n = definition.numTeeth; // 模數 var m = definition.module; // 壓力角, 單位為角度 var pa = definition.pressureAngle; // 齒輪的節圓半徑 var rp = m*n/2; // 正齒輪囓合用的定位線 skLineSegment(gearSketch, \"line\", { \"start\" : vector(midx,midy), \"end\" : vector(midx,midy+rp) }); // 齒根, 暫時不考慮納入 offsetClearance var d = 2.5*rp/n; // 齒頂圓半徑, 暫不考慮納入 offsetDiameter var ra = rp + m; // 基圓半徑 var rb = rp*cos(pa); //print(rb); // 齒根圓半徑 var rd = rp - d; // 分段後齒頂與齒根半徑差增量 var dr = 0*meter; // 若 rb > rd 時從基圓開始繪製漸開線, 但是若 rd > rb, 則漸開線從 rd 畫到齒頂圓 if (rd > rb) { // 半徑差的分段, 由齒根圓到齒頂圓 dr = (ra-rd)/imax; } else { // 半徑差的分段, 由基圓到齒頂圓 dr = (ra-rb)/imax; } // PI 為實數值沒有單位, tan(pa)也沒有單位, pa 已經設定單位為 degree var rot = PI/(2*n)*radian; // 用來設定 entity id 用的增量變數 var nameId = 1; var r = 0*meter; // theta 為浮點數字 var theta = 0; var inv = 0*radian; var inc = 0*radian; // 當 r=rp 時 ,計算 inv_rp 用來旋轉漸開線用 // theta 為沒有單位的實數 theta = sqrt((rp*rp)/(rb*rb)-1); // atan(theta) 為 radian // Onshape SG 的 const alpha 就是這裡的 inv_rp // Onshape SG 的 const beta 就是這裡的 rot-inv_rp var inv_rp = theta*radian-atan(theta); // 漸開線上點的 x 座標 var xpt = 0*meter; // 漸開線上點的 y 座標 var ypt = 0*meter; // 左側漸開線第1點座標 left first x and y var lfx = 0*meter; var lfy = 0*meter; // 右側漸開線第1點座標 right first x and y var rfx = 0*meter; var rfy = 0*meter; // 左側齒根圓上點座標 left x of dedendum point var lxd = 0*meter; var lyd = 0*meter; // 右側齒根圓上點座標 right x of dedendum point var rxd = 0*meter; var ryd = 0*meter; // 左側齒根圓上點座標 right x of dedendum point (advanced) var lxd_ad = 0*meter; var lyd_ad = 0*meter; var inc_ad = 0*radian; for (var j=0;j<n;j+=1) { var involute1 = []; var involute2 = []; var arcDone = false; var point1; var point2; // 當 j 增量時, 按照齒數輪廓繞行旋轉增量角度, 加入 offsetAngle 參數 inc = (2.*j*PI/n)*radian+offsetAngle; inc_ad = (2.*(j+1)*PI/n)*radian+offsetAngle; if (rd>rb) { // 當齒根半徑因為齒數增多後大於基圓半徑時, 漸開線從齒根圓長起 theta = sqrt((rd*rd)/(rb*rb)-1.); inv = theta*radian-atan(theta); // 左側漸開線第1點座標 // 左側輪廓線配合逆時針旋轉 inc 角度 lfx = midx+rd*sin(inv-rot-inv_rp+inc); lfy = midy+rd*cos(inv-rot-inv_rp+inc); point1 = vector(lfx, lfy); lxd = lfx; lyd = lfy; lxd_ad = midx+rd*sin(inv-rot-inv_rp+inc_ad); lyd_ad = midy+rd*cos(inv-rot-inv_rp+inc_ad); // 右側漸開線第1點座標 // 右側輪廓線配合順時針旋轉 inc 角度 rfx = midx-rd*sin(inv-rot-inv_rp-inc); rfy = midy+rd*cos(inv-rot-inv_rp-inc); point2 = vector(rfx, rfy); rxd = rfx; ryd = rfy; } else { // 當基圓半徑大於齒根圓時, 漸開線從基圓長起 //theta = sqrt((rb*rb)/(rb*rb)-1.); theta = 0; inv = theta*radian-atan(theta); // 左側漸開線第1點座標 lfx = midx+rb*sin(inv-rot-inv_rp+inc); lfy = midy+rb*cos(inv-rot-inv_rp+inc); point1 = vector(lfx, lfy); lxd = midx+rd*sin(inv-rot-inv_rp+inc); lyd = midy+rd*cos(inv-rot-inv_rp+inc); lxd_ad = midx+rd*sin(inv-rot-inv_rp+inc_ad); lyd_ad = midy+rd*cos(inv-rot-inv_rp+inc_ad); // 左側從基圓點到齒根圓點, 畫直線 left from base point to dedendum point skLineSegment(gearSketch, \"line_lbd\" ~ nameId, { \"start\" : vector(lfx,lfy), \"end\" : vector((lxd),(lyd)) }); // 右側漸開線第1點座標 rfx = midx-rb*sin(inv-rot-inv_rp-inc); rfy = midy+rb*cos(inv-rot-inv_rp-inc); point2 = vector(rfx, rfy); rxd = midx-rd*sin(inv-rot-inv_rp-inc); ryd = midy+rd*cos(inv-rot-inv_rp-inc); // 右側從基圓點到齒根圓點, 畫直線 right from base point to dedendum point skLineSegment(gearSketch, \"line_rbd\" ~ nameId, { \"start\" : vector(rfx,rfy), \"end\" : vector((rxd),(ryd)) }); } // 處理齒根的圓弧 if (!arcDone) // create base arc between involutes once per tooth { var mid = getArcMidPoint(center2D, vector(lxd_ad,lyd_ad), vector(rxd,ryd)); // sketch arc is arc 3 points so need addtional point on arc if (mid != undefined) // if no base cylinder present (due to pressure angle), don't draw it { // 齒根圓上的圓弧 skArc(gearSketch, \"arc-d\" ~ nameId, { \"start\" : vector(lxd_ad,lyd_ad), \"mid\" : mid, \"end\" : vector(rxd,ryd) }); } if (rd>rb) { // 只有在齒根圓半徑大於基圓時, 將漸開線起點作為倒圓角的基準點 // find points in 3D space where edges need to be filleted later filletEdges = append(filletEdges, toWorldVector(planeToCSys(sketchPlane), point2, definition.gearDepth, definition.flipGear)); filletEdges = append(filletEdges, toWorldVector(planeToCSys(sketchPlane), point1, definition.gearDepth, definition.flipGear)); } else { // 當小齒數時, 從基圓到齒根圓有一條直線, 因此倒圓角基準點必須以齒根圓上的點為基準 // find points in 3D space where edges need to be filleted later filletEdges = append(filletEdges, toWorldVector(planeToCSys(sketchPlane), vector(rxd, ryd), definition.gearDepth, definition.flipGear)); filletEdges = append(filletEdges, toWorldVector(planeToCSys(sketchPlane), vector(lxd, lyd), definition.gearDepth, definition.flipGear)); } // find area to extrude regionPoint = vector(point1[0] * 0.95 + center2D[0]*0.05, point1[1] * 0.95+center2D[1]*0.05, 0 * meter); arcDone = true; } // 將漸開線第1點存入 involute1 與 involute2 陣列中 involute1 = append(involute1, point1); involute2 = append(involute2, point2); for (var i=1; i<imax+1; i+= 1) { // 先處理中線左側的漸開線 // 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if (rd>rb) { r = rd+i*dr; } else { r = rb+i*dr; } theta = sqrt((r*r)/(rb*rb)-1); var inv = theta*radian-atan(theta); // 漸開線上的點座標 xpt = midx+r*sin(inv-rot-inv_rp+inc); ypt = midy+r*cos(inv-rot-inv_rp+inc); point1 = vector(xpt, ypt); // 更新漸開線點座標 lfx = xpt; lfy = ypt; //nameId += 1; involute1 = append(involute1, point1); } // 紀錄左側漸開線的最後一點, 也就是齒頂圓上的點座標 var lastlx = xpt; var lastly = ypt; // another side for (var i=1; i<imax+1; i+= 1) { if (rd>rb) { r = rd+i*dr; } else { r = rb+i*dr; } theta = sqrt((r*r)/(rb*rb)-1); var inv = theta*radian-atan(theta); // 漸開線上的點座標 xpt = midx-r*sin(inv-rot-inv_rp-inc); ypt = midy+r*cos(inv-rot-inv_rp-inc); point2 = vector(xpt, ypt); // 更新漸開線點座標 rfx = xpt; rfy = ypt; //nameId += 1; involute2 = append(involute2, point2); } var lastrx = xpt; var lastry = ypt; // create involute sketch splines skFitSpline(gearSketch, \"spline-a\" ~ nameId, { \"points\" : involute1 }); skFitSpline(gearSketch, \"spline-b\" ~ nameId, { \"points\" : involute2 }); // 要注意, 若對調 vector(lastrx, lastry) 與 vector(lastlx, lastly) 則無法求得中點 var mid_a = getArcMidPoint(center2D, vector(lastrx,lastry), vector(lastlx,lastly)); if (mid_a != undefined) { skArc(gearSketch, \"arc-a\" ~ nameId, { \"start\" : vector(lastlx,lastly), \"mid\" : mid_a, \"end\" : vector(lastrx,lastry) }); } nameId += 1; } if (definition.centerHole) { if (definition.key) { var keyVector = vector(0, 1); var perpKeyVector = vector(-1, 0); var keyHeight = (definition.keyHeight + definition.centerHoleDia) / 2; var points = [ center2D - (definition.keyWidth / 2) * perpKeyVector, center2D - (definition.keyWidth / 2) * perpKeyVector + keyHeight * keyVector, center2D + (definition.keyWidth / 2) * perpKeyVector + keyHeight * keyVector, center2D + (definition.keyWidth / 2) * perpKeyVector]; for (var i = 0; i < size(points); i += 1) { skLineSegment(gearSketch, \"line\" ~ nameId, { \"start\" : points[i], \"end\" : points[(i + 1) % size(points)] }); nameId += 1; } } // center hole circle sketch skCircle(gearSketch, \"Center\", { \"center\" : center2D, \"radius\" : definition.centerHoleDia / 2 }); } skSolve(gearSketch); extrude(context, id + \"extrude1\", { \"entities\" : qContainsPoint(qCreatedBy(id + \"gearSketch\", EntityType.FACE), toWorld(planeToCSys(sketchPlane), regionPoint)), \"endBound\" : BoundingType.BLIND, \"depth\" : definition.gearDepth, \"oppositeDirection\" : definition.flipGear }); var filletEdges3D = []; for (var i = 0; i < size(filletEdges); i += 1) { // Find the edges that intersect the points previously collected filletEdges3D = append(filletEdges3D, qContainsPoint(qCreatedBy(id + \"extrude1\", EntityType.EDGE), filletEdges[i])); } const filletRadius = norm(filletEdges[1] - filletEdges[0]) / 4; // arbitrary fillet size = one fourth the distance between the edges if (filletRadius >= 0.2 * millimeter) // arbitrary small size assuming tooling cannot hold a fillet radius smaller than this { try(opFillet(context, id + \"fillet1\", { \"entities\" : qUnion(filletEdges3D), \"radius\" : filletRadius })); } // Remove sketch entities - no longer required opDeleteBodies(context, id + \"delete\", { \"entities\" : qCreatedBy(id + \"gearSketch\") }); // created PCD sketch const PCDSketch = newSketchOnPlane(context, id + \"PCDsketch\", { \"sketchPlane\" : sketchPlane }); skCircle(PCDSketch, \"PCD\", { \"center\" : center2D, \"radius\" : definition.pitchCircleDiameter / 2, \"construction\" : true }); skSolve(PCDSketch); }); function getArcMidPoint(center is Vector, start is Vector, end is Vector) { // need to convert 2D vectors back to 3D for vector angle calculation const center3D = vector(center[0], center[1], 0 * meter); const start3D = vector(start[0], start[1], 0 * meter); const end3D = vector(end[0], end[1], 0 * meter); const angle = vectorAngle(center3D - start3D, center3D - end3D) / 2; // if angle is less than zero then arc was flipped if (angle <= 0 * radian) return; start = center - start; var ca = cos(angle); // in radians var sa = sin(angle); return center - vector(ca * start[0] - sa * start[1], sa * start[0] + ca * start[1]); } function vectorAngle(vector1 is Vector, vector2 is Vector) { // function assumes vectors are on a 2D plane so Z is always zero and the normal vector is always [0, 0, 1] return atan2(dot(vector(0, 0, 1), cross(vector1, vector2)), dot(vector1, vector2)); } function toWorldVector(csys is CoordSystem, point is Vector, depth is map, direction is boolean) returns Vector { var dir = direction ? -1 : 1; var vector3D = vector(point[0], point[1], dir * depth / 2); return toWorld(csys, vector3D); } export function editGearLogic(context is Context, id is Id, oldDefinition is map, definition is map, isCreating is boolean, specifiedParameters is map, hiddenBodies is Query) returns map { // isCreating is required in the function definition for edit logic to work when editing an existing feature if (oldDefinition.numTeeth != definition.numTeeth) { definition.module = definition.pitchCircleDiameter / definition.numTeeth; definition.circularPitch = definition.module * PI; definition.diametralPitch = 1 * inch / definition.module; definition.teeth = toString(definition.numTeeth); //to name the feature return definition; } if (oldDefinition.circularPitch != definition.circularPitch) { definition.module = definition.circularPitch / PI; definition.pitchCircleDiameter = (definition.circularPitch * definition.numTeeth) / PI; definition.diametralPitch = 1 * inch / definition.module; return definition; } if (oldDefinition.pitchCircleDiameter != definition.pitchCircleDiameter) { definition.module = definition.pitchCircleDiameter / definition.numTeeth; definition.circularPitch = (PI * definition.pitchCircleDiameter) / definition.numTeeth; definition.diametralPitch = 1 * inch / definition.module; return definition; } if (oldDefinition.module != definition.module) { definition.circularPitch = definition.module * PI; definition.pitchCircleDiameter = definition.numTeeth * definition.module; definition.diametralPitch = 1 * inch / definition.module; return definition; } if (oldDefinition.diametralPitch != definition.diametralPitch) { definition.circularPitch = PI / (definition.diametralPitch / inch); definition.module = definition.circularPitch / PI; definition.pitchCircleDiameter = (definition.circularPitch * definition.numTeeth) / PI; return definition; } return definition; } const TEETH_BOUNDS = { \"min\" : 4, \"max\" : 250, (unitless) : [4, 25, 250] } as IntegerBoundSpec; const PRESSURE_ANGLE_BOUNDS = { \"min\" : 12 * degree, \"max\" : 35 * degree, (degree) : [12, 20, 35] } as AngleBoundSpec; const MODULE_BOUNDS = { \"min\" : -TOLERANCE.zeroLength * meter, \"max\" : 500 * meter, (meter) : [1e-5, 0.001, 500], (centimeter) : 0.1, (millimeter) : 1.0, (inch) : 0.04 } as LengthBoundSpec; const CENTERHOLE_BOUNDS = { \"min\" : -TOLERANCE.zeroLength * meter, \"max\" : 500 * meter, (meter) : [1e-5, 0.01, 500], (centimeter) : 1.0, (millimeter) : 10.0, (inch) : 0.375 } as LengthBoundSpec; const KEY_BOUNDS = { \"min\" : -TOLERANCE.zeroLength * meter, \"max\" : 500 * meter, (meter) : [1e-5, 0.003, 500], (centimeter) : 0.3, (millimeter) : 3.0, (inch) : 0.125 } as LengthBoundSpec; export enum GearInputType { annotation { \"Name\" : \"Module\" } module, annotation { \"Name\" : \"Diametral pitch\" } diametralPitch, annotation { \"Name\" : \"Circular pitch\" } circularPitch }"},{"url":"http://cadlab.mde.tw/post/onshape-featurescript-spur-gear-lun-kuo-hui-tu.html","tags":"MISC","title":"Onshape Featurescript Spur Gear 輪廓繪圖","text":"學習 Onshape 可以從 614 頁的 pdf 格式導引手冊: https://cad.onshape.com/help/PDF/Onshape.pdf 下手, 在手動操作逐漸熟悉之後, 就可以透過下列的 FeatureScript 程式客製化理想中的各種零件, 這裡先來看看漸開線正齒輪輪廓繪圖, 有關齒輪的參考資料, 請參閱 http://khkgears.net/gear-knowledge/ . 從 機械設計工程師的設計模擬與實作 文章中, 可以看到利用 Brython 直接在網際畫布上以小段直線繪製漸開線正齒輪輪廓的程式原始碼. 類似的正齒輪繪圖可以參考 Approximation of Involute Curves for CAD-System Processing 論文中的說明, 完成 靜態與動態的漸開線正齒輪繪圖與模擬 . 以下主要以教導 FeatureScript 為目的, 依據下列圖示作為參考: 假設齒數為 n, 模數為 m, 壓力角為 pa, 則正齒輪的節圓半徑為 \\(rp = m*n/2\\) , 且基圓半徑 \\(rb = rp*cos(pa)\\) , 假設齒根 \\(d = 2.5*rp/n\\) , 齒頂圓半徑 \\(ra = rp + m\\) , 齒根圓半徑 \\(rd = rp - d\\) , 接著當齒數 n 小於 \\(2.5/(1-cos(pa))\\) 時就能夠從基圓開始繪製漸開線到齒頂圓, 若 n 大於 \\(2.5/(1-cos(pa))\\) , 則漸開線必須從齒根圓畫起, 而不是從基圓畫起 (因為基圓半徑已經小於齒根圓半徑). 有關這一點, Onshape 官方釋出的漸開線 正齒輪繪圖 FeatureScript 程式第1版 也未能納入考量, 因此當選擇壓力角 20 度時, 若齒數超過 43 齒, 或者選擇壓力角 15.5 度, 當齒數超過 70 齒, 正齒輪的輪廓就會出錯. 之後當以下的練習完成後, 就可以將漸開線納入 spline 中, 並且加上齒輪底部的導倒圓角後, 就能夠修正上述的錯誤. 以下為 17 齒, 模數 20 mm, 壓力角 20 度的漸開線正齒輪輪廓繪圖: 以下為 170 齒, 模數 20 mm, 壓力角 20 度的漸開線正齒輪輪廓繪圖: 以下為對應的 FeatureScript 正齒輪輪廓繪圖程式碼: FeatureScript 355; import(path : \"onshape/std/geometry.fs\", version : \"355.0\"); annotation { \"Feature Type Name\" : \"Spur2\" } export const spur = defineFeature(function(context is Context, id is Id, definition is map) precondition { // 正齒輪齒數, 由使用者輸入, 型別為整數 annotation { \"Name\" : \"Number of Gear Tooth\" } isInteger(definition.n, POSITIVE_COUNT_BOUNDS); // 正齒輪模數, 由使用者輸入, 型別為長度, 為內建尺寸單位 annotation { \"Name\" : \"Module\" } isLength(definition.module, LENGTH_BOUNDS); // 正齒輪壓力角, 由使用者輸入, 型別為角度, 為內建角度單位 annotation { \"Name\" : \"Pressure Angle\" } isAngle(definition.pa, ANGLE_360_BOUNDS); // 正齒輪圓心座標點, 由使用者選擇 annotation { \"Name\" : \"Select a point\", \"Filter\" : EntityType.VERTEX, \"MaxNumberOfPicks\" : 1 } definition.point is Query; } { // Precondition 中的查詢, 需要 evalue 才能傳回對應的 entity var location = evaluateQuery(context, definition.point)[0]; // location 變數為點座標對應的 entity, 必須透過 evVetexPoint 的評量才能傳回對應的點座標 var center3D = evVertexPoint(context, { \"vertex\" : location }); // 作圖平面利用 evOwnerSketch 評量, 與 location entity 同一個平面 var sketchPlane = evOwnerSketchPlane(context, { \"entity\" : location }); // 作圖畫 const gearSketch = newSketchOnPlane(context, id + \"gearSketch\", { \"sketchPlane\" : sketchPlane }); // 利用 worldToPlane, 將 center3D 轉換為 sketchPlane 上的平面點座標 const center2D = worldToPlane(sketchPlane, center3D); //print(center2D); // 漸開線近似點數 var imax = 5; // 使用者所選的齒輪圓心 x 座標 var midx = center2D[0]; // 使用者所選的齒輪圓心 y 座標 var midy = center2D[1]; // 齒數 var n = definition.n; // 模數 var m = definition.module; // 壓力角, 單位為角度 var pa = definition.pa; // 齒輪的節圓半徑 var rp = m*n/2; skLineSegment(gearSketch, \"line\", { \"start\" : vector(midx,midy), \"end\" : vector(midx,midy+rp) }); // 齒根 var d = 2.5*rp/n; // 齒頂圓半徑 var ra = rp + m; // 基圓半徑 var rb = rp*cos(pa); //print(rb); // 齒根圓半徑 var rd = rp - d; // 分段後齒頂與齒根半徑差增量 var dr = 0*meter; // 若 rb > rd 時從基圓開始繪製漸開線, 但是若 rd > rb, 則漸開線從 rd 畫到齒頂圓 if (rd > rb) { // 半徑差的分段, 由齒根圓到齒頂圓 dr = (ra-rd)/imax; } else { // 半徑差的分段, 由基圓到齒頂圓 dr = (ra-rb)/imax; } // PI 為實數值沒有單位, tan(pa)也沒有單位, pa 已經設定單位為 degree, 這裡為了與 radian 運算 // 系統會自動轉為 radian var rot = PI/(2*n)*radian; //print(sigma); // 分別用來設定 entity id 用的增量變數 var nameId = 1; var nameId2 = 1; var r = 0*meter; // theta 為浮點數字 var theta = 0; var inv = 0*radian; var inc = 0*radian; // 當 r=rp 時 ,計算 inv_rp 用來旋轉漸開線用 // theta 為沒有單位的實數 theta = sqrt((rp*rp)/(rb*rb)-1); // atan(theta) 為 radian var inv_rp = theta*radian-atan(theta); // 漸開線上點的 x 座標 var xpt = 0*meter; // 漸開線上點的 y 座標 var ypt = 0*meter; // 左側漸開線第1點座標 left first x and y var lfx = 0*meter; var lfy = 0*meter; // 右側漸開線第1點座標 right first x and y var rfx = 0*meter; var rfy = 0*meter; // 左側齒根圓上點座標 left x of dedendum point var lxd = 0*meter; var lyd = 0*meter; // 右側齒根圓上點座標 right x of dedendum point var rxd = 0*meter; var ryd = 0*meter; // 左側齒根圓上點座標 right x of dedendum point (advanced) var lxd_ad = 0*meter; var lyd_ad = 0*meter; var inc_ad = 0*radian; for (var j=0;j<n;j+=1) { // 當 j 增量時, 按照齒數輪廓繞行旋轉增量角度 inc = (2.*j*PI/n)*radian; inc_ad = (2.*(j+1)*PI/n)*radian; if (rd>rb) { // 當齒根半徑因為齒數增多後大於基圓半徑時, 漸開線從齒根圓長起 theta = sqrt((rd*rd)/(rb*rb)-1.); inv = theta*radian-atan(theta); // 左側漸開線第1點座標 // 左側輪廓線配合逆時針旋轉 inc 角度 lfx = midx+rd*sin(inv-rot-inv_rp+inc); lfy = midy+rd*cos(inv-rot-inv_rp+inc); lxd = lfx; lyd = lfy; lxd_ad = midx+rd*sin(inv-rot-inv_rp+inc_ad); lyd_ad = midy+rd*cos(inv-rot-inv_rp+inc_ad); // 右側漸開線第1點座標 // 右側輪廓線配合順時針旋轉 inc 角度 rfx = midx-rd*sin(inv-rot-inv_rp-inc); rfy = midy+rd*cos(inv-rot-inv_rp-inc); rxd = rfx; ryd = rfy; // 齒根圓上的直線 on dedendum points skLineSegment(gearSketch, \"line_dd\" ~ nameId, { \"start\" : vector(rxd,ryd), \"end\" : vector((lxd_ad),(lyd_ad)) }); } else { // 當基圓半徑大於齒根圓時, 漸開線從基圓長起 theta = sqrt((rb*rb)/(rb*rb)-1.); inv = theta*radian-atan(theta); // 左側漸開線第1點座標 lfx = midx+rb*sin(inv-rot-inv_rp+inc); lfy = midy+rb*cos(inv-rot-inv_rp+inc); lxd = midx+rd*sin(inv-rot-inv_rp+inc); lyd = midy+rd*cos(inv-rot-inv_rp+inc); lxd_ad = midx+rd*sin(inv-rot-inv_rp+inc_ad); lyd_ad = midy+rd*cos(inv-rot-inv_rp+inc_ad); // 從基圓點到齒根圓點, 畫直線 left from base point to dedendum point skLineSegment(gearSketch, \"line_lbd\" ~ nameId, { \"start\" : vector(lfx,lfy), \"end\" : vector((lxd),(lyd)) }); // 右側漸開線第1點座標 rfx = midx-rb*sin(inv-rot-inv_rp-inc); rfy = midy+rb*cos(inv-rot-inv_rp-inc); rxd = midx-rd*sin(inv-rot-inv_rp-inc); ryd = midy+rd*cos(inv-rot-inv_rp-inc); // 從基圓點到齒根圓點, 畫直線 right from base point to dedendum point skLineSegment(gearSketch, \"line_rbd\" ~ nameId, { \"start\" : vector(rfx,rfy), \"end\" : vector((rxd),(ryd)) }); // 齒根圓上的直線 on dedendum points skLineSegment(gearSketch, \"line_dd\" ~ nameId, { \"start\" : vector(rxd,ryd), \"end\" : vector((lxd_ad),(lyd_ad)) }); } for (var i=1; i<imax+1; i+= 1) { // 先處理中線左側的漸開線 // 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if (rd>rb) { r = rd+i*dr; } else { r = rb+i*dr; } theta = sqrt((r*r)/(rb*rb)-1); var inv = theta*radian-atan(theta); // 漸開線上的點座標 xpt = midx+r*sin(inv-rot-inv_rp+inc); ypt = midy+r*cos(inv-rot-inv_rp+inc); // lxd, lyd 為漸開線上的繪線起點座標 skLineSegment(gearSketch, \"lineb\" ~ nameId, { \"start\" : vector(lfx,lfy), \"end\" : vector((xpt),(ypt)) }); // 更新漸開線點座標 lfx = xpt; lfy = ypt; nameId += 1; } // 紀錄左側漸開線的最後一點, 也就是齒頂圓上的點座標 var lastlx = xpt; var lastly = ypt; // another side for (var i=1; i<imax+1; i+= 1) { if (rd>rb) { r = rd+i*dr; } else { r = rb+i*dr; } theta = sqrt((r*r)/(rb*rb)-1); var inv = theta*radian-atan(theta); // 漸開線上的點座標 xpt = midx-r*sin(inv-rot-inv_rp-inc); ypt = midy+r*cos(inv-rot-inv_rp-inc); // rxd, ryd 為漸開線上的繪線起點座標 skLineSegment(gearSketch, \"linec\" ~ nameId, { \"start\" : vector(rfx,rfy), \"end\" : vector((xpt),(ypt)) }); // 更新漸開線點座標 rfx = xpt; rfy = ypt; nameId += 1; } var lastrx = xpt; var lastry = ypt; // 齒頂連線 skLineSegment(gearSketch, \"lined\" ~ nameId2, { \"start\" : vector(lastlx,lastly), \"end\" : vector(lastrx,lastry) }); nameId2 += 1; } skSolve(gearSketch); }); if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }"},{"url":"http://cadlab.mde.tw/post/dian-nao-fu-zhu-she-ji-shi-xiang-guan-qu-yu-wang-lu-she-ding.html","tags":"MISC","title":"電腦輔助設計室相關區域網路設定","text":"今天早上發現一台 Asus 電腦, 裝了 IIS 8 的伺服器佔用了 17.9 的 IPV4 網路位址, 導致原先配置的 Ubuntu 16.04 代理主機無法正常連線. 其實自從 2012 年起台灣就已經逐步完善 IPV6 的網路環境, 而且各種最新的操作系統也都已經提供 IPV6 相關協定的支援, 但是許多用戶仍然只用 IPV4 協定, 而且無論是客戶端或伺服器端, 一律搶佔已經不敷分配的 IPV4 網路位址. 當然, 電腦輔助設計室周遭相關的區域網路, 目前只有兩種伺服器非採用 IPV4 協定不可, 一種是各式 CAD/CAE/CAM/PLM 軟體的網路認証主機, 一種則是同時支援 IPV4/IPV6 的 Proxy Servers. 各式 CAD/CAE/CAM/PLM 軟體的網路認証主機, 早就已經支援 IPV6, 因此採用 IPV6 協定設置的認証主機, 可以服務純 IPV6 的客戶端, 但是仍然有許多的客戶端仍然使用純 IPV4 協定上網, 因此這些客戶端除非採用內部虛擬主機的自我認証, 否則仍然必須採用 IPV4 協定, 連接到區域或廣域網路上的認証伺服器. 在台灣教育界有一個非常有趣的現象, 假如用戶堅持要使用合法購買的各式 CAD/CAE/CAM/PLM 軟體, 負責管理的團隊就必須花錢買罪受, 肩負多元合法軟體的認証伺服器的管理, 而且大部份負責代理這些軟體套件的公司, 都希望將網路認証授權綁在特定的封閉區域網路上, 一來, 可以多賣些套數, 二來也能避開紛擾較多的廣域網路認証主機的管理工作. 上面提到佔用合法 IP 位址的電腦, 網卡的硬體位址以 9c:5c:8e 開頭, 這個網卡從 http://aruljohn.com/mac/9C5C8E 就可以得知來自 Asus, 因此合理的推論, 是一台 Asus 的伺服器, 並且從 http 連線可以看到 IIS 8, 因此應該是安裝 MS 2012 Server 以上的伺服操作系統. 並且從已經開啟的 3389 埠號, 也可以確定 Remote Desktop 已經啟用, 並且允許廣域網路上的任何主機連線. 比較特殊的是沒有任何的 https 埠號啟用, 因此假如這台伺服器提供任何需要使用者輸入帳號密碼的應用, 這些帳號密碼已經透過明碼傳遞曝露在區域網路的封包中. 其實, 上述合法 IPV4 位址被搶佔的問題, 早就可以透過 MAC 綁定 IPV4 的方案解決, 但是因為電腦輔助設計室中的伺服器數量超過 30 台, 許多伺服器的任務多元, 且經常更換, 因此自 2015 年秋季開始, 已經透過校方建置的雲端虛擬主機逐步取代實體主機, 而且部份上課的網路連線也將採純 IPV6 設定上網, 一旦各 Proxy Server 的任務確定, 就可以將伺服器 MAC 位址與 IPV4 位址綁定, 上述的網址佔用問題就不會存在. 接下來, 看一下有關電腦輔助設計室相關區域網路的 IPV6 網路設定, 虎尾科技大學機械設計工程系的 IPV6 網址區段為 2001:288:6004:17, 路由器的通道為 2001:288:6004:17::254, 而校方的 DNS 為 2001:288:6004:1::2, 中華電信的 DNS 則為 2001:b000:168::1, 因此使用者要設定 IPV6 網路連線, 只需要知道自己電腦所配置的網段即可. 從 IPV6 的網路定址格式, 機械設計工程系可用網段為 2001:288:6004:17:0000:0000:0000:0000 ~ 2001:288:6004:17:FFFF:FFFF:FFFF:FFFF, 總共可配置 IPV6 總數為 16&#94;16 = 1.8446744e+19, 可以透過教師編號 (例如為 3001), 將則其所屬的學生與實習研究室 IPV6 分配網段為 2001:288:6004:17:3001:0000:0000:0000 ~ 2001:288:6004:17:3001:FFFF:FFFF:FFFF (可配置位址總數為 16&#94;12 = 2.8147498e+14), 且將 2001:288:6004:17:0000:0000:0000:0000 ~ 2001:288:6004:17:0000:0000:0000:FFFF 保留給電腦輔助設計室與工作站室相關主機使用 (可配置 IPV6 位址總數為 16&#94;4 = 65536), 而行政管理相關的 IPV6 網段則使用 2001:288:6004:17:168:0000:0000:0000 ~ 2001:288:6004:17:168:FFFF:FFFF:FFFF (可配置位址總數為 16&#94;12 = 2.8147498e+14). 之後, 將要利用回收的 20 個 IPV4 網址來配置同時支援 IPV4/IPV6 的 Proxy Server, 並且利用雙協定支援的 DNS 來配置這些伺服器, 遙望 IPV6 的世界, 應該再沒有 IPV6 網址短缺的機會了!"},{"url":"http://cadlab.mde.tw/post/onshape-featurescript-tutorial-dao-yin.html","tags":"MISC","title":"Onshape Featurescript Tutorial 導引","text":"Onshape 配合公開 FeatureScript 特徵程式語言的過程, 特別製作了一個詳細的教學導引: https://cad.onshape.com/FsDoc/tutorials/create-a-slot-feature.html , 從這個導引中, 可以一窺 FeatureScript 的基本用法. 左下角所謂的頁面創建功能 (也就是 + 號所在), 增加了創建 Feature Studio (特徵工房) 的選項, 可以讓使用者利用特徵工房中的 IDE (Integrated Development Environment) 環境, 開發獨特的客製化特徵程式. 所以 Feature Studio 是 Onshape 的一種特殊頁面 (Tab), 其中提供編修 FeatureScript 程式的各種工具. 進入 Feature Studio 後, 通常第一件事就是按下 New Feature 按鈕, 可以在特徵程式編輯區 (採用 Ace.js ) 中帶出 FeatureScript 程式的 Template codes (程式模版). 程式模版中包含所導入的 FeatureScript 程式庫版本, 以及即將讓使用者定義的客製化特徵函式區, 模版程式如下: // 宣告所使用的 FeatureScript 版次 FeatureScript 355; // 配合所使用的 FeatureScript 版次, 導入 geometry 標準程式庫 import(path : \"onshape/std/geometry.fs\", version : \"355.0\"); // 利用 New Feature 所產生的程式模版, 包含 annotation 與 myFeature 常數的 export // 其中使用了匿名函式的立即實例化, 使用者負責填入此一匿名函式的 precondition 與函式內容 // precondition 區主要在設定 FeatureScript 的 GUI 介面, 而函式內容則可實際產生各式特徵操作 annotation { \"Feature Type Name\" : \"My Feature\" } export const myFeature = defineFeature(function(context is Context, id is Id, definition is map) precondition { // 特徵程式的使用者介面對話設計, 包括輸入表單, 各式選單以及使用者動態選擇的各種幾何特徵 } { // 定義函式的幾何操作內容 }); 在 precondition 的大括號中間, 以鍵盤輸入 qu, FeatureScript Studio 就會啟動 Autocompletion 功能, 列出可以選用的 Query 設定, 並且列出詳細的使用說明, 其中的 Query parameter 是 snippet 小程式段外, 其餘都是查詢函式. Query parameter 的程式段如下: annotation { \"Name\" : \"My Query\", \"Filter\" : EntityType.FACE, \"MaxNumberOfPicks\" : 1 } definition.myQuery is Query; 當使用者在 precondition 對話區建立兩個查詢變數後, 就可以提交 (commit) 所增加的 FeatureScript 程式, 提交程式的目的在讓其他的頁面 (Tabs) 可以使用此一特徵程式. 另外假如 Feature Studio 中有新增資料尚未提交, 頁面上的特徵程式名稱前面會多一個 * 號, 一旦提交後, 此一 * 符號就會消失, 表示所有新增或編修的 FeatureScript 程式都已經提交到 Document 的模型本體. FeatureScript 語法中的 annotation 資料型別為 map, 類似 Python 的 Dictionary 資料型別, 且 map 的 key 一律為字串, 以 slot 程式範例而言, annotation { \"Feature Type Name\" : \"Slot\" } 中的 \"Feature Type Name\" 為每一個特徵函式的必要字串鍵值, 這裡的對應名稱為 \"slot\". 從導引影片的操作, 也可以看到當使用者利用某一個平面草圖執行擠出後, 原先的草圖將會內定隱藏, 但隨後將需要選擇此一草圖上的其他線段, 因此必須在特徵瀏覽視窗中, 將此草圖顯示出來. 另外, 當使用者在設計 FeatureScript 程式的 Query 對話區表單時, 可以透過 \"Filter\" 字串鍵進行控制可選的幾何元素, 例如, \"Slot path\" 對應的 \"Filter\" 為 EntityType.EDGE, 表示只能選擇 EDGE 幾何元件, 且透過 \"MaxNumberOfPicks\", 限定只能選擇一個 EDGE. \"Part to cut\" 的 Query 則以 EntityType.BODY && BodyType.SOLID 界定, 表示只能選擇 SOLID BODY. 其次, FeatureScript 的所有尺寸, 角度與重量變數, 都隨使用者所選擇的單位而自動換算, 而且支援不同單位的 混合運算 , 因此除了在互動區設定的 definition.variable_name 會根據 Onshape Document 中的單位為準外, 其他在函式定義過程中新增的其他變數, 必須自行加註單位, 否則會產生具單位尺寸與無單位設定的變數運算的錯誤. 接下來, 當使用者開始進入函式內容的幾何模型操作時, 就必須對 id 型別有些認識. 模型主體 (Context) 中的所有特徵, 子特徵與操作, 都配置獨特的 id 加以辨識. 獨特的 id 可以在查詢, 錯誤回報或者取用特徵或操作時有所依據. id 的標示依照模型本體中各特徵與操作的關係, 以從屬架構表示. 也就是說 ,每一個操作項目的 id 都有其上層對應項目的 id. 過程中可以利用 newId() 函式來產生根項目 id, 隨後的子 id 則利用 + 運算子進行附加. 在 Onshape FeatureScript 手冊中舉例, id + \"foo\" 中的 \"foo\" 就是子項目的 id 名稱, 而其父項目就是 id 變數. 依此類推, id + \"foo\" + \"bar\" 的就是以 \"bar\" 作為子項目的 id, 而其父項目的 id 就是 id + \"foo\". 而且在 FeatureScript 中 id 的資料型別為陣列, 其算元素為字串, 可以經過陣列元素表示各項目的路徑. 例如, newId() + \"foo\" + \"bar\" 等同 id 值為 [\"foo\", \"bar\"], 但是實際操作仍以前面的用法為主. slot 教學導引的後段操作, 接續在互動介面區所設定的兩個 Query 與一個 Parameter 輸入, Query1 是選擇 \"Slot path\", 並將選擇與 definition.slotPath 變數對應, Query2 則選擇 \"Part to cut\", 以 definition.partToCut 表示, 而切槽的寬度則由使用者在欄位中輸入, 以 definition.width 變數表示. 接下來, 則以 definition.slotPath 透過 opExtrude 操作長出橫貫 \"Part to cut\" 本體的平面, 接著利用 opThicken 操作, 對用來切槽的平面增加厚度, 而且一旦平面加厚成為實體之後, 就利用 opDeleteBodies 操作, 將此平面刪除, 最後的操作則是利用 opBoolean 操作, 以增厚的平面實體對 \"Part to cut\" 進行除料, 就完成 slot 客製 FeatureScript 程式的製作. slot FeatureScript 程式碼如下: FeatureScript 355; import(path : \"onshape/std/geometry.fs\", version : \"355.0\"); annotation { \"Feature Type Name\" : \"Slot\" } export const slot = defineFeature(function(context is Context, id is Id, definition is map) precondition { // Query for EDGE entity annotation { \"Name\" : \"Slot path\", \"Filter\" : EntityType.EDGE, \"MaxNumberOfPicks\" : 1 } definition.slotPath is Query; // Query for Body entity annotation { \"Name\" : \"Part to cut\", \"Filter\" : EntityType.BODY && BodyType.SOLID, \"MaxNumberOfPicks\" : 1 } definition.partToCut is Query; // parameter input field for width annotation { \"Name\" : \"Width\" } isLength(definition.width, LENGTH_BOUNDS); } { // Extrude operation, id is extrude1 opExtrude(context, id + \"extrude1\", { \"entities\" : definition.slotPath, \"direction\" : evOwnerSketchPlane(context, {\"entity\" : definition.slotPath}).normal, \"endBound\" : BoundingType.THROUGH_ALL, \"startBound\" : BoundingType.THROUGH_ALL }); // Thicken operation for extrude1 entity opThicken(context, id + \"thicken1\", { \"entities\" : qCreatedBy(id + \"extrude1\", EntityType.BODY), \"thickness1\" : definition.width / 2, \"thickness2\" : definition.width / 2 }); // DeleteBodies operation to delete extrude1 opDeleteBodies(context, id + \"delete1\", { \"entities\" : qCreatedBy(id + \"extrude1\", EntityType.BODY) }); // Boolean operation to subtract the thicken1 from partToCut part opBoolean(context, id + \"boolean1\", { \"tools\" : qCreatedBy(id + \"thicken1\", EntityType.BODY), \"targets\" : definition.partToCut, \"operationType\" : BooleanOperationType.SUBTRACTION }); }); 有了 slot 操作基礎後, 就可以進一步完成繪製齒輪與鏈輪輪廓的程式模版: FeatureScript 355; import(path : \"onshape/std/geometry.fs\", version : \"355.0\"); annotation { \"Feature Type Name\" : \"Gear test\" } export const gearTest = defineFeature(function(context is Context, id is Id, definition is map) precondition { // 圓半徑直接輸入表單為 radius 的欄位中 annotation { \"Name\" : \"radius\" } isLength(definition.radius, LENGTH_BOUNDS); // 在 Select a point 輸入區為查詢, 只能選擇既有的 VERTEX, 且只選一個點 annotation { \"Name\" : \"Select a point\", \"Filter\" : EntityType.VERTEX, \"MaxNumberOfPicks\" : 1 } definition.point is Query; } { // Precondition 中的查詢, 需要 evalue 才能傳回對應的 entity var location = evaluateQuery(context, definition.point)[0]; // location 變數為點座標對應的 entity, 必須透過 evVetexPoint 的評量才能傳回對應的點座標 var center3D = evVertexPoint(context, { \"vertex\" : location }); // 作圖面利用 evOwnerSketch 評量, 與 location entity 同一個平面 var sketchPlane = evOwnerSketchPlane(context, { \"entity\" : location }); // 利用 worldToPlane, 將 center3D 轉換為 sketchPlane 上的平面點座標 const center2D = worldToPlane(sketchPlane, center3D); // 接下來利用 sketchPlane 建立一個草圖畫布元件 const gearSketch = newSketchOnPlane(context, id + \"gearSketch\", { \"sketchPlane\" : sketchPlane }); // 有了草圖畫布元件, 就可以在其上進行各式平面繪圖, 這裡利用 center2D 點作為圓心, definition.radius 作為半徑畫圓 skCircle(gearSketch, \"circle1\", { \"center\" : center2D, \"radius\" : definition.radius }); // 接著從圓心, 沿 x 軸方向畫一條長度為半徑的直線 skLineSegment(gearSketch, \"line1\", { \"start\" : center2D, \"end\" : center2D + vector(1, 0) * definition.radius }); // 這裡使用固定點在畫布上繪製平滑曲線, 之後可以直接用來繪製各種齒輪或鏈輪輪廓 skFitSpline(gearSketch, \"spline1\", { \"points\" : [ vector( 0, 0) * inch, vector( 0, -1) * inch, vector( 1, 1) * inch, vector(-1, 0) * inch, vector( 0, 0) * inch ] }); // 利用 skSolve 解出畫布上的所有繪圖內容, 並顯示出來 skSolve(gearSketch); });"},{"url":"http://cadlab.mde.tw/post/cadlab-xin-dian-nao-xi-tong.html","tags":"MISC","title":"CADLab 新電腦系統","text":"CPU 選擇: Intel i7-6700 Ram 選擇: 16GB (8GBx2) DDR4-3000 (至少還可再升級 8GBx2) HD: 2TB (64MB) SATA III Video Card: NVIDIA GEFORCE GTX950 2GB GDDR5 NIC: 1Gbits/s*5 (除了主機板上的兩片網路卡之外 ,再加上 3 片外接式網路卡, 以便與各開機磁區中的虛擬機橋接出虛擬的多台連外伺服器) 參考: i7: https://en.wikipedia.org/wiki/List_of_Intel_Core_i7_microprocessors i7-6700: http://ark.intel.com/products/88196"},{"url":"http://cadlab.mde.tw/post/onshape-featurescript-cheng-shi-yu-yan-yi.html","tags":"MISC","title":"Onshape FeatureScript 程式語言 (一)","text":"接續上一篇文章, 整理目前 Onshape 已經釋出的 FeatureScript 相關應用範例. Curve Pattern FeatureScript 程式 Document Helix in Fill FeatureScript 程式 Document 3D Spline Fill FeatureScript 程式 Document Brick FeatureScript 程式 Document Measure Distance FeatureScript 程式 Document Lighten FeatureScript 程式 Document Snap Hook FeatureScript 程式原始碼: /* Snap Hook This custom feature creates a common fastening feature in plastic part design. The Snap Hook is just one version of this type of fastening feature and could be easily extended to include many other types. This was built to show that you can create complex, compound features easily. Version 1 - April 26, 2016 - Neil Cooke, Onshape Inc. */ FeatureScript 336; import(path : \"onshape/std/geometry.fs\", version : \"336.0\"); annotation { \"Feature Type Name\" : \"Snap Hook\" } export const SnapHook = defineFeature(function(context is Context, id is Id, definition is map) precondition { annotation { \"Name\" : \"Sketch point locations\", \"Filter\" : EntityType.VERTEX && SketchObject.YES && ConstructionObject.NO } definition.locations is Query; annotation { \"Name\" : \"Height type\" } definition.style is HookStyle; if (definition.style == HookStyle.BLIND) { annotation { \"Name\" : \"Height\", \"UIHint\" : \"REMEMBER_PREVIOUS_VALUE\" } isLength(definition.height, HOOK_HEIGHT); } else { annotation { \"Name\" : \"Parallel face or plane\", \"Filter\" : EntityType.FACE, \"MaxNumberOfPicks\" : 1 } definition.parallelFace is Query; } annotation { \"Name\" : \"Width\", \"UIHint\" : \"REMEMBER_PREVIOUS_VALUE\" } isLength(definition.hookWidth, HOOK_WIDTH); annotation { \"Name\" : \"Flip direction\", \"UIHint\" : \"OPPOSITE_DIRECTION\" } definition.hookFlipDirection is boolean; annotation { \"Name\" : \"Edge to define direction\", \"Filter\" : EntityType.EDGE, \"MaxNumberOfPicks\" : 1 } definition.hookDirection is Query; annotation { \"Name\" : \"Thickness\", \"UIHint\" : \"REMEMBER_PREVIOUS_VALUE\" } isLength(definition.hookThickness, HOOK_THK); annotation { \"Name\" : \"Undercut depth\", \"UIHint\" : \"REMEMBER_PREVIOUS_VALUE\" } isLength(definition.hookDepth, HOOK_THK); annotation { \"Name\" : \"Lip height\", \"UIHint\" : \"REMEMBER_PREVIOUS_VALUE\" } isLength(definition.flatHeight, HOOK_LIP); annotation { \"Name\" : \"Insertion angle\", \"UIHint\" : \"REMEMBER_PREVIOUS_VALUE\" } isAngle(definition.deflectionAngle, HOOK_ANGLE); annotation { \"Name\" : \"Draft\", \"UIHint\" : [\"DISPLAY_SHORT\", \"REMEMBER_PREVIOUS_VALUE\"], \"Default\" : true } definition.hasDraft is boolean; if (definition.hasDraft == true) { annotation { \"Name\" : \"Draft angle\", \"UIHint\" : [\"DISPLAY_SHORT\", \"REMEMBER_PREVIOUS_VALUE\"] } isAngle(definition.draftAngle, ANGLE_STRICT_90_BOUNDS); annotation { \"Name\" : \"Back face draft angle\", \"UIHint\" : \"REMEMBER_PREVIOUS_VALUE\" } isAngle(definition.backDraftAngle, ANGLE_STRICT_90_BOUNDS); } annotation { \"Name\" : \"Cutout\", \"Default\" : true } definition.hasCutout is boolean; annotation { \"Name\" : \"Merge scope\", \"Filter\" : EntityType.BODY && BodyType.SOLID } definition.booleanScope is Query; } { // get all the user selected locations const locations = evaluateQuery(context, definition.locations); // if a solid body intersects the first point in the list, automatically use that in the merge scope const targetBody = evaluateQuery(context, qContainsPoint(qBodyType(qEverything(EntityType.BODY), BodyType.SOLID), evVertexPoint(context, { \"vertex\" : locations[0] }))); if (size(targetBody) == 0 && definition.booleanScope != undefined) definition.targetBody = definition.booleanScope; // if not, get user to select merge scope else definition.targetBody = targetBody[0]; var sketchPlane is Plane = evOwnerSketchPlane(context, { \"entity\" : locations[0] }); var topPlane; var hookVector = vector(1, 0); // by default pointing across in x // if user has defined hook direction, work out the vector if (definition.hookDirection != undefined) { const directionResult = try(evAxis(context, { \"axis\" : definition.hookDirection })); if (directionResult != undefined) hookVector = normalize(vector(directionResult.direction[0], directionResult.direction[1])); } if (definition.hookFlipDirection) hookVector = hookVector * -1; // get vector perpendicular to hook direction var perpHookVector = vector(hookVector[1] * -1, hookVector[0]); // define the plane for the top of the boss if (definition.style == HookStyle.PLANE && definition.parallelFace != undefined) topPlane = evPlane(context, { \"face\" : definition.parallelFace }); else topPlane = plane(sketchPlane.origin + definition.height * sketchPlane.normal, sketchPlane.normal); var nameId = 1; var chamferPoints = []; var frontFacePoints = []; var backFacePoints = []; const sketch1 = newSketchOnPlane(context, id + \"sketch1\", { \"sketchPlane\" : topPlane }); const sketch2 = newSketchOnPlane(context, id + \"sketch2\", { \"sketchPlane\" : topPlane }); const sketch3 = newSketchOnPlane(context, id + \"sketch3\", { \"sketchPlane\" : topPlane }); definition.depth = definition.hookDepth / tan(definition.deflectionAngle) + definition.flatHeight; // Build 3 sketches each with a rectangle for (var location in locations) { var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { \"vertex\" : location })); skRectangle(sketch1, \"rectangleHook\" ~ nameId, { \"firstCorner\" : vector(point[0], point[1]) + (definition.hookWidth / 2) * hookVector, \"secondCorner\" : vector(point[0], point[1]) - (definition.hookWidth / 2) * hookVector - definition.hookDepth * perpHookVector }); skRectangle(sketch2, \"rectangleThickness\" ~ nameId, { \"firstCorner\" : vector(point[0], point[1]) - (definition.hookWidth / 2) * hookVector, \"secondCorner\" : vector(point[0], point[1]) + (definition.hookWidth / 2) * hookVector + definition.hookThickness * perpHookVector }); skRectangle(sketch3, \"completeRectangle\" ~ nameId, { \"firstCorner\" : vector(point[0], point[1]) - (definition.hookWidth / 2) * hookVector - definition.hookDepth * perpHookVector, \"secondCorner\" : vector(point[0], point[1]) + (definition.hookWidth / 2) * hookVector + definition.hookThickness * perpHookVector }); // Keep a list of the centerpoints of the edges where the chamfers may go var chamferPoint2d = vector(point[0], point[1]) - definition.hookDepth * perpHookVector; if (definition.hasDraft) { chamferPoint2d = vector(point[0], point[1]) - (definition.hookDepth - definition.depth * tan(definition.draftAngle)) * perpHookVector; } chamferPoints = append(chamferPoints, toWorld(planeToCSys(topPlane), vector(chamferPoint2d[0], chamferPoint2d[1], definition.depth))); var backFacePoint2d = vector(point[0], point[1]) + definition.hookThickness * perpHookVector; backFacePoints = append(backFacePoints, toWorld(planeToCSys(topPlane), vector(backFacePoint2d[0], backFacePoint2d[1], 0 * meter))); frontFacePoints = append(frontFacePoints, toWorld(planeToCSys(topPlane), vector(point[0], point[1], 0 * meter))); nameId += 1; } skSolve(sketch1); skSolve(sketch2); skSolve(sketch3); extrude(context, id + (\"extrude1\"), { \"entities\" : qSketchRegion(id + \"sketch2\"), \"endBound\" : BoundingType.UP_TO_BODY, \"depth\" : definition.depth, \"endBoundEntityBody\" : definition.targetBody, \"oppositeDirection\" : true, \"hasDraft\" : definition.hasDraft, \"draftAngle\" : definition.draftAngle, \"draftPullDirection\" : false, \"operationType\" : NewBodyOperationType.ADD, \"defaultScope\" : false, \"booleanScope\" : definition.targetBody }); extrude(context, id + (\"extrude2\"), { \"entities\" : qSketchRegion(id + \"sketch3\"), \"endBound\" : BoundingType.BLIND, \"depth\" : definition.depth, \"endBoundEntityBody\" : definition.targetBody, \"oppositeDirection\" : false, \"hasDraft\" : definition.hasDraft, \"draftAngle\" : definition.draftAngle, \"draftPullDirection\" : true, \"operationType\" : NewBodyOperationType.ADD, \"defaultScope\" : false, \"booleanScope\" : definition.targetBody }); var chamferEdges = []; for (var i = 0; i < size(chamferPoints); i += 1) { // Find the edges that intersect the points previously collected chamferEdges = append(chamferEdges, qContainsPoint(qCreatedBy(id + \"extrude2\", EntityType.EDGE), chamferPoints[i])); } try(opChamfer(context, id + \"chamfer1\", { \"entities\" : qUnion(chamferEdges), \"chamferType\" : ChamferType.OFFSET_ANGLE, \"width\" : definition.depth - definition.flatHeight, \"angle\" : definition.deflectionAngle, \"oppositeDirection\" : true })); if (definition.hasDraft) { var backFaces = []; var frontFaces = []; for (var i = 0; i < size(backFacePoints); i += 1) { // Find the edges that intersect the points previously collected backFaces = append(backFaces, qContainsPoint(qCreatedBy(id + \"extrude1\", EntityType.FACE), backFacePoints[i])); frontFaces = append(frontFaces, qContainsPoint(qCreatedBy(id + \"extrude1\", EntityType.FACE), frontFacePoints[i])); } opPlane(context, id + \"plane1\", { \"plane\" : topPlane, \"size\" : 0.1 * meter }); opDraft(context, id + \"draft1\", { \"neutralPlane\" : qCreatedBy(id + \"plane1\", EntityType.FACE), \"pullVec\" : topPlane.normal, \"draftFaces\" : qUnion(frontFaces), \"angle\" : 0 * degree }); opDraft(context, id + \"draft2\", { \"neutralPlane\" : qCreatedBy(id + \"plane1\", EntityType.FACE), \"pullVec\" : topPlane.normal, \"draftFaces\" : qUnion(backFaces), \"angle\" : definition.backDraftAngle + definition.draftAngle }); } if (definition.hasCutout) { extrude(context, id + (\"extrude3\"), { \"entities\" : qSketchRegion(id + \"sketch1\"), \"endBound\" : BoundingType.THROUGH_ALL, \"depth\" : definition.depth, \"endBoundEntityBody\" : definition.targetBody, \"oppositeDirection\" : true, \"hasDraft\" : definition.hasDraft, \"draftAngle\" : definition.draftAngle, \"draftPullDirection\" : false, \"operationType\" : NewBodyOperationType.REMOVE, \"defaultScope\" : false, \"booleanScope\" : definition.targetBody }); } // Remove sketch entities and plane - no longer required var sketches = [qCreatedBy(id + \"sketch1\"), qCreatedBy(id + \"sketch2\"), qCreatedBy(id + \"sketch3\"), qCreatedBy(id + \"plane1\")]; opDeleteBodies(context, id + \"delete\", { \"entities\" : qUnion(sketches) }); }, {}); const HOOK_ANGLE = { \"min\" : -TOLERANCE.zeroAngle * radian, \"max\" : (2 * PI + TOLERANCE.zeroAngle) * radian, (degree) : [15, 30, 60] } as AngleBoundSpec; const HOOK_HEIGHT = { \"min\" : -TOLERANCE.zeroLength * meter, \"max\" : 500 * meter, (meter) : [1e-5, 0.015, 500], (centimeter) : 1.5, (millimeter) : 15.0, (inch) : 0.6 } as LengthBoundSpec; const HOOK_WIDTH = { \"min\" : -TOLERANCE.zeroLength * meter, \"max\" : 500 * meter, (meter) : [1e-5, 0.005, 500], (centimeter) : 0.5, (millimeter) : 5.0, (inch) : 0.2 } as LengthBoundSpec; const HOOK_THK = { \"min\" : -TOLERANCE.zeroLength * meter, \"max\" : 500 * meter, (meter) : [1e-5, 0.002, 500], (centimeter) : 0.2, (millimeter) : 2.0, (inch) : 0.08 } as LengthBoundSpec; const HOOK_LIP = { \"min\" : -TOLERANCE.zeroLength * meter, \"max\" : 500 * meter, (meter) : [1e-5, 0.001, 500], (centimeter) : 0.1, (millimeter) : 1.0, (inch) : 0.04 } as LengthBoundSpec; export enum HookStyle { annotation { \"Name\" : \"Blind\" } BLIND, annotation { \"Name\" : \"Up to face\" } PLANE } Fill Pattern FeatureScript 程式碼: FeatureScript 336; import(path : \"onshape/std/geometry.fs\", version : \"336.0\"); import(path : \"onshape/std/transform.fs\", version : \"336.0\"); /** * Performs a pattern of faces within a face. The instances are placed in a hexagonal pattern and no instances will be * created that cross the boundary of the face. If a border is set then no instances are created within a border of that size * @param definition {{ * @field entities A collection of faces that will be patterned * @field target A planar face that contains the 'entities' faces and that will contain the pattern * @field direction Specifies the alignment of the pattern in the face * @field distance The distance between the center of the instances * @field border The width of the \"exclusion zone\" at the edge of the target face * }} */ annotation { \"Feature Type Name\" : \"Fill pattern\", \"Filter Selector\" : \"allparts\" } export const fillPattern = defineFeature(function(context is Context, id is Id, definition is map) precondition { annotation { \"Name\" : \"Faces to pattern\", \"Filter\" : EntityType.FACE && ConstructionObject.NO && SketchObject.NO } definition.entities is Query; annotation { \"Name\" : \"Target face\", \"Filter\" : GeometryType.PLANE, \"MaxNumberOfPicks\" : 1 } definition.target is Query; annotation { \"Name\" : \"Direction\", \"Filter\" : QueryFilterCompound.ALLOWS_AXIS, \"MaxNumberOfPicks\" : 1 } definition.direction is Query; annotation { \"Name\" : \"Distance\" } isLength(definition.distance, LENGTH_BOUNDS); annotation { \"Name\" : \"Border\" } isLength(definition.border, NONNEGATIVE_ZERO_DEFAULT_LENGTH_BOUNDS); } { var transforms = []; var instanceNames = []; var direction = try(evAxis(context, { \"axis\" : definition.direction })).direction; println(direction); var normal = try(evPlane(context, { \"face\" : definition.target })).normal; // For a hexagonal pattern we have two directions, with one being at an angle of 60 degrees from the other. // If we pattern in both those directions then we get a hexagonal pattern with equal spacing var vertical = cross(normal, direction); var angled = (direction * cos(60 * degree)) + (vertical * sin(60 * degree)); // We want to get the edges of the target face so that we can get the distance from the face boundary // However, because the tool faces ought to be \"in\" the target face we don't want to count those // We can use booleans on the queries, which is pretty nice. We can also take the opportunity to ensure // that at least some edges are shared var allTargetEdges = qEdgeAdjacent(definition.target, EntityType.EDGE); var toolEdges = qEdgeAdjacent(definition.entities, EntityType.EDGE); var targetEdges = qSubtraction(allTargetEdges, toolEdges); var edgesInFace = qIntersection([allTargetEdges, toolEdges]); if (size(evaluateQuery(context, edgesInFace)) == 0) { throw regenError(\"The entities must share edges with the target face\"); } // To prevent excessive calculation we do a quick exclusion of faces based on bounding boxes // It doesn't need to be perfect. Get the box of the target face and of the shared edges var faceBox = try(evBox3d(context, { \"topology\" : definition.target })); var toolBox = try(evBox3d(context, { \"topology\" : edgesInFace })); // Again, to prevent excessive computation we will estimate the maximum number of instances and // fail early if we exceed some limit. var diagonal = faceBox.maxCorner - faceBox.minCorner; var maximumIndex = round((norm(diagonal) - (definition.border * 2)) / definition.distance); var toolSize = norm(toolBox.maxCorner - toolBox.minCorner); var estimatedIndexCount = maximumIndex * maximumIndex; if (estimatedIndexCount > 2500) { throw regenError(\"Too many instances in the pattern (estimate: \" ~ estimatedIndexCount ~ \" ). Try a larger spacing.\"); } // Now we loop and look to see if the instance should be included for (var i = -maximumIndex; i <= maximumIndex; i += 1) { for (var j = -maximumIndex; j <= maximumIndex; j += 1) { if (abs(i) < 0.5 && abs(j) < 0.5) { // Zero transform = initial position => Skip continue; } var translation = ((direction * i) + (angled * j)) * definition.distance; var instanceTransform = transform(translation); // Now that we have the transform we transform the tool box and see if it is within the face // but not too close to the edges of the face // Note: this isn't exact, it uses the center of the face and the size of the face box // rather than transforming the geometry every time. var xformed = box3d(toolBox.minCorner + translation, toolBox.maxCorner + translation); if (clash(xformed, faceBox)) { var minDistance = evDistance(context, { \"side0\" : targetEdges, \"side1\" : (xformed.minCorner + xformed.maxCorner) * 0.5 }); // Note: if border is zero this still results in a border that is half the size of the tool, // the border is additional on top of that if (minDistance.distance > (toolSize + definition.border)) { transforms = append(transforms, instanceTransform); instanceNames = append(instanceNames, \"\" ~ i ~ \".\" ~ j); } } } } // Now we set the data as needed by the applyPattern function before calling it. definition.patternType = PatternType.FACE; definition.transforms = transforms; definition.instanceNames = instanceNames; definition.seed = definition.entities; var remainingTransform = getRemainderPatternTransform(context, { \"references\" : definition.entities }); applyPattern(context, id, definition, remainingTransform); }, { }); /** * Utility function to do a quick clash of boxes */ function clash(box1 is Box3d, box2 is Box3d) returns boolean { for (var index = 0; index < 3; index += 1) { var min1 = box1.minCorner[index]; var max1 = box1.maxCorner[index]; var min2 = box2.minCorner[index]; var max2 = box2.maxCorner[index]; // Comparisons to zero are never a good idea because values that are calculated separately are // rarely the same to machine precision. FeatureScript provides tolerant equality methods // but not tolerant inequalities. No matter, we can fashion one ourselves by checking the // inequality and excluding approximate equality if ((max1 < min2 && !tolerantEquals(max1, min2)) || (max2 < min1 && !tolerantEquals(max2, min1))) { return false; } } return true; } Rib FeatureScript 程式碼: FeatureScript 336; import(path : \"onshape/std/geometry.fs\", version : \"336.0\"); const RIB_THICKEN_BOUNDS = { \"min\" : -TOLERANCE.zeroLength * meter, \"max\" : 500 * meter, (meter) : [0.0, 0.005, 500], (centimeter) : 0.5, (millimeter) : 5.0, (inch) : 0.25, (foot) : 0.025, (yard) : 0.01 } as LengthBoundSpec; /** * Specifies the direction of the rib extrusion starting from the profile * going up to the part. * * @value NORMAL_TO_SKETCH_PLANE : The direction of the rib extrusion goes normal to the profile sketch plane. * @value PARALLEL_TO_SKETCH_PLANE : The direction of the rib extrusion goes parallel to the profile sketch plane. */ export enum RibExtrusionDirection { annotation { \"Name\" : \"Normal to sketch plane\" } NORMAL_TO_SKETCH_PLANE, annotation { \"Name\" : \"Parallel to sketch plane\" } PARALLEL_TO_SKETCH_PLANE } function isClosed(context is Context, edge is Query) returns boolean { return size(evaluateQuery(context, qVertexAdjacent(edge, EntityType.VERTEX))) < 2; } annotation { \"Feature Type Name\" : \"Rib\" } export const rib = defineFeature(function(context is Context, id is Id, definition is map) precondition { annotation { \"Name\" : \"Sketch profiles\", \"Filter\" : EntityType.EDGE && SketchObject.YES && ConstructionObject.NO } definition.profiles is Query; annotation { \"Name\" : \"Parts\", \"Filter\" : EntityType.BODY } definition.parts is Query; annotation { \"Name\" : \"Thickness\" } isLength(definition.thickness, RIB_THICKEN_BOUNDS); annotation { \"Name\" : \"Rib extrusion direction\" } definition.ribExtrusionDirection is RibExtrusionDirection; annotation { \"Name\" : \"Opposite direction\", \"UIHint\" : \"OPPOSITE_DIRECTION\", \"Default\" : true } definition.oppositeDirection is boolean; annotation { \"Name\" : \"Extend profiles up to part\" } definition.extendProfilesUpToPart is boolean; annotation { \"Name\" : \"Merge ribs\", \"Default\" : true } definition.mergeRibs is boolean; } { const profiles = evaluateQuery(context, definition.profiles); const numberOfRibs = size(profiles); if (profiles == []) { throw regenError(\"Select sketch profiles for the rib contours\"); } if (evaluateQuery(context, definition.parts) == []) { throw regenError(\"Select parts where the rib will be fitted into\"); } // Create a transform for making the feature patternable via feature pattern. var remainingTransform = getRemainderPatternTransform(context, {\"references\" : qUnion([definition.profiles, definition.parts])}); // Before evaluating the profiles to create the ribs, we find out how big the parts are // so if any extending is necessary for any rib end, we know how far we need to extend. // To ensure the extended profile will always go past the part(s), we use the // diagonal of the bounding box of the part(s) and profile(s) as the extend length. const partBoundingBox = evBox3d(context, { \"topology\" : qUnion([definition.parts, definition.profiles]) }); const extendLength = norm(partBoundingBox.maxCorner - partBoundingBox.minCorner); // Create each rib (one rib per profile) as its own body. for (var i = 0; i < numberOfRibs; i += 1) { const profile = profiles[i]; const thickenId = id + (i ~ \"thickenRib\"); try { // Keep track of the entities we will extrude as a surface which will later // be thickened to create the rib. The profile and any // profile extensions will need to be included in the extrude operation. var entitiesToExtrude = [profile]; // Get the endpoints of the profile and the normal direction at those endpoints // so we can determine what needs to be extended and what direction to extend. const profileEndTangentLines = evEdgeTangentLines(context, { \"edge\" : profile, \"parameters\" : [0, 1], \"arcLengthParameterization\" : false }); // There are 2 reasons we might need to extend the given profiles: // 1. If the profile touches the part(s), make an extension of the profile past the part to ensure // that there are no gaps when we thicken the profile (this can happen if the profile is not normal // to the part where they intersect). // 2. The extend profiles up to part checkbox has been selected. const partsContainPoint = function(point is Vector) returns boolean { return evaluateQuery(context, qContainsPoint(definition.parts, remainingTransform * point)) != []; }; var extendProfiles = makeArray(2); var extendedEndPoints = makeArray(2); const extendDirections = [-profileEndTangentLines[0].direction, profileEndTangentLines[1].direction]; // If the profile is closed, then there is nothing to extend. const isProfileClosed = isClosed(context, profile); for (var end in [0, 1]) // Potentially extend both endpoints of the profile curve { extendProfiles[end] = !isProfileClosed && definition.extendProfilesUpToPart || partsContainPoint(profileEndTangentLines[end].origin); if (extendProfiles[end]) { extendedEndPoints[end] = profileEndTangentLines[end].origin + (extendDirections[end] * extendLength); // This is actually a quick way to create a line in 3D opFitSpline(context, id + (i ~ \"extendProfile\" ~ end), { \"points\" : [ profileEndTangentLines[end].origin, extendedEndPoints[end] ] }); entitiesToExtrude = append(entitiesToExtrude, qCreatedBy(id + (i ~ \"extendProfile\" ~ end), EntityType.EDGE)); } } // Find the direction to extrude a surface that will later be thickened to produce the rib. // First determine the normal or parallel direction, then, if specified, // choose the opposite of the normal or parallel direction. const profilePlane = evOwnerSketchPlane(context, { \"entity\" : profile }); var ribDirection; if (definition.ribExtrusionDirection == RibExtrusionDirection.PARALLEL_TO_SKETCH_PLANE) { // To get the parallel direction with the sketch plane, find the direction perpendicular // to the sketch plane normal and the line that connects the start and end point of the profile. const profileDirection = normalize(profileEndTangentLines[1].origin - profileEndTangentLines[0].origin); ribDirection = cross(profilePlane.normal, profileDirection); } else { ribDirection = profilePlane.normal; } if (definition.oppositeDirection) { ribDirection = ribDirection * -1; } // Extrude a surface from the extended profile into the part(s), using the extend length // as the extrude depth to make sure the surface goes through the part(s). opExtrude(context, id + (i ~ \"surfaceExtrude\"), { \"entities\" : qUnion(entitiesToExtrude), \"direction\" : ribDirection, \"endDepth\" : extendLength, \"endBound\" : BoundingType.BLIND }); // Transform the extruded surface if needed to support feature pattern. transformResultIfNecessary(context, id + (i ~ \"surfaceExtrude\"), remainingTransform); // Thicken the surface to make the rib plus some excess material around the part(s). const halfThickness = definition.thickness / 2; opThicken(context, thickenId, { \"entities\" : qCreatedBy(id + (i ~ \"surfaceExtrude\"), EntityType.FACE), \"thickness1\" : halfThickness, \"thickness2\" : halfThickness }); // Split the rib with the part(s) to separate the rib body from the thicken excess. var ribPartsQuery = qCreatedBy(thickenId, EntityType.BODY); opBoolean(context, id + (i ~ \"splitOffRibExcess\"), { \"tools\" : definition.parts, \"targets\" : ribPartsQuery, \"operationType\" : BooleanOperationType.SUBTRACTION, \"keepTools\" : true }); // Apply the remaining transform to the profile before doing collision testing. patternTransform(context, id + (i ~ \"tr1\"), profile, remainingTransform); // Do collision testing to help determine which parts of the thicken are excess. var clashes = evCollision(context, { \"tools\" : ribPartsQuery, \"targets\" : profile }); // Since we don't want the profile to actually move // move it back to it's original location after checking for collisions. patternTransform(context, id + (i ~ \"tr2\"), profile, inverse(remainingTransform)); var clashBodies = mapArray(clashes, function(clash) { return clash.toolBody; }); // Specify a point at the end of the surface extrude. // Any thicken body that intersects with this point is excess. const surfaceExtrudeEndPoint = profileEndTangentLines[0].origin + (extendLength * ribDirection); // Collect up all the thicken excess and any other entities we've created leading // up to the thicken operation, because all of these need to be deleted. var entitiesToDelete = [ // Remove rib thicken excess sections that don't intersect the original profile. qSubtraction(ribPartsQuery, qUnion(clashBodies)), // Remove rib thicken excess sections that extend all the way to the end of // the surface extrude (which we deliberately had extend well past the part, // i.e. well past where a rib should be created). qContainsPoint(ribPartsQuery, remainingTransform * surfaceExtrudeEndPoint), // Remove the surface extrude, now that the thicken is completed and we don't need it anymore. qCreatedBy(id + (i ~ \"surfaceExtrude\"), EntityType.BODY) ]; // Delete any profile extensions created now that we don't need them anymore. // Also, any thicken section that intersects with the far end of an extension // (i.e. not the end that intersects with the profile) is thicken excess and should be deleted. for (var end in [0, 1]) { if (extendProfiles[end]) { entitiesToDelete = append(entitiesToDelete, qCreatedBy(id + (i ~ \"extendProfile\" ~ end), EntityType.BODY)); entitiesToDelete = append(entitiesToDelete, qContainsPoint(ribPartsQuery, extendedEndPoints[end])); } } opDeleteBodies(context, id + (i ~ \"deleteRibExcess\"), { \"entities\" : qUnion(entitiesToDelete) }); } catch { throw regenError('Failed to create a rib from a selected profile.', profile); } // Fail early if the rib body can't be created. if (evaluateQuery(context, qCreatedBy(thickenId, EntityType.BODY)) == []) { throw regenError('Selected profile did not produce a rib body. Make sure the rib direction and alignment are correct.', profile); } } // Optionally, merge the new ribs with the original parts. if (definition.mergeRibs) { // The original parts are first in the tools query so that they // will maintain their names. var toMerge = [definition.parts]; for (var i = 0; i < numberOfRibs; i += 1) { toMerge = append(toMerge, qCreatedBy(id, EntityType.BODY)); } try { opBoolean(context, id + \"mergeRibsWithParts\", { \"tools\" : qUnion(toMerge), \"operationType\" : BooleanOperationType.UNION }); } catch { throw regenError('Failed to merge ribs into parts.'); } } }, { oppositeDirection : true, ribExtrusionDirection : RibExtrusionDirection.NORMAL_TO_SKETCH_PLANE, extendProfilesUpToPart : false, mergeRibs : true }); function patternTransform(context, id, query, transform) { if (transform == identityTransform()) return; opTransform(context, id, { \"bodies\" : qOwnerBody(query), \"transform\" : transform }); }"},{"url":"http://cadlab.mde.tw/post/onshape-featurescript-cheng-shi-yu-yan.html","tags":"MISC","title":"Onshape FeatureScript 程式語言","text":"在 FeatureScript 簡介 的影片中, 可以看到 Onshape 打造了一個客製化特徵功能的程式語言與社群分享機制, 任何人利用 FeatureScript 建立的延伸功能, 都能夠透過 Add custom features 指令與其他使用者分享. FeatureScript 是 Onshape 發明, 一種可用來定義客製化參數特徵用的程式語言, 具有下列特點: 各 Document 中用戶所建立的 FeatureScript 程式碼, 位於 Feature Studio (特徵工房) 分頁中. FeatureScript 的整合開發環境 (Integrated Development Environment) 內建於 Onshape 中. Onshape 原本系統中使用的特徵功能, 其對應的 FeatureScript 程式碼, 已經採 開放源 (Open Source) 模式釋出. Onshape 同時提供 FeatureScript 參考手冊 與 FeatureScript 論壇 登入 Onshape, 建立一個 Document 之後, 就可以透過左下角的 + 號中的 Create Feature Studio, 進入 FeatureScript 的整合開發環境, 開始編寫客製化的特徵程式碼, IDE 則提供下列相關功能: Parameter (參數) Length, Angle, Count, Query, Enum, Boolean and String Query (查詢) Everything, Nth element, Entity filter, Created by, Intersection, Subtraction, Symetric difference, Own by body, Own by body filter, Owner body, Entities adjacent to edge, Geometry type filter, Contains point, Intersects plane and Query evaluation Evaluation (評量) Tangent plane, Tangent line, Vertex point, Length measurement, Area measurement, Volume measurement, Query evaluation Sketch, Line segment, Circle, Arc, Ellipse, Rectangle, Line segment chain Cuboid, Cylinder, Extrude, Revolute, Fillet, Boolean, Transform, Import Import (導入) Format feature studio (整理特徵工房編輯格式) Commit (提交) FeatureScript 程式基本架構如下: FeatureScript 355; import(path : \"onshape/std/geometry.fs\", version : \"355.0\"); annotation { \"Feature Type Name\" : \"My Feature\" } export const myFeature = defineFeature(function(context is Context, id is Id, definition is map) precondition { // Define the parameters of the feature type } { // Define the function's action }); 上層宣告, 列舉值與指令敘述都可以加上 annotations (註解). FeatureScript 的註解使用格式類似 Python 的 Dictionary, 但是 annotation 的索引值型別必須為字串, 而且索引值為 \"Feature Type Name\" 的 annotation 為每一個特徵指令的必要註解. export 則可視為上述的程式碼中, 使用者所宣告的 myFeature 對應特徵物件會被優先置入 FeatureScript Template 中. 此外 Onshape 任一頁面送出時, 都帶有以下標頭設置, 除了利用 X-Frame-Options:SAMEORIGIN, 不允許使用者將頁面納入 iframe 或 object 標註中外, 也避免遭受可能的網路攻擊: Cache-Control:must-revalidate,no-cache,no-store Strict-Transport-Security:max-age=31536000; includeSubDomains X-Content-Type-Options:nosniff X-Frame-Options:SAMEORIGIN X-XSS-Protection:1; mode=block 以下則為目前 Onshape 官方釋出的參考應用範例: Point Pattern FeatureScript 程式 Document Spur Gear FeatureScript 程式 Document Wave Spring FeatureScript 程式 Document Port feature 程式碼 (建立 SAE J1926 螺孔): FeatureScript 336; import(path : \"onshape/std/geometry.fs\", version : \"336.0\"); export enum PortSize { annotation { \"Name\" : \"5/16-24\" } fiveSixteen, annotation { \"Name\" : \"3/8-24\" } threeEights, annotation { \"Name\" : \"7/16-20\" } sevenSixteen, annotation { \"Name\" : \"1/2-20\" } half, annotation { \"Name\" : \"9/16-18\" } nineSixteen, annotation { \"Name\" : \"3/4-16\" } threeFour, annotation { \"Name\" : \"7/8-14\" } sevenEights, annotation { \"Name\" : \"1 1/16-12\" } oneSixteen } annotation { \"Feature Type Name\" : \"Port Feature\" } export const portFeature = defineFeature(function(context is Context, id is Id, definition is map) precondition { annotation { \"Name\" : \"Port Size\" } definition.portSize is PortSize; annotation { \"Name\" : \"Points\", \"Filter\" : EntityType.VERTEX } definition.points is Query; annotation { \"Name\" : \"Depth\" } isLength(definition.depth, DEPTH_BOUNDS); } { var ports; var depth = definition.depth; //here the vector points for each port are added to an array depending on size chosen if (definition.portSize == PortSize.fiveSixteen) { ports = [vector(0, 0) * inch, vector(-depth, 0 * inch), vector(-depth + .019 * inch, -.031 * inch), vector(-.631, -.031) * inch, vector(-.53, -.132) * inch, vector(-.167, -.132) * inch, vector(-.136, -.163) * inch, vector(-.062, -.179) * inch, vector(-.062, -.336) * inch, vector(0, -.336) * inch, vector(0, 0) * inch]; } if (definition.portSize == PortSize.threeEights) { ports = [vector(0, 0) * inch, vector(-depth, 0 * inch), vector(-depth + .038 * inch, -.063 * inch), vector(-.629, -.063) * inch, vector(-.53, -.162) * inch, vector(-.169, -.162) * inch, vector(-.136, -.195) * inch, vector(-.062, -.211) * inch, vector(-.062, -.375) * inch, vector(0, -.375) * inch, vector(0, 0) * inch]; } if (definition.portSize == PortSize.sevenSixteen) { ports = [vector(0, 0) * inch, vector(-depth, 0 * inch), vector(-depth + .052 * inch, -.086 * inch), vector(-.663, -.086) * inch, vector(-.547, -.202) * inch, vector(-.176, -.202) * inch, vector(-.155, -.224) * inch, vector(-.062, -.243) * inch, vector(-.062, -.414) * inch, vector(0, -.414) * inch, vector(0, 0) * inch]; } if (definition.portSize == PortSize.half) { ports = [vector(0, 0) * inch, vector(-depth, 0 * inch), vector(-depth + .07 * inch, -.117 * inch), vector(-.71, -.117) * inch, vector(-.607, -.22) * inch, vector(-.188, -.22) * inch, vector(-.153, -.255) * inch, vector(-.062, -.275) * inch, vector(-.062, -.453) * inch, vector(0, -.453) * inch, vector(0, 0) * inch]; } if (definition.portSize == PortSize.nineSixteen) { ports = [vector(0, 0) * inch, vector(-depth, 0 * inch), vector(-depth + .089 * inch, -.149 * inch), vector(-.773, -.149) * inch, vector(-.671, -.251) * inch, vector(-.195, -.251) * inch, vector(-.159, -.287) * inch, vector(-.062, -.308) * inch, vector(-.062, -.485) * inch, vector(0, -.485) * inch, vector(0, 0) * inch]; } if (definition.portSize == PortSize.threeFour) { ports = [vector(0, 0) * inch, vector(-depth, 0 * inch), vector(-depth + .117 * inch, -.196 * inch), vector(-.928, -.196) * inch, vector(-.782, -.341) * inch, vector(-.237, -.341) * inch, vector(-.194, -.384) * inch, vector(-.094, -.406) * inch, vector(-.094, -.594) * inch, vector(0, -.594) * inch, vector(0, 0) * inch]; } if (definition.portSize == PortSize.sevenEights) { ports = [vector(0, 0) * inch, vector(-depth, 0 * inch), vector(-depth + .145 * inch, -.242 * inch), vector(-1.032, -.242) * inch, vector(-.875, -.399) * inch, vector(-.245, -.399) * inch, vector(-.194, -.45) * inch, vector(-.094, -.471) * inch, vector(-.094, -.672) * inch, vector(0, -.672) * inch, vector(0, 0) * inch]; } if (definition.portSize == PortSize.oneSixteen) { ports = [vector(0, 0) * inch, vector(-depth, 0 * inch), vector(-depth + .183 * inch, -.304 * inch), vector(-1.22, -.304) * inch, vector(-1, -.525) * inch, vector(-.246, -.525) * inch, vector(-.224, -.546) * inch, vector(-.094, -.574) * inch, vector(-.094, -.813) * inch, vector(0, -.813) * inch, vector(0, 0) * inch]; } const checkLength = (ports[3] - ports[2]); if (checkLength[0] < 0) // check the depth entered and throw error if depth causes feature to invert { throw regenError(ErrorStringEnum.SKETCH_DIMENSION_FAILED, [\"depth\"]); } var points = evaluateQuery(context, definition.points); var numberOfPoints = size(points); var sketchId = id + \"sketch\"; var portId = \"port1\"; for (var i = 0; i < numberOfPoints; i += 1) //for each point selected create a sketch using port vertices and revolve cut { sketchId = sketchId + i; var point = points[i]; var sketchPlane = evOwnerSketchPlane(context, { \"entity\" : point }); var cSys = planeToCSys(sketchPlane); var pointVertex = evVertexPoint(context, { \"vertex\" : point }); var sketchPlane2 = plane(pointVertex, cSys.xAxis, cSys.zAxis); var sketch = newSketchOnPlane(context, sketchId, { \"sketchPlane\" : sketchPlane2 }); skPolyline(sketch, portId, { \"points\" : ports, \"constrained\" : false }); skSolve(sketch); var axisQuery = sketchEntityQuery(sketchId, EntityType.EDGE, portId ~ \".line0\"); revolveCut(context, id, sketch, sketchId, axisQuery); } opDeleteBodies(context, id + \"delete_sketch\", { \"entities\" : qCreatedBy(id + \"sketch\", EntityType.BODY) }); // delete the sketch }, { /* default parameters */ }); function revolveCut(context is Context, id is Id, sketch is Sketch, sketchId is Id, axisQuery is Query) { var sketchQuery = qSketchRegion(sketchId, false); //revolve cut revolve(context, sketchId + \"revolve\", { \"operationType\" : NewBodyOperationType.REMOVE, \"entities\" : qUnion([sketchQuery]), \"axis\" : qUnion([axisQuery]), \"revolveType\" : RevolveType.FULL, \"defaultScope\" : true }); } const DEPTH_BOUNDS = { \"min\" : -TOLERANCE.zeroLength * meter, \"max\" : 500 * meter, (meter) : [1e-5, 0.0381, 500], (centimeter) : 3.81, (millimeter) : 38.1, (inch) : 1.5 // set the default depth to 1.5 inch } as LengthBoundSpec; Screw Boss FeatureScript 原始碼: /* Screw Boss This custom feature creates a common fastening feature in plastic part design. The Screw Boss is just one version of this type of fastening feature and could be easily extended to include many other types. This was built to show that you can create complex, compound features easily. Version 1 - April 26, 2016 - Neil Cooke, Onshape Inc. */ FeatureScript 336; import(path : \"onshape/std/geometry.fs\", version : \"336.0\"); annotation { \"Feature Type Name\" : \"Screw Boss\" } export const ScrewBoss = defineFeature(function(context is Context, id is Id, definition is map) precondition { annotation { \"Name\" : \"Sketch points to place bosses\", \"Filter\" : EntityType.VERTEX && SketchObject.YES && ConstructionObject.NO } definition.locations is Query; annotation { \"Name\" : \"Boss style\" } definition.style is BossStyle; if (definition.style == BossStyle.BLIND) { annotation { \"Name\" : \"Boss height\", \"UIHint\" : \"REMEMBER_PREVIOUS_VALUE\" } isLength(definition.height, BOSS_HEIGHT); } else { annotation { \"Name\" : \"Parallel face or plane\", \"Filter\" : EntityType.FACE, \"MaxNumberOfPicks\" : 1 } definition.parallelFace is Query; } annotation { \"Name\" : \"Boss diameter\", \"UIHint\" : \"REMEMBER_PREVIOUS_VALUE\" } isLength(definition.diameter, BOSS_DIA); annotation { \"Name\" : \"Ribs\", \"Default\" : true, \"UIHint\" : \"DISPLAY_SHORT\" } definition.hasRibs is boolean; if (definition.hasRibs == true) { annotation { \"Name\" : \"Number of ribs (max 6)\", \"UIHint\" : [\"DISPLAY_SHORT\", \"REMEMBER_PREVIOUS_VALUE\"] } isInteger(definition.ribCount, RIB_COUNT_BOUNDS); annotation { \"Name\" : \"Flip rib direction\", \"UIHint\" : \"OPPOSITE_DIRECTION\" } definition.ribFlipDirection is boolean; annotation { \"Name\" : \"Edge to define rib direction\", \"Filter\" : EntityType.EDGE, \"MaxNumberOfPicks\" : 1 } definition.ribDirection is Query; annotation { \"Name\" : \"Rib diameter at top\", \"UIHint\" : \"REMEMBER_PREVIOUS_VALUE\" } isLength(definition.ribDiameter, RIB_DIA); annotation { \"Name\" : \"Rib distance from top\", \"UIHint\" : \"REMEMBER_PREVIOUS_VALUE\" } isLength(definition.ribHeight, RIB_HEIGHT); annotation { \"Name\" : \"Rib thickness\", \"UIHint\" : \"REMEMBER_PREVIOUS_VALUE\" } isLength(definition.ribThickness, RIB_THK); annotation { \"Name\" : \"Chamfer\", \"UIHint\" : [\"DISPLAY_SHORT\", \"REMEMBER_PREVIOUS_VALUE\"], \"Default\" : true } definition.hasChamfer is boolean; if (definition.hasChamfer == true) { annotation { \"Name\" : \"Chamfer size\", \"UIHint\" : [\"DISPLAY_SHORT\", \"REMEMBER_PREVIOUS_VALUE\"] } isLength(definition.chamferSize, CHAMFER_SIZE); } } annotation { \"Name\" : \"Hole diameter\", \"UIHint\" : \"REMEMBER_PREVIOUS_VALUE\" } isLength(definition.holeDiam, HOLE_DIA); annotation { \"Name\" : \"Wall thickness\", \"UIHint\" : \"REMEMBER_PREVIOUS_VALUE\" } isLength(definition.wallThickness, WALL_THK); annotation { \"Name\" : \"Draft\", \"UIHint\" : [\"DISPLAY_SHORT\", \"REMEMBER_PREVIOUS_VALUE\"], \"Default\" : true } definition.hasDraft is boolean; if (definition.hasDraft == true) { annotation { \"Name\" : \"Draft angle\", \"UIHint\" : [\"DISPLAY_SHORT\", \"REMEMBER_PREVIOUS_VALUE\"] } isAngle(definition.draftAngle, DRAFT_ANGLE); } annotation { \"Name\" : \"Merge scope\", \"Filter\" : EntityType.BODY && BodyType.SOLID } definition.booleanScope is Query; } { // get all the user selected locations const locations = evaluateQuery(context, definition.locations); // if a solid body intersects the first point in the list, automatically use that in the merge scope const targetBody = evaluateQuery(context, qContainsPoint(qBodyType(qEverything(EntityType.BODY), BodyType.SOLID), evVertexPoint(context, { \"vertex\" : locations[0] }))); if (size(targetBody) == 0 && definition.booleanScope != undefined) definition.targetBody = definition.booleanScope; // if not, get user to select merge scope else definition.targetBody = targetBody[0]; var sketchPlane is Plane = evOwnerSketchPlane(context, { \"entity\" : locations[0] }); var topPlane; var ribPlane; // define the plane for the top of the boss if (definition.style == BossStyle.PLANE && definition.parallelFace != undefined) topPlane = evPlane(context, { \"face\" : definition.parallelFace }); else topPlane = plane(sketchPlane.origin + definition.height * sketchPlane.normal, sketchPlane.normal); var nameId = 1; definition.sketch = newSketchOnPlane(context, id + \"sketch1\", { \"sketchPlane\" : topPlane }); // Build first feature - extruded circle for (var location in locations) { var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { \"vertex\" : location })); skCircle(definition.sketch, \"circle\" ~ nameId, { \"center\" : vector(point[0], point[1]), \"radius\" : definition.diameter / 2 }); nameId += 1; } skSolve(definition.sketch); extrude(context, id + (\"extrude1\"), { \"entities\" : qSketchRegion(id + \"sketch1\"), \"endBound\" : BoundingType.UP_TO_BODY, \"endBoundEntityBody\" : definition.targetBody, \"oppositeDirection\" : true, \"hasDraft\" : definition.hasDraft, \"draftAngle\" : definition.draftAngle, \"draftPullDirection\" : false, \"operationType\" : NewBodyOperationType.ADD, \"defaultScope\" : false, \"booleanScope\" : definition.targetBody }); // Build second feature - extruded ribs if (definition.hasRibs) { // define top of ribs ribPlane = plane(topPlane.origin - definition.ribHeight * topPlane.normal, topPlane.normal); var ribVector = vector(0, 1); // by default pointing up in Y // if user has defined rib direction, work out the vector if (definition.ribDirection != undefined) { const directionResult = try(evAxis(context, { \"axis\" : definition.ribDirection })); if (directionResult != undefined) ribVector = normalize(vector(directionResult.direction[0], directionResult.direction[1])); } if (definition.ribFlipDirection) ribVector = ribVector * -1; definition.sketch = newSketchOnPlane(context, id + \"sketch2\", { \"sketchPlane\" : ribPlane }); const ribPlaneCSys = planeToCSys(ribPlane); var chamferPoints = []; nameId = 1; for (var location in locations) { var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { \"vertex\" : location })); const center = vector(point[0], point[1]); // Build a closed \"star\" shaped sketch to represent the ribs for (var j = 0; j < definition.ribCount; j += 1) { var angle = (360 / definition.ribCount) * j * degree; // The angle for each rib var angledRibVector = vector(ribVector[0] * cos(angle) - ribVector[1] * sin(angle), ribVector[0] * sin(angle) + ribVector[1] * cos(angle)); var perpRibVector = vector(angledRibVector[1] * -1, angledRibVector[0]); var ribOffset = definition.ribThickness / 2 / tan(180 / definition.ribCount * degree); if (definition.ribCount == 1) ribOffset = 0 * meter; var points = [ center - (definition.ribThickness / 2) * perpRibVector + (ribOffset) * angledRibVector, center - (definition.ribThickness / 2) * perpRibVector + (definition.ribDiameter / 2) * angledRibVector, center + (definition.ribThickness / 2) * perpRibVector + (definition.ribDiameter / 2) * angledRibVector, center + (definition.ribThickness / 2) * perpRibVector + (ribOffset) * angledRibVector]; for (var i = 0; i < size(points); i += 1) { skLineSegment(definition.sketch, \"line\" ~ nameId, { \"start\" : points[i], \"end\" : points[(i + 1) % size(points)] }); nameId += 1; } // Keep a list of the centerpoints of the edges where the chamfers may go var chamferPoint2d = center + (definition.ribDiameter / 2) * angledRibVector; chamferPoints = append(chamferPoints, toWorld(ribPlaneCSys, vector(chamferPoint2d[0], chamferPoint2d[1], 0 * meter))); } nameId += 1; } skSolve(definition.sketch); extrude(context, id + (\"extrude2\"), { \"entities\" : qSketchRegion(id + \"sketch2\"), \"endBound\" : BoundingType.UP_TO_BODY, \"endBoundEntityBody\" : definition.targetBody, \"oppositeDirection\" : true, \"hasDraft\" : definition.hasDraft, \"draftAngle\" : definition.draftAngle, \"draftPullDirection\" : false, \"operationType\" : NewBodyOperationType.ADD, \"defaultScope\" : false, \"booleanScope\" : definition.targetBody }); // Build third feature - chamfers if (definition.hasChamfer) { var chamferEdges = []; for (var i = 0; i < size(chamferPoints); i += 1) { // Find the edges that intersect the points previously collected chamferEdges = append(chamferEdges, qContainsPoint(qCreatedBy(id + \"extrude2\", EntityType.EDGE), chamferPoints[i])); } try(opChamfer(context, id + \"chamfer1\", { \"entities\" : qUnion(chamferEdges), \"chamferType\" : ChamferType.EQUAL_OFFSETS, \"width\" : definition.chamferSize })); } } nameId = 1; // Build fourth feature - through hole to outside of part var holePlane = plane(topPlane.origin - definition.wallThickness * topPlane.normal, topPlane.normal); definition.sketch = newSketchOnPlane(context, id + \"sketch3\", { \"sketchPlane\" : holePlane }); for (var location in locations) { var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { \"vertex\" : location })); skCircle(definition.sketch, \"circle\" ~ nameId, { \"center\" : vector(point[0], point[1]), \"radius\" : definition.diameter / 2 - definition.wallThickness }); nameId += 1; } skSolve(definition.sketch); extrude(context, id + (\"extrude3\"), { \"entities\" : qSketchRegion(id + \"sketch3\"), \"endBound\" : BoundingType.UP_TO_BODY, \"endBoundEntityBody\" : definition.targetBody, \"oppositeDirection\" : true, \"hasDraft\" : definition.hasDraft, \"draftAngle\" : definition.draftAngle, \"draftPullDirection\" : false, \"operationType\" : NewBodyOperationType.REMOVE, \"defaultScope\" : false, \"booleanScope\" : definition.targetBody }); nameId = 1; // Build fifth feature - screw hole definition.sketch = newSketchOnPlane(context, id + \"sketch4\", { \"sketchPlane\" : topPlane }); for (var location in locations) { var point is Vector = worldToPlane(topPlane, evVertexPoint(context, { \"vertex\" : location })); skCircle(definition.sketch, \"circle\" ~ nameId, { \"center\" : vector(point[0], point[1]), \"radius\" : definition.holeDiam / 2 }); nameId += 1; } skSolve(definition.sketch); extrude(context, id + (\"extrude4\"), { \"entities\" : qSketchRegion(id + \"sketch4\"), \"endBound\" : BoundingType.UP_TO_BODY, \"endBoundEntityBody\" : definition.targetBody, \"oppositeDirection\" : true, \"hasDraft\" : definition.hasDraft, \"draftAngle\" : definition.draftAngle, \"draftPullDirection\" : false, \"operationType\" : NewBodyOperationType.REMOVE, \"defaultScope\" : false, \"booleanScope\" : definition.targetBody }); // Remove sketch entities - no longer required var sketches = [qCreatedBy(id + \"sketch1\"), qCreatedBy(id + \"sketch2\"), qCreatedBy(id + \"sketch3\"), qCreatedBy(id + \"sketch4\")]; opDeleteBodies(context, id + \"delete\", { \"entities\" : qUnion(sketches) }); }, {}); const BOSS_HEIGHT = { \"min\" : -TOLERANCE.zeroLength * meter, \"max\" : 500 * meter, (meter) : [1e-5, 0.02, 500], (centimeter) : 2.0, (millimeter) : 20.0, (inch) : 0.8 } as LengthBoundSpec; const BOSS_DIA = { \"min\" : -TOLERANCE.zeroLength * meter, \"max\" : 500 * meter, (meter) : [1e-5, 0.008, 500], (centimeter) : 0.8, (millimeter) : 8.0, (inch) : 0.3125 } as LengthBoundSpec; const RIB_COUNT_BOUNDS = { \"min\" : 1, \"max\" : 6, (unitless) : [1, 4, 6] } as IntegerBoundSpec; const RIB_DIA = { \"min\" : -TOLERANCE.zeroLength * meter, \"max\" : 500 * meter, (meter) : [1e-5, 0.015, 500], (centimeter) : 1.5, (millimeter) : 15.0, (inch) : 0.6 } as LengthBoundSpec; const RIB_HEIGHT = { \"min\" : -TOLERANCE.zeroLength * meter, \"max\" : 500 * meter, (meter) : [0, 0.005, 500], (centimeter) : 0.5, (millimeter) : 5.0, (inch) : 0.2 } as LengthBoundSpec; const RIB_THK = { \"min\" : -TOLERANCE.zeroLength * meter, \"max\" : 500 * meter, (meter) : [1e-5, 0.001, 500], (centimeter) : 0.1, (millimeter) : 1.0, (inch) : 0.04 } as LengthBoundSpec; const CHAMFER_SIZE = { \"min\" : -TOLERANCE.zeroLength * meter, \"max\" : 500 * meter, (meter) : [1e-5, 0.002, 500], (centimeter) : 0.2, (millimeter) : 2.0, (inch) : 0.08 } as LengthBoundSpec; const HOLE_DIA = { \"min\" : -TOLERANCE.zeroLength * meter, \"max\" : 500 * meter, (meter) : [1e-5, 0.003, 500], (centimeter) : 0.3, (millimeter) : 3.0, (inch) : 0.12 } as LengthBoundSpec; const WALL_THK = { \"min\" : -TOLERANCE.zeroLength * meter, \"max\" : 500 * meter, (meter) : [1e-5, 0.0015, 500], (centimeter) : 0.15, (millimeter) : 1.5, (inch) : 0.06 } as LengthBoundSpec; const DRAFT_ANGLE = { \"min\" : -TOLERANCE.zeroAngle * radian, \"max\" : (2 * PI + TOLERANCE.zeroAngle) * radian, (degree) : [0, 2, 360], (radian) : 0.035 } as AngleBoundSpec; export enum BossStyle { annotation { \"Name\" : \"Blind\" } BLIND, annotation { \"Name\" : \"Up to face\" } PLANE }"},{"url":"http://cadlab.mde.tw/post/yun-duan-ping-tai-shang-de-dian-nao-fu-zhu-ji-jie-she-ji.html","tags":"MISC","title":"雲端平台上的電腦輔助機械設計","text":"Onshape 在 2015年12月 正式全面對外公開之後, 已經啟動電腦輔助機械設計的雲端世代, 為了追求高效能的全球協同產品設計流程, 利用跨硬體裝置, 免安裝, 具備設計特徵版次管理, 而且提供類似 Featurescript 客製化功能建構環境 (i.e. Feature Studio) 的全雲端電腦輔助機械設計工具, 將會日漸完備. 面對 Onshape 的破壞性創新產品挑戰, SolidWorks 也以採用 3dexperience platform 核心技術為主體, 推出全新的全雲端產品: Xdesign 回應. 目前, SolidWorks 單機版約佔全球市場 超過五分之一 , 未來將與自家的 Xdesign 與 Onshape 免安裝全雲端產品, 競逐全球電腦輔助機械設計軟體市場. 因此, 2016 年可以說是電腦輔助機械設計的雲端元年, 正好比 2006 年推出的 Google Doc , 晚了十年."},{"url":"http://cadlab.mde.tw/post/dian-nao-fu-zhu-she-ji-shi-de-dian-nao-kai-ji-ci-qu-she-zhi.html","tags":"MISC","title":"電腦輔助設計室的電腦開機磁區設置","text":"第1磁區: Windows 10 Pro + Hyper-V 安裝 Windows 7 Professional 第2磁區: Windows 10 Pro + 可攜免安裝程式套件 第3磁區: Ubuntu 16.04 Server + ubuntu-desktop 第1磁區擬舀採 Windows 10 Pro 開機, 並安裝常用的 CAD/CAE/CAM 相關軟體套件的安裝為主, 針對無法在 Windows 10 Pro 執行的套件, 則建議安裝在 Hyper-V 模式下的 Windows 7 Professional 開機磁區中. 第1磁區的網路設置以純 IPV4 為主, 並將最後一排的 9 台電腦, 以 IPV4/IPV6 雙支援的固定 IP 啟動 Ubuntu + Squid (選擇第3磁區開機), 讓上課師生自行選擇開機後透過 Round Robin DNS 配置域名的代理主機增速上網. 第2磁區擬採 Windows 10 Pro 開機, 並全數使用無需安裝的程式套件, 以提升套件使用效能, 網路配置則彈性配置純 IPV4 或純 IPV6 位址上網, 當採用純 IPV6 上網時, 必須啟動電腦輔助設計室中的 9 台 IPV4/IPV6 雙支援代理主機 (以 Ubuntu 磁區開機)."},{"url":"http://cadlab.mde.tw/post/da-xue-jiao-yu-zheng-ce-bai-pi-shu-du-hou-xin-de-bao-gao.html","tags":"MISC","title":"大學教育政策白皮書讀後心得報告","text":"15 年前寫的 大學教育政策白皮書 讀後心得報告 科技大學的本質在教導學生獲得知識的能力，二十一世紀知識經濟最大的特色，在於必須將知識迅速化為商品，由於市場全球化的影響，未能即時將本身所擁有的知識，快速轉化為商品，並被市場接受的企業，終將難逃被時代淘汰的命運，企業如此，教育界也正面臨同樣的挑戰。 教育部將大學的競爭力，視為國家競爭力的重要指標，全國各大學面對社會多元化的需求與全民終身學習的發展趨勢，如何在「大學教育政策白皮書」的基本方針下，強化各校的競爭力，建立各校的重點特色，便成為各大學今後所賴以生存的重要關鍵。 事實上，「大學教育政策白皮書」中所提到的觀點，或許是台灣一般大學與科技大學所共同面臨的問題，但，就基本體制上，仍然要有所區分，方能貫徹彼此的教育目標，為社會的現在與未來，提供充足的人力資源。吾人以為，一般大學的最高目標在追求學術的卓越，而科技大學則必須掌握技術的領先，學術強調的是其具備未來的主導性，卓越的學術指的是高瞻遠矚，是未來有用的技術；而技術的領先是要培養能馬上為企業所用的科技尖兵，是能馬上將知識轉化為商品的創新發明家。也許，隨著科技進化的速度日益增快，學術與技術的區隔，也就變得越來越小，但一般大學與科技大學應有的角色與定位，仍不失為各大學爭取重點特色時，所應強調的重點。 最後，談到本校在通過改名為科技大學後，如何在「大學教育政策白皮書」的指導方針下，爭取市場定位，並積極發展出屬於自己的特色，吾人以為，必須要先從小處做起，慢慢往大處做；必須要先由內做起，然後再漸漸往外落實。小處在哪裡，必須先用科學化與合理化來管理學校的每一個角落，然後才能談替企業診斷，為財團解憂。必須要先在校內建立起知識經濟的體系，然後才有可能與社會上全民學習的脈動相結合。未來，全球化經濟發展的趨勢或許很難臆測，但本校單類多科的包袱，如何逐步轉化為本校的重點特色，將是一項嚴酷的考驗，成敗的關鍵，就看現在。"},{"url":"http://cadlab.mde.tw/post/onshape-ji-jiang-shi-chu-featurescript-cheng-shi-yu-yan.html","tags":"MISC","title":"Onshape 即將釋出 Featurescript 程式語言","text":"今天早上參加 Onshape 在台灣所舉行的首次實體論壇，除了持續感受到 Onshape 團隊滿滿的誠意外，最大的收穫就是得知 Featurescript 特徵程式語言，即將開放各界使用。 所謂的 Featurescript， 根據了解，是一種可以透過 Feature Studio， 讓使用者修改或延伸 Onshape 特徵指令的新程式語言，據悉，目前 Onshape 所指供的特徵指令功能，也是透過 Featurescript 打造。 並且，未來使用者所打造的各式客製化 Featurescript 程式，可以在 Onshape App store 中免費公開或販售。"},{"url":"http://cadlab.mde.tw/post/dian-nao-fu-zhu-ji-jie-she-ji-liu-cheng-zhong-de-fen-san-shi-ban-ben-guan-li.html","tags":"導引","title":"電腦輔助機械設計流程中的分散式版本管理","text":"Bazaar (2004 年從 Gnu arch 分出), BitKeeper , darcs , Git , Mercurial 是目前較為常見的分散式版本管理 (Distributed Version Control Systems, DVCS) 技術, 其中自 1998 年前後推出, 唯一商用閉源的 Bitkeeper, 也終於在 2016.05.09, 宣佈轉為開放原始碼套件: https://users.bitkeeper.org/t/bk-7-2ce-released-2016-05-09/93 . 其實, 早在 1995 年左右的 Sun WorkShop TeamWare 就已經擁有分散式版本的相關技術, 而且在許多與機械設計相關的 PDM/PLM 系統中, 也都提供各種分散式版本控管的功能, 只是大多與封閉的檔案系統格式搭配使用, 使得多人協同模式下的電腦輔助機械設計流程, 成本不斷推升, 而且造成導入新技術的步調緩慢. 當然, 這些國際大公司面對快速發展的數位虛擬與雲端技術, 眼看無法透過賣斷的使用授權來限制使用者, 也紛紛隨著許多創新的先行者 (例如: Onshape), 喊出不再販售大而無當的單機賣斷版本套件, 而改採較具彈性的網路訂閱授權. 接下來, 當快速進展的全球協同模式必得讓各方團隊開始自行打造各式本地端、區域網路端、廣域網路端與雲端上的網際服務系統時, 目前最佳的授權認証模式, 則多採取 oauth2 的協定進行, 例如: Onshape 已經釋出 node.js 相容的程式模組: https://github.com/onshape/passport-onshape . 儘管如此, 身為一般的機械設計產品開發團隊, 仍然無法像全球大量持續甩開 Microsoft 約束的程式開發者一樣, 熱烈擁抱諸如 Linux 與 FreeBSD 相關分支, 因為 http://www.freecadweb.org/ 尚未大到可以取代許多封閉套件的地步, 現階段只能期待 Onshape 的授權方案能夠持續友善, 未來能夠有機會藉著清楚展示設計流程的分散式版本管理, 讓使用者能夠從此自混水中解脫. 儘管 Onshape 的 API 使用授權尚未全面釋出, 但是假如希望先利用 oauth2 自行打造一個網際產品設計開發系統, 可以參考下列的簡單程式開發描述: 讓使用者以 Gmail 帳號, 經由 google 制式流程登入後轉回應用程式 使用技術: oauth2 網際程式可以在本地端、區域網路端與雲端平台上佈署, 得到相同執行結果 使用技術: 利用物件案例的啟始, 建立所需的環境目錄架構, 以及起始資料庫檔案等, 利用操作系統模組讀取特定變數判定執行環境 資料庫存取技術與分頁 人性化的 Javascript 或 Brython 環境導入 美化的 Template 與 css 導入 Github, bitbucket 與 gogs 的程式開發版本管理 規劃所要維護的資料表: 人員名單含角色管理 事件管理 網際運算 (結合 Jupyter) 參考資料: flask http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-now-with-python-3-support oauth2 http://oauth.net/2/ https://blog.yorkxin.org/posts/2013/09/30/oauth2-1-introduction/ https://tools.ietf.org/html/rfc6749 git https://github.com/git working flow https://www.drupal.org/node/803746 Jupyter and oauth2 https://github.com/jupyterhub/oauthenticator https://github.com/ryanlovett/jh-google-oauthenticator"},{"url":"http://cadlab.mde.tw/post/chang-yong-python3-cheng-shi-mo-zu.html","tags":"導引","title":"常用 Python3 程式模組","text":"CherryPy , pytz , mako , beautifulsoup4 , pymysql , peewee , github3.py , authomatic 等是 CADLab 網際程式開發流程中較常用的 Python3 模組. 其中的 CherryPy 與 Flask 位階相似, 但是 特性卻有很大差別, CherryPy 小而自給自足, Flask 則架構較具彈性, 許多延伸功能都採 extension 方式補足, 有關 CherryPy 的各種用法, 請參考 http://cad-lab.github.io/manual/post/cherrypy-shi-yong-shou-ce.html . https://github.com/zzzeek/mako 的最大特色, 是將 Python 的語法直接放到 template 文件中, 儘管如此可能會讓使用者將原本應該放在控制端的資料流程, 分散到展示端, 但是實際採用後, 也沒有發生太大問題, 反而可以利用相同的網際程式, 直接套用到 Mako 與 Flask 內建的 template 語法中, 進行比較. github3.py 針對 Github 倉儲新增協同者的程式片斷範例: @app.route('/yourrepoadd', methods=['POST']) def yourrepoadd(): account = request.form[\"account\"] repository = \"yourrepo\" url = \"https://github.com/youraccount/yourrepo.git\" # 登入系統 g = github3.login(\"youraccount\", \"yourpassword\") # 以下則新增協同者 #g.repository(倉儲帳號, 倉儲名稱).add_collaborator(協同者 github 帳號) # 若新增 collaborator 成功傳回 True 否則傳回 False if g.repository(\"youraccount\", repository).add_collaborator(account): # 共同使用 cpaadd.html return render_template(\"cpaadd.html\", account=account, repository=repository, url=url) else: return render_template(\"cpaerror.html\") 至於 authomatic 的使用, 共有3個步驟: 1. 取得 key 與 secret 設定網址: https://console.developers.google.com 總共有兩項設定: 啟用 Google + API 然後到憑證處建立專案, 設定授權的 URI 設定目的在希望透過 Google+ API 讓 Web browser (Javascript) 能夠擷取 User data, 這時需要的是 Create an OAuth 2.0 client ID, 建立專案後, 必須選擇 Authorized Javascript origins 為 http://your.server.domain.name 與 http://localhost:5000, 而 Authorized redirect URIs 為: http://your.server.domain.name/autho_login/google/ 與 http://localhost:5000/autho_login/google/ 2. 導入模組, 進行設定 import authomatic from authomatic.providers import oauth2 CONFIG = { 'google': { 'class_': oauth2.Google, 'consumer_key': '1234567.apps.googleusercontent.com', 'consumer_secret': '87654321', #'scope': oauth2.Google.user_info_scope # 以下只允許(瞭解您在 Google 上的身分)與(檢視電子郵件地址) 'scope': ['email'] } } 3. 配合建立登入連結 @app.route('/autho_login/<provider_name>/', methods=['GET', 'POST']) def autho_login(provider_name): # We need response object for the WerkzeugAdapter. response = make_response() # Log the user in, pass it the adapter and the provider name. result = authomatic.login(WerkzeugAdapter(request, response), provider_name) # If there is no LoginResult object, the login procedure is still pending. if result: if result.user: # We need to update the user to get more info. result.user.update() # 利用 session 登記登入者的 email session['login_email'] = result.user.email # 這裡必須分近端與雲端, 因為 google logout redirect 的 url 不同 if 'OPENSHIFT_REPO_DIR' in os.environ.keys(): # 表示程式在雲端執行 local = False else: # 表示在近端執行 local = True # The rest happens inside the template. return render_template('autho_login.html', result=result, local=local) # Don't forget to return the response. return response oauth2 登入的情境 使用 oauth2 的目的, 在利用既有的使用者帳號進行應用程式的登入, 例如, 使用 facebook 或 gmail 帳號登入到我們所開發的網際應用程式, 好處是, 使用者無需在各類網際程式中額外再申請帳號, 而程式開發者也可以免去管理使用者帳號的難題. 但是, 為了在使用者被 oauth2 協定轉介到 gmail 登入頁面, 完成登入後, 就會再帶著帳號擁有者所允許的相關訊息, 回到網際應用程式中, 通常這些網際程式會利用 session 與 cookie 來儲存使用者登入的身份資料, 如此一來, 便有以下情境: 假如使用者在選擇登入到網際程式之前, 已經登入到 gmail, 那麼使用者無需再輸入帳號密碼, 只要同意允許擷取帳號資料 ,就會直接跳轉到網際程式功能中, 特別注意到, 這時 gmail 有使用者登入的 session 與 cookie, 而且使用者的瀏覽器還存在登入到網際應用程式的狀態. 第2種情況則是, 使用者被轉介到 gmail 登入畫面時, 才輸入帳號密碼登入, 之後情境就與上述第1種情況相同. 上述兩種情況, 在瀏覽器中, 使用者的狀態是同時登入到 gmail 與網際程式中, 即便使用者登入網際程式後, 若使用者沒有主動登出 gmail, 這位使用者在瀏覽器的狀態中, 仍然保持登入到 gmail 的狀態. 因此第3種情況則是, 使用者經由 oauth2 協定轉介到 gmail 登入後同意讓網際程式擷取帳號資料後, 就能登入到網際程式中, 隨後使用者主動登出 gmail, 並不會影響仍然登入到網際程式中的狀態, 一直到使用者選擇登出網際應用程式為止. 理論上, 假如我們所開發的網際程式, 只是透過一系列上述的設定, 藉由 gmail 的帳號, 來登入我們所開發的網際程式, 比較好的作法是一旦完成我們網際應用程式的登入後, 可以經由程式方法登出使用者的 gmail 帳號, 然後再由使用者決定何時要登出我們所開發的網際程式. 以下就是利用 Javascript 在登入應用程式之後, 設法登出使用者 gmail 帳號的設計, 並且同時支援本地端程式開發與雲端應用的情況: {# autho_login.html #} {% extends \"autho_base.html\" %} {% block body %} <!-- 這裡應該要再分近端與雲端的不同處理流程, 而且要在設定時便取得綁定的雲端網址 --> {% if local %} <script type=\"text/javascript\"> window.location=\"https://www.google.com/accounts/Logout?continue=https://appengine.google.com/_ah/logout?continue=http://localhost:5000/check_login\"; </script> {% else %} <script type=\"text/javascript\"> window.location=\"https://www.google.com/accounts/Logout?continue=https://appengine.google.com/_ah/logout?continue=http://your.server.domain.name/check_login\"; </script> {% endif %} {% endblock body %}"},{"url":"http://cadlab.mde.tw/post/dian-nao-fu-zhu-she-ji-shi-wang-zhi-kai-tong.html","tags":"規劃","title":"電腦輔助設計室網誌開通","text":"機械設計工程系電腦輔助設計室 2016 Fall 電腦系統規劃. CADLab 是國立虎尾科技大學機械設計工程系, 綜一館八樓, 共配置 64 台 (9x7 加上老師一台) 個人電腦的教學實驗室. 網誌文章分類 本網站的文章分類暫定為: 規劃 (Planning) - 規劃中的專案, 但是尚未完成之前的相關配置與架構設計紀錄 導引 (Tutorial) - 已經完成的流程紀錄與心得感想 資源 (Resources) - 配合上課需求所提供的各項內容服務 參考 (References) - 紀錄其他相關類似教學實驗室的管理方法與現況了解 其他 (Misc) - 未能納入上述其他分類的文章 磁區規劃 第1開機磁區為 Windows 10 Pro 或 Education 64 位元版 , 存放必須安裝才能啟動的應用程式 第2開機磁區為 Windows 10 Pro 或 Education 64 位元版 , 存放無需安裝的綠色應用程式 第3開機磁區為 Ubuntu 16.04 LTS Server 版 加裝 ubuntu-desktop 第1開機磁區 網路連線以 IPV4 設定為主 若有部份教學程式無法在 Windows 10 Pro 或 Education 64 位元版 操作系統中啟動, 將建議在 Virtualbox 中, 安裝 Windows 7 Professional 環境中使用 由於仍需透過 NAT 轉址, 64 台電腦將共用一個對外 IP, 為提升連線速度, 將在系主幹建立四台代理主機, 由上課老師選擇使用 第2開機磁區 網路連線以 IPV4 設定為主, 並以 IPV6 為輔 當網路連線採 IPV6 上網後, 每一排特定電腦將以第3磁區開機 (共需要 9 個固定 IPV4 IP 位址), 並預先設定為 IPV4/IPV6 雙支援協定, 並啟動 Proxy Server , 其餘 55 台電腦將透過代理主機連線上網 本磁區中的所有應用程式將以可攜方式配置, 無需安裝, 並同時提供支援 Ubuntu 或其他 Linux 操作系統中的對應版本 第3開機磁區 網路連線將以 IPV6 為主, 其中 9 台電腦將額外設置同時支援 IPV4/IPV6, 以便當作 Proxy Server , 讓其他純 IPV6 連線電腦可以連接純 IPV4 協定主機 由於本磁區無法受還原卡保護, 因此開機後僅提供一般用戶權限, 使用預先安裝的應用套件 本磁區所安裝的應用程式套件, 將與第2磁區對應, 專門提供跨平台應用程式教學使用 CADLab 使用與維護 各班上課時, 每排推派一名輪值生, 負責事項: 敦促同學不要在電腦桌上用餐 上課前後, 負責到 CADLab 日誌, 登記或勾選學員電腦使用情形, 填寫維修單或建議表 負責在課後, 確實檢查各電腦是否正常關機, 是否遺留個人物品 負責在課後清潔各排座位地板與桌面, 與班上幹部配合全員離開 CADLab 前確實關閉所有照明與空調系統"},{"url":"http://cadlab.mde.tw/post/onshape-ti-gong-mian-fei-jiao-yu-dan-wei-zhang-hao.html","tags":"導引","title":"Onshape 提供免費教育單位帳號","text":"從 https://www.onshape.com/cad-blog/introducing-the-onshape-education-plan 得知, Onshpae 除了提供各種身份的用戶有使用限度的免費帳號以外, 從 2016.04.07 開始更加碼, 讓教育單位可以免費, 且沒有使用限度的情況下, 來探索使用這個劃時代的雲端電腦輔助機械設計套件. 穩定的網路連線是使用 Onshpae 的必要條件 假如電腦教室網路連線穩定, 六十名學生可以同時利用 Firefox 或 Chrome, 登入到 Onshape 執行協同產品設計, 登記免費的教育單位專用帳號後, 只要完成電子郵箱驗證, 就會自動登入系統. Onshape 的 Document 是專案容器 登入後, 可以利用左側的 Tutorials & Samples 來了解 Onshpae 的用法: Onshape 中的 Documents 為設計專案層次 (Project level) 的文件庫 (Container), 可以納入 3D 零件, 3D 組件, 工程圖, 以及從外部轉入的各式檔案. Onshape 操作無需存檔, 而且保有流程版本 在 Onshpae 環境中操作零件繪圖, 使用者無需手動存檔, 只要完成任何操作, 都會自動儲存版本, 而且可以在各版本之間遊走. 登入 Onshape, 就可以利用左上角的 Create 按鈕建立 Document 專案文件, 然後再利用左下角的 + 號, 選擇要建立零件, 組件, 工程圖或者是從本地端上傳各式文件. 假如是建立零件, 與其他 MCAD 套件類似, 可以選擇 Sketch 再選擇作圖平面, 或者先選擇作圖平面, 再選擇 Sketch 繪製平面輪廓, 輪廓繪圖, 可以直接在 3D 環境畫圖, 或者利用滑鼠右鍵帶出 View normal to sketch plane 的功能, 以垂直繪圖面的平面上進行繪圖. Onshape 可以轉出各式檔案 各種基本的平面繪圖與尺寸標定或約束條件設定, 都與其他傳統的單機 MCAD 大同小異, 雖然 Onshape 與 Solid Edge 採用相同的 PARASOLID kernel, 但是所有的零組件檔案, 可以直接以點選下方的零組件 Tab, 再以滑鼠右鍵帶出 Export 功能, 然後轉成 PARASOLID 或 ACIS 核心檔,甚至也能直接轉成 Solidworks 格式檔案, 當然也能轉成 IGES, STEP, RHINO, STL 等格式. Onshape 擁有直覺的組立約束 當使用者在 Onshape 零件繪製模式下完成基本零件, 就可以利用左下方的 + 建立組立檔, 將各零件一一放入進行組裝. Fastened mate 主要用於焊接式的組合, 約束條件置入後, 兩個零件間已經沒有任何自由度而結為一體. Revolute mate 主要用於旋轉軸式的組合, 約束條件置入後, 兩個零件間只留下一個旋轉自由度. Slider mate 主要用於滑塊式的組合, 約束條件置入後, 兩個零件間只留下一個平移自由度. Planar mate 主要用於面接式組合, 約束條件置入後, 兩個零件面對面靠接, 只允許兩個方向的移動自由度, 以及垂直靠接面方向的一個旋轉自由度. Pin slot mate 主要用於插銷式組合, 約束條件置入後, 兩個零件具有旋轉與側向平移等兩個自由度. Ball mate 主要用於球接頭式的組合, 約束條件置入後, 將保留3個方向的旋轉自由度. Tangent mate 則是比較特殊的相切組立, 約束條件置入後, 兩個零件將始終保持相切的關係. 簡單的組立應用 根據上述基本功能, 就可以完成下列腳踏車鏈條的基本組立: 教育版對應帳號下所完成的 Bike chain Document ."},{"url":"http://cadlab.mde.tw/post/bezier-qu-xian-dao-yin.html","tags":"導引","title":"Bezier 曲線導引","text":"A primer on Bezier curves http://pomax.github.io/bezierinfo/ http://pomax.github.io/bezierjs/ 嘗試將純 Javascript 的環境轉為 Brython based https://github.com/brython-dev/brython , 希望完成之後, 可以讓使用者編寫 Python3 程式碼來操控 Bezier 曲線 https://en.wikipedia.org/wiki/B%C3%A9zier_curve ."},{"url":"http://cadlab.mde.tw/post/cadlab-cade-ruan-ti-tao-jian-shi-yong-jian-yi.html","tags":"資源","title":"CADLab CAD/E 軟體套件使用建議","text":"電腦輔助設計與工程分析是機械設計工程師進行 2D/3D 繪圖與理論分析表達的重要工具, 這裡是我們建議學員使用的 CAD/CAE 軟體套件. CAD: 商用封閉單機套件: SolidWorks 與 PTC Creo 雲端封閉套件(提供免費使用方案): Onshape: http://onshape.com 自由開源套件: Solvespace: http://solvespace.com/ FreeCAD: http://www.freecadweb.org/ CAE: 商用封閉套件: ansys 與 comsol 自由開源套件: Elmer: https://www.csc.fi/web/elmer Kratos: http://www.cimne.com/kratos 數值運算: 商用封閉套件: Matlab 與 Mathematica 自由開源套件: Jupyter: http://jupyter.org/"},{"url":"http://cadlab.mde.tw/post/cadlab-de-li-xiang-she-zhi.html","tags":"參考","title":"Cadlab 的理想設置","text":"一個符合二十一世紀工學院實際需求的電腦輔助設計室, 應該如何規劃配置? Cadlab 是個熱門的名詞, 代表 Computer Aided Design Laboratory, 也就是電腦輔助設計實驗室, 或簡稱電腦輔助設計室. 過去的電腦輔助設計室, 充滿各種讓使用者進行電腦輔助設計的公用電腦, 加上部份伺服器提供相關設計運算或資料儲存之用, 而現在, 這樣的配置可能不再恰當, 尤其是一間配置著 60 幾台最新硬體的桌上型電腦, 但卻採用所謂的防寫卡進行硬碟保護的電腦, 倘若無法隨時配合著經常性的操作系統或應用軟體更新, 這樣的 Cadlab 配置, 更是錯上加錯. 其實, 二十一世紀的工學院, 所有課程都應該在數位網路環境中進行, 因此所有這些所謂未來的工程師, 就應該在入學的第1天就被配予一台 17 寸的筆記型電腦, 而且裝載著各種未來幾年甚至離開學校之後, 都還能夠合法使用的相關專業用軟硬體套件. 過去, 由於全球協同的步調較慢, 各種產品的生命週期時間較長, 因此允許學校與產業界的差異性容忍度較大, 但是, 近幾年在在各種資訊與通訊軟硬體的快速發展衝擊下, 不僅全球協同的步調加速, 各種產品的生命週期愈來愈短, 促使學校教育單位與產業界必須在某些層面上攜手同步, 否則終將無法培育出適才、適所與適任的未來工程師. 而且, 隨著可攜裝置與自造軟硬體的逐步普及, Cadlab 配置中的所謂電腦, 除了包括讓工程師可以隨身攜帶的筆記型電腦以外, 還必須包括各類微控制器與 3D 印表機, 讓 Cadlab 實驗室中的各種系統模擬, 可以透過初步的硬體原型測試基本的可行性."},{"url":"http://cadlab.mde.tw/post/cadlab-ji-jie-she-ji-xi-wang-lu-pei-zhi-tu.html","tags":"規劃","title":"CADLab 機械設計系網路配置圖","text":"我們正在使用 Python3 與 http://blockdiag.com/en/ 中的 nwdiag 工具繪製機械設計工程系的網路配置圖. 從 機械設計專題的表達、技術領域與考量層面 範例, 可以了解利用文字描述轉成 2D 流程圖, 具有容易修改維護的優點, 這裡運用相同的概念, 嘗試利用類似的 nwdiag 工具, 畫出整個系的網路配置圖. blockdiag 與 nwdiag 若能夠搭配全球資訊網路上的 Python3 wsgi 程式, 採用資料庫系統來管理機械設計工程系的網路資源配置, 將可以實際納為 網際內容管理 課程的教材. 上述 CADLab 網路配置圖對應的 nwdiag 描述文件: nwdiag { default_fontsize = 15; 校主幹 [shape = cloud]; 校主幹 -- 系路由器; network 系主幹{ address = \"140.130.17.0/24\"; 系路由器 [address=\"140.130.17.254\"]; 雲端點名網路; 八樓集線器 [address=\"140.130.17.82\"]; 七樓集線器; 六樓集線器; 系伺服器群; } network 八樓主幹{ address=\"17.10-82\" 八樓集線器 [address=\"140.130.17.82\"]; 老師1伺服器群 [address=\"140.130.17.10-15\"]; 老師2伺服器群 [address=\"140.130.17.16-25\"]; 老師3伺服器群 [address=\"140.130.17.26-60\"]; } network CAD_CAE{ address=\"17.83\"; 八樓集線器 [address=\"140.130.17.82\"]; CAD_NAT [address=\"140.130.17.82\"]; CAE_NAT [address=\"140.130.17.83\"]; } network 電腦輔助設計室{ address=\"192.168.1.0/24\"; CAD_NAT [address=\"192.168.1.1\"]; CAD1 [address=\".2\"]; CAD2; CAD64 [address=\".100\"]; } network 電腦輔助繪圖室{ address=\"192.168.1.0/24\"; CAE_NAT [address=\"192.168.1.1\"]; CAE1 [address=\".2\"]; CAE2; CAE64 [address=\".100\"]; } network 七樓主幹{ address=\"140.130.17.83-90\" 七樓集線器; 老師4伺服器群 [address=\"140.130.17.61-63\"]; 老師5伺服器群 [address=\"140.130.17.64-70\"]; 老師6伺服器群 [address=\"140.130.17.71-75\"]; } network 六樓主幹{ address=\"140.130.17.91-100\" 六樓集線器; 老師7伺服器群 [address=\"140.130.17.76-78\"]; 老師8伺服器群 [address=\"140.130.17.79-80\"]; 老師9伺服器群 [address=\"140.130.17.81-95\"]; } }"},{"url":"http://cadlab.mde.tw/post/cadlab-wang-lu-pei-xian-hui-tu.html","tags":"參考","title":"CADLab 網路配線繪圖","text":"利用程式方法執行網路配線繪圖 CADLab 中的網路配線圖, 就如同 http://blockdiag.com/en/ 專案所示, 可以利用語法描述參數與配置之後, 透過程式方法轉出結果. 以 nwdiag https://bitbucket.org/blockdiag/nwdiag 為例, 在只有 Python3 的 Windows 環境中安裝: pip install nwdiag 之後就可以利用 nwdiag 命令解讀 .diag network diagram 描述檔, 並且轉為 png 或 svg 格式. 假如是在同時裝有 Python2 與 Python3 的 Ubuntu 環境中安裝 nwdiag: pip3 install nwdiag 之後的應用與 Windows 環境相同. http://blockdiag.com/en/ 專案還有方塊圖 blockdiag, 序列圖 seqdiag 以及活動圖 actdiag 等相關繪圖的應用. 最後假如 CADLab 希望利用 Sphinx 來整理電腦輔助設計室的文件, 則可以套用 https://github.com/blockdiag 中的 extensions 工具."},{"url":"http://cadlab.mde.tw/post/cadlab-xue-yuan-qia-pian-dian-nao-gui-ge-yu-ying-yong.html","tags":"參考","title":"CADLab 學員卡片電腦規格與應用","text":"卡片電腦 (credit-card sized computer) 的盛行, 除了在操作系統上有機會讓 CADLab 的學員, 得以學習 Windows 10 以外的應用, 最大的功用, 是讓機械設計工程專長的學員能夠實際動手, 理解網路的整合, 並且迎接自造 (self-manufacturing) 時代的蒞臨. Raspberry Pi 3 電腦 當一間嚴格管理, 軟硬體配置僵化的 CADLab 電腦輔助設計室已經無法滿足現代機械設計科技人才的培育使用時, 導入以 Raspberry Pi 3 Model B 為基礎的個人隨身卡片電腦, 應該是個不錯的選擇. 2016 年 2 月份推出的這一片採用 1.2GHz 64-bit quad-core ARMv8 CPU 的小卡片電腦, 不僅能夠用來控制 http://delta.firepick.org/ , 可以安裝執行 Jupyter hub , 而且在 Noobs 操作系統套件中, 還 內建 免費的非營利版 Mathematica. 以下是我們建議學員自備的 Raspberry Pi 3 Model B 卡片電腦規格: 處理器: Broadcom BCM2387 晶片組，1.2GHz 四核心 ARM Cortex-A53.802.11 b/g/n 無線 LAN 和藍牙 4.1 GPU: 雙核心 VideoCore IVR 多媒體協同處理器。提供 Open GL ES 2.0、硬體加速 OpenVG，以及 1080p30 H.264 高型解碼。支援 1Gpixel/s、1.5Gtexel/s 或 24GFLOPs，並具備材質過濾功能與 DMA 基礎架構 記憶體: 1GB LPDDR2 作業系統: 由 Micro SD 記憶卡(建議使用 32 GB 以上) 啟動，建議安裝 Raspbian 操作系統 尺寸: 85 x 56 x 17mm 電源: Micro USB 插槽 5V1，2.5A Raspbian 安裝配置 當學員拿到 Raspberry Pi 3 卡片電腦之後, 首次配置時, 建議使用 CADLab 教室中的 HDMI 線連接到支援 HDMI 的電腦螢幕後, 進行 Raspbian 操作系統的安裝, 安裝後則必須開啟 SSH 的連線, 並且編輯 /etc/lightdm/lightdm.conf 設定檔, 將 [XDMCPServer] 項下的 enabled 設為 true. CADLab 卡片電腦使用情境 完成 Raspbin 系統安裝後, Raspberry Pi 3 電腦在 CADLab 教室使用, 共有兩種基本情境: 連接滑鼠鍵盤螢幕開機 目前的 CADLab 電腦配置, USB 鍵盤與滑鼠的接頭是採隱藏式保護, 因此學員無法直接以公用的滑鼠與鍵盤連接 Raspberry Pi 3 卡片電腦, 但是若新配置的新電腦設備允許學員使用公用的 USB 鍵盤與滑鼠, 並且提供支援 HDMI 格式的電腦螢幕, 用戶就可以很單純直接用自行攜入的 Raspberry Pi 3 開機使用. 開機後, 可以透過 CADLab 中的 Wifi 連線 (Raspberry Pi 3 Model B 內建 802.11n Wireless LAN) 或實體線 (每桌必須提供 4 或 8 port hub) 上網, 使用較為簡單. 無滑鼠鍵盤螢幕開機 若新配置的 CADLab 電腦設備並不允許學員使用公用的滑鼠與鍵盤, 且桌上並無 hub 可用, 則建議 Raspberry Pi 3 使用者, 可以自帶一條網路跳線, 利用桌上型電腦的多 NIC 連線, 以 https://sourceforge.net/projects/dhcpserver/ 發給 Raspberry Pi 3 電腦臨時的內部網路 IP, 然後再利用 https://sourceforge.net/projects/xming/ , 以 XDMCP 協定 (只建議在內部網路使用, 廣域網路上, 建議採較安全的 SSH 連線), 登入 Raspberry Pi 3, 並且以 Wifi 連線到 CADLab 的 Access Point 後, 確定連線的 IP 位址後, 就可以移除與桌上型電腦的網路跳線, 改採與桌上型電腦同位階的內部網路上網, 然後透過桌上型電腦的 Putty, 以 SSH 連線到 Raspberry Pi 3 進行操控, 或者再透過 xming, 以 XDMCP 協定登入. 另外, 假如 Raspberry Pi 3 電腦並無與電腦教室其他電腦設備連線的要求, 用戶希望利用網路跳線與桌機相連後上網, 則建議在桌機上使用代理程式 http://www.youngzsoft.net/ccproxy/ 的免費版 (可以3個用戶使用), 讓 Raspberry pi 3 電腦以桌機的 proxy server 上網, 或者設法將桌上型電腦 Windows 7 或 10 操作系統上的第2片網路卡橋接到第1片已經上網的網卡上, Raspberry Pi 3 就可以藉此設定直接上網."},{"url":"http://cadlab.mde.tw/post/cadlab-xue-yuan-wang-zhi-xi-tong.html","tags":"規劃","title":"CADLab 學員網誌系統","text":"我們希望每一位 CADLab 電腦輔助設計室的學員都能夠充份利用現階段各種全球資訊網上的工具, 有效管理自己與團隊間的協同產品開發或學習過程的各種資訊. 這裡所謂的資訊包括: 口語資訊 Text 文字資訊 2D 圖面資訊 3D 動態資訊 系統模擬資訊 實體模型資訊 其中需要使用的工具包括 Python3, Leo Editor 以及 Pelican, 使用者若在 Windows 環境, 可以直接使用可攜套件: https://github.com/chiamingyen/kmol2016 . 而每位學員均可利用 http://www.cmsimply.com 來收集上述各種資訊內容, 然後再配合時機點與需求, 將資料分別同步到動態 Wordpress 網誌與 Pelican 靜態網誌. 目前所使用的 Leo Editor 網誌系統專案位於: https://github.com/cad-lab/manual , 學員可以在其中加入下列3個 Leo Editor 的指令按鈕, 讓內容與 Wordpress 動態網誌同步. #new-to-wordpress #coding: utf-8 import xmlrpc.client import datetime import os def get_cat_tag_content(data): # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python # 用跳行符號分割 data_list = data.split(\"\\n\") #第2行為 title title= data_list[1] #第3行為 category category = data_list[2] #第4行為 tags tags = data_list[3] # 有多項資料的 content 型別為數列 # 再將第7行之後的資料數列串回成以跳行隔開的資料 content = \"\\n\".join(data_list[6:]) # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 content = content.replace(' ', ' ') # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式 content = content.replace('~~~python', '[code lang=\"python\"]') content = content.replace('~~~', '[/code]') return title, category, tags, content os.environ['TZ'] = 'Asia/Taipei' ################################# filepath = \"/home/amd/Desktop/your_wordpress_account_and_password.txt\" wordpress = \"your-wordpress-site-url\" fo = open(filepath, \"r+\") data = [] for line in fo.readlines(): data.append(line) fo.close() # 從網誌節點的 parent().h 取得 wp_url # 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑 wp_url = \"https://\"+wordpress+\"/xmlrpc.php\" wp_username = data[0] wp_password = data[1] ################################# wp_blogid = \"0\" status_draft = 0 status_published = 1 server = xmlrpc.client.ServerProxy(wp_url) # 從目前所在節點的 body pan 中取出類別, tags 以及文章內容 title_str, category_str, tags_str, content = get_cat_tag_content(p.b) # title 是一個單獨的字串 title = title_str.split(\":\")[1] # 指定時間出版 ''' date_created = xmlrpc.client.DateTime(datetime.datetime.strptime(\"2013-01-01 00:00\", \"%Y-%m-%d %H:%M\")) ''' # 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表 date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \\ datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),\"%Y-%m-%d %H:%M\")) categories = [category_str.split(\":\")[1]] # 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料 # 先用 : 斷開標投頭的 Tags:, 然後再透過逗點隔開, 將標註轉為數列資料 tags = tags_str.split(\":\")[1].split(\",\") data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags} post_id = server.metaWeblog.newPost(wp_blogid, wp_username, wp_password, data, status_published) # 利用最後的 child 節點來儲存 post_id to_save_post_id = p.insertAsLastChild() # 改為內文為空的節點, id 直接標在 head 標題 to_save_post_id.b = \"\" to_save_post_id.h = post_id # 因為新增節點, commander 必須 redraw c.redraw() g.es(\"post_id 為\", post_id) g.es(\"已經送出資料!\") ''' 其他 metaWeblog 的用法: metaWeblog.newPost (blogid, username, password, struct, publish) returns string(postid) metaWeblog.editPost (postid, username, password, struct, publish) returns true metaWeblog.getPost (postid, username, password) returns struct(blog content) ''' #edit-to-wordpress #coding: utf-8 import xmlrpc.client import datetime import os def get_cat_tag_content(data): # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python # 用跳行符號分割 data_list = data.split(\"\\n\") #第2行為 title title= data_list[1] #第3行為 category category = data_list[2] #第4行為 tags tags = data_list[3] # 有多項資料的 content 型別為數列 # 再將第7行之後的資料數列串回成以跳行隔開的資料 content = \"\\n\".join(data_list[6:]) # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 content = content.replace(' ', ' ') # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式 content = content.replace('~~~python', '[code lang=\"python\"]') content = content.replace('~~~', '[/code]') return title, category, tags, content os.environ['TZ'] = 'Asia/Taipei' ################################# filepath = \"/home/amd/Desktop/your_wordpress_account_and_password.txt\" wordpress = \"your-wordpress-site-url\" fo = open(filepath, \"r+\") data = [] for line in fo.readlines(): data.append(line) fo.close() wp_url = \"https://\"+wordpress+\"/xmlrpc.php\" wp_username = data[0] wp_password = data[1] ################################# wp_blogid = \"0\" status_draft = 0 status_published = 1 server = xmlrpc.client.ServerProxy(wp_url) # 從目前所在節點的 body pan 中取出類別, tags 以及文章內容 title_str, category_str, tags_str, content = get_cat_tag_content(p.b) # title 是一個單獨的字串 title = title_str.split(\":\")[1] # 指定時間出版 ''' date_created = xmlrpc.client.DateTime(datetime.datetime.strptime(\"2013-01-01 00:00\", \"%Y-%m-%d %H:%M\")) ''' # 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表 date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \\ datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),\"%Y-%m-%d %H:%M\")) categories = [category_str.split(\":\")[1]] # 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料 tags = tags_str.split(\":\")[1].split(\",\") data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags} # 設法取得原 post 的 id origin_post = p.getLastChild() # 直接從標題取得 post 的 id 號碼 post_id = origin_post.h status = server.metaWeblog.editPost(post_id, wp_username, wp_password, data, status_published) if status: g.es(\"資料已經更新!\") else: g.es(\"有問題, 資料沒有更新!\") ''' 其他 metaWeblog 的用法: metaWeblog.newPost (blogid, username, password, struct, publish) returns string(postid) metaWeblog.editPost (postid, username, password, struct, publish) returns true metaWeblog.getPost (postid, username, password) returns struct(blog content) ''' #get-from-wordpress #coding: utf-8 import xmlrpc.client # 導入 html 模組, 使用 html.unescape 轉換 html 特殊符號 import html ################################# filepath = \"/home/amd/Desktop/your_wordpress_account_and_password.txt\" wordpress = \"your-wordpress-site-url\" fo = open(filepath, \"r+\") data = [] for line in fo.readlines(): data.append(line) fo.close() # 從網誌節點的 parent().h 取得 wp_url # 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑 wp_url = \"https://\"+wordpress+\"/xmlrpc.php\" wp_username = data[0] wp_password = data[1] ################################# server = xmlrpc.client.ServerProxy(wp_url) # 設法透過上述網誌網址, 帳號與密碼, 以及文章 id, 取回 categories, tags, 文章標題, 文章內容等資 # 從最後的 child 節點來取 post_id origin_post = p.getLastChild() post_id = origin_post.h # 取回與 post_id 對應的網誌文章內容 blog_content = server.metaWeblog.getPost(post_id, wp_username, wp_password) title = blog_content[\"title\"] # 這裡要利用 html.unescape 轉回特殊符號 description = html.unescape(blog_content[\"description\"]) mt_text_more = html.unescape(blog_content[\"mt_text_more\"]) if mt_text_more != \"\": post_content = description + \"\\n \\n\"+mt_text_more else: post_content = description # 所取回的 categories 為 list categories = blog_content[\"categories\"] # 所取回的 tags 為以逗點隔開的字串 mt_keywords = blog_content[\"mt_keywords\"] # 取回文章作者 author = blog_content[\"wp_author_display_name\"] p.h = title categories_str = \"\" for category in categories: # 假如不是最後一個 if category != categories[len(categories)-1]: categories_str += category + \", \" else: # 這是最後一個 categories_str += category line1 = \"@language md\\n\" line2 = \"Title: \" +title + \"\\n\" line3 = \"Category: \" + categories_str + \"\\n\" line4 = \"Tags: \" + mt_keywords + \"\\n\" line5 = \"Author: \" + author + \"\\n@others\\n\" post_content = post_content.replace(' ', '\\n \\n') post_content = post_content.replace('[code lang=\"python\"]', '~~~python') post_content = post_content.replace('[/code]', '~~~') p.b = line1 + line2 + line3 + line4 + line5 + post_content + \"\\n\" # 因為節點資料更新, commander 必須 redraw c.redraw() g.es(\"資料已經取回\")"},{"url":"http://cadlab.mde.tw/post/dao-ru-ubuntu-cao-zuo-xi-tong.html","tags":"導引","title":"導入 Ubuntu 操作系統","text":"身為一位機械設計工程系的學生, 有機會在 Ubuntu 操作系統上工作嗎? 自從 1995 年, 第1套能在 Windows 操作系統執行的電腦輔助機械設計繪圖軟體套件, SolidWorks, 出現, 並且逐步蔚為風潮之後, MCAD (Mechanical Computer Aided Design) 中端套件, 幾乎都只能在 Windows 操作系統上運作. 許多機械設計工程系相關師生, 幾乎早已經忘記, 最早的 MCAD 系統可都是在泛 Unix based 的操作系統上運作. 時間轉到 2015 年, Onshape: http://www.onshape.com 的出現, 雖然截至目前只提供陽春的 MCAD 功能, 但是至少讓原本必須在 Windows 操作系統上才能上課的約束條件, 頓時消失, 因為計算機程式、網際內容管理、電腦輔助設計實習與協同產品設計實習等課程, 已經能夠百分之百在 Ubuntu 操作系統上運作. 過去, 我們在 Windows 操作系統上的工作類別, 不外乎: 文書處理 程式編寫與執行 MCAD 零件繪圖, 零件組立 MCAE 工程分析 擷取執行畫面 錄製操作流程影片 遠端登入到其他電腦 (Remote Desktop) 以下將就這些工作分類, 介紹在 Ubuntu 操作系統中的相對應工具與使用方法. 首先, 這裡建議的 Ubuntu 操作系統為 Ubuntu Server 版本加上 ubuntu-desktop 套件的安裝. 一旦安裝完成, 第1項文書處理工作就可以由 LibreOffice 套件加以勝任. 程式編寫與執行 這裡包含 Python3, PyQt5, Leo Editor, SciTE, Git 等套件都是跨操作系統, 其中 Python3 已經內建在 Ubuntu 14.04 操作系統中, 只是必須透過 python3 執行, 例如: 必須在命令列中, 輸入 python3 帶出互動式解譯環境. pip3 模組則需要透過 sudo apt-get install python3-pip 安裝 PyQt5 則需要透過 sudo apt-get install python3-pyqt5 安裝 Leo Editor 透過 sudo pip3 install https://github.com/leo-editor/leo-editor/archive/master.zip 安裝, 並且以 leo& 呼叫 SciTE 透過 sudo apt-get install scite 安裝 git 透過 sudo apt-get install git 安裝 MCAD 零件與組件繪圖 這裡採用 http://www.onshape.com , 只需要 Firefox 或 Chromium 瀏覽器就可以運作 FreeCAD: http://www.freecadweb.org/ 與 Solvespace: http://solvespace.com/ , 則是能在 Ubuntu 環境運作的 MCAD 套件. MCAE 工程分析 這裡採用 http://www.simscale.com , 只需要 Firefox 或 Chromium 瀏覽器就可以運作 COMSOL 可以 在 Ubuntu 環境中運作 Ansys 則 建議 在 Red Hat 或 SUSE 商用版上運作 錄製操作流程影片 在 Ubuntu 操作系統中擷取電腦螢幕畫面, 只要按下 PrintScr 按鍵, 就可以直接存為 png 格式檔案 操作流程則可以使用 Kazam 將過程錄成 mp4檔案 Kazam: https://code.launchpad.net/~kazam-team/kazam/stable (以 Python 編寫) 安裝: sudo add-apt-repository ppa:kazam-team/stable-series sudo apt-get update sudo apt-get install kazam 使用: kazam& 至於在 Ubuntu 遠端登入到 Windows, 可以使用 Ubuntu Software Center 安裝 remmina, 並且在連線設定上的 Advanced 頁面中, Security 選用 RDP 協定, 即可正確連線. Ubuntu 檔案架構 /bin ­­ binary applications (most of your executable files) /boot ­­ files required to boot (such as the kernel, etc) /dev ­­ your devices (everything from drives to displays) /etc ­­ just about every configuration file for your system /etc/rc.d ­­ contains a number of shell scripts that are run on bootup at different run levels. /etc/X11 ­­ configuration files for the X Window system /home ­­ locally stored user files and folders /lib ­­ system libraries (similar to Program Files) /media ­­ mounted (or loaded) devices such as cdroms, digital cameras, etc. /mnt ­­ mounted file systems /opt ­­ location for \"optionally\" installed programs /sbin ­­ system ­only binaries /sys ­­ contains information about the system /tmp ­­ temporary files /usr ­­ applications mainly for regular users /var ­­ mainly logs, databases, etc. Ubuntu 常用指令 ls : list directory contents cd : Change Directory pwd : print the current/working directory mkdir : make/create directory rmdir : remove the empty directory rm : remove/delete file mv : rename or move a file/directory man : Manual pages for shell commands cp : Copy Files passwd : Change password for user tar : Creates and extracts files from a tape or disk archive find : find searches the file located at / grep : print lines matching a pattern chown : change file owner and group chgrp : change group ownership chmod : change file mode bits ifconfig : configure a network interface 參考資料: https://help.ubuntu.com/lts/serverguide/serverguide.pdf http://ecourts.nic.in/2/mannual/admin_manual.pdf http://wiki.lib.sun.ac.za/images/7/7b/Ubuntu-desktop.pdf http://askubuntu.com/questions/154121/why-wont-remmina-connect-to-windows-7-remote-desktop"},{"url":"http://cadlab.mde.tw/post/dian-nao-fu-zhu-she-ji-shi-wang-lu-lian-xian-guan-li.html","tags":"規劃","title":"電腦輔助設計室網路連線管理","text":"電腦輔助設計室長期以來都是在 IPV4 的架構下, 透過 NAT, 以共用一個網路位址上網, 若以整間教室 63 台電腦為例, 只需要設法利用 9 個固定的 IPV4 網路位址, 讓其中的 9 台電腦同時支援 IPV4 與 IPV6 協定, 並且透過 Squid 代理伺服器的設定, 就可以利用網路負載平衡, 大幅提升用戶的連網速度. 自 2012 年起校園主幹就已經全面支援 IPV6 的網路協定, 但是由於台灣大部份的網站仍然只提供 IPV4 網址與協定連線, 因此即使在 IPV6 網址無虞的情況下, 讓每一台電腦輔助設計室的電腦都透過 IPV6 協定取得網址, 仍然需要 IPV4/IPV6 雙支援的代理主機, 才能連結使用所有的網站. 因此目前的規劃是, 讓 63 台電腦全部透過 IPV6 協定取得 IP 位址上網, 但是其中的 9 台電腦則以其中規劃好的第3磁區 Ubuntu Server 開機 (其他兩個開機磁區分別為 Windows 7 與 Windows 10), 而且這 9 台電腦是在預先綁定 MAC 位址到雙支援 IPV4/IPV6 的固定 IP 情況下, 自行透過 DNS 設定, 以 Round Robin 的簡單負載平衡, 來服務其他僅設定 IPV6 DHCP Client 連線的電腦. 其次, 學員自行攜入 CADLab 使用的 Raspberry Pi 3 隨身卡片電腦, 也可以利用 IEEE 802.11n 的協定取得 IPV6 位址, 然後也是透過雙支援的代理伺服器連線上網. 而使用 git 相關指令之前, 必須確定已經設定 git config --global http.proxy http://myproxy.server:port git config --global https.proxy https://myproxy.server:port"},{"url":"http://cadlab.mde.tw/post/gai-ru-he-bian-xie-yi-fen-dian-nao-fu-zhu-ji-jie-she-ji-shi-yong-shou-ce.html","tags":"規劃","title":"該如何編寫一份電腦輔助機械設計使用手冊","text":"我們正在極力推廣使用的電腦輔助機械設計(Mechanical Computer Aided Design)相關套件, 包括 OnShape, Solvespace, FreeCAD, Elmer, V-rep 以及 Jupyter, 該如何用最\"好\"的方式來編寫使用手冊? 假如您已經在使用 OnShape, 一定已經看過 https://cad.onshape.com/help/ . 對應的 Solvespce 導引 http://solvespace.com/tutorial.pl 也是很不錯, 其他的幾個套件, 也都已經有了不錯的英文導引資料, 只是從教導學員協力完成某件電腦輔助設計流程工作的同時, 我們想要試試在 Github 的版次管理模式下, 我們能夠怎樣協同編寫一份電腦輔助設計相關的網頁式手冊. 啟動: 在 Github cad-lab 帳號下新增一個倉儲, 命名為 manual, 然後 git clone 到本地端, 準備置入能夠協同編輯的 Leo Editor 與 Pelican 架構. git clone https://github.com/cad-lab/manual.git cadlabmanual 之後, 進入 cadlabmanual 目錄, 利用 git branch gh-pages 建立 Github Pages 對應分支, 然後以 git checkout gh-pages 指令將本地端倉儲的工作目錄定位在 gh-pages 分支. 接下來就是放入 Pelican 靜態網頁系統, 就可以開始建立電腦輔助機械設計使用手冊了: http://cad-lab.github.io/manual/"},{"url":"http://cadlab.mde.tw/post/gigabit-yi-tai-wang-lu-xian.html","tags":"規劃","title":"Gigabit 乙太網路線","text":"目前在 CADLab 中使用的網路線為傳輸速率每秒十億 bit (10**9 bit/sec) 的 Category 6 Gigabit Ethernet. 採 1000BASE‑T 無遮蔽雙絞線, 以 EIA/TIA 568B 連接 RJ45 接頭. 其接線方式為接頭向前, 耳朵朝下, 混白線在前, 緊接著色線, 以橘藍綠棕排列後, 再將藍白與綠白對調, 就是 568B 的接法. 至於 568B 的網路跳線則再將一邊的橘白與橘線, 跟綠白與綠線對調. 因為橘白線的 pin 1 為 Transmit Data+, 橘線 pin2 則是 Transmit Data-, 綠白線 pin3 則為 Receive Data+, 綠線 pin 6 為 Receive Data-. 藍線 pin 4 與棕白 pin 7 同為 Bi-directional+, 而藍白線 pin5 與棕線 pin 8 則同為 Bi-directional-. 為了達到規格中的 Gigabit 傳輸速度, 8 條線都要確實連接, 假如只有 pin 1, 2, 3, 6 接線, 則傳輸速度將會降為 100 Mega bit/sec. 另外, 1000BASE‑T 的無遮蔽雙絞銅線, 建議每段最長為 100 m. EIA/TIA 568B 的標準雙絞線 (兩端採相同色線排列) 腳位: 接頭朝前, 耳朵朝下 (橘藍綠棕, 白線在前, 排好後, 藍白與綠白對調) 顏色: 橘白-橘-綠白-藍-藍白-綠-棕白-棕 Cross Over (EIA/TIA 568B) 線 (一端採標準 EIA/TIA 568B 色線排列, 另一端則將綠線與橘線對調) 腳位: 接頭朝前, 耳朵朝下 顏色: 綠白-綠-橘白-藍-藍白-橘-棕白-棕 (即將上面正常線的橘線與綠線對調) 最後, 假如要利用 Raspberry Pi 3 打造成為 Wifi 的 Access Point, 可以參考 http://blog.itist.tw/2016/03/using-raspberry-pi-3-as-wifi-ap-with-raspbian-jessie.html 與 http://raspberry-at-home.com/hotspot-wifi-access-point/ 與 https://frillip.com/using-your-raspberry-pi-3-as-a-wifi-access-point-with-hostapd/"},{"url":"http://cadlab.mde.tw/post/kmol-2016-spring-portable-tool.html","tags":"資源","title":"KMOL 2016 Spring Portable Tool","text":"針對 cadlab 上計算機程式、網際內容管理、電腦輔助設計實習與協同產品設計實習等課程, 採用 Python 3.4 打造的 Windows 版可攜程式套件 可攜套件倉儲: https://github.com/chiamingyen/kmol2016 kmol2016 下載: https://my.pcloud.com/publink/show?code=XZH5J4ZOj9C9aomi5F1DtnuQNIHYLDO7EjX"},{"url":"http://cadlab.mde.tw/post/shi-yong-zhe-gong-xian-wen-zhang-biao-ti.html","tags":"參考","title":"使用者貢獻文章標題","text":"使用者貢獻文章的參考 Leo Editor 檔案 本網誌的系統與靜態資料為一個 Github 倉儲 https://github.com/cad-lab/blog , 只要符合 GNU AFFERO GENERAL PUBLIC LICENSE 授權規範, 任何人都可以取用. 本網誌的規劃是希望透過 Gmail 的認証取得參與協同著作的權限後, 各作者可以利用 users 目錄下的 .leo 檔案, 各自維護自己的文章, 基本要求是, 每篇文章, 必須以使用者帳號作為開頭, 並建議依照日期分類, 以避免各用戶的文章彼此覆蓋. 各用戶若需要協同著作, 共同維護一篇 content 目錄中的某一個 .md 檔案, 那麼各用戶在 gh-pages 倉儲分支版本提交與推送過程, 就必須設法處理版本內容的衝突, 但各 .md 檔案建議是在 Leo Editor @edit 或@clean 節點下進行協同編輯並處理內容衝突. 下圖為機械設計工程系即時網路連線:"},{"url":"http://cadlab.mde.tw/post/shi-yong-zhe-gong-xian-wen-zhang-biao-ti-can-kao.html","tags":"參考","title":"使用者貢獻文章標題(參考)","text":"使用者貢獻文章的參考 Leo Editor 檔案 使用者貢獻文章的內容"}]}